<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Tool" referent="RBX0">
		<Properties>
			<bool name="CanBeDropped">true</bool>
			<bool name="Enabled">true</bool>
			<CoordinateFrame name="Grip">
				<X>0</X>
				<Y>-0.100000001</Y>
				<Z>0.300000012</Z>
				<R00>0.90270108</R00>
				<R01>-0.182986572</R01>
				<R02>-0.389418334</R02>
				<R10>-0.413517714</R10>
				<R11>-0.118885815</R11>
				<R12>-0.90270108</R12>
				<R20>0.11888586</R20>
				<R21>0.97590065</R21>
				<R22>-0.182986543</R22>
			</CoordinateFrame>
			<string name="Name">SnakeStaff</string>
			<Content name="TextureId"><url>http://www.roblox.com/asset/?id=82230051</url></Content>
			<string name="ToolTip">Snake Staff</string>
		</Properties>
		<Item class="Part" referent="RBX1">
			<Properties>
				<bool name="Anchored">false</bool>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">4</token>
				<token name="BottomSurfaceInput">0</token>
				<int name="BrickColor">194</int>
				<CoordinateFrame name="CFrame">
					<X>0.600000381</X>
					<Y>2.79999852</Y>
					<Z>-0.399999619</Z>
					<R00>1</R00>
					<R01>-0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>-0</R11>
					<R12>1</R12>
					<R20>0</R20>
					<R21>-1</R21>
					<R22>0</R22>
				</CoordinateFrame>
				<bool name="CanCollide">false</bool>
				<float name="Elasticity">0.5</float>
				<float name="Friction">0.300000012</float>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">false</bool>
				<token name="Material">256</token>
				<string name="Name">Handle</string>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">3</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<token name="formFactorRaw">3</token>
				<token name="shape">1</token>
				<Vector3 name="size">
					<X>0.800000012</X>
					<Y>0.800000012</Y>
					<Z>5.5</Z>
				</Vector3>
			</Properties>
			<Item class="SpecialMesh" referent="RBX2">
				<Properties>
					<token name="LODX">2</token>
					<token name="LODY">2</token>
					<Content name="MeshId"><url>http://www.roblox.com/asset/?id=82229883</url></Content>
					<token name="MeshType">5</token>
					<string name="Name">Mesh</string>
					<Vector3 name="Offset">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<Vector3 name="Scale">
						<X>1</X>
						<Y>1</Y>
						<Z>1</Z>
					</Vector3>
					<Content name="TextureId"><url>http://www.roblox.com/asset/?id=82229891</url></Content>
					<Vector3 name="VertexColor">
						<X>1</X>
						<Y>1</Y>
						<Z>1</Z>
					</Vector3>
				</Properties>
			</Item>
			<Item class="Sound" referent="RBX3">
				<Properties>
					<bool name="Looped">false</bool>
					<string name="Name">SlashSound</string>
					<float name="Pitch">1</float>
					<bool name="PlayOnRemove">false</bool>
					<Content name="SoundId"><url>http://www.roblox.com/asset/?id=46760716</url></Content>
					<float name="Volume">1</float>
				</Properties>
			</Item>
			<Item class="Sound" referent="RBX4">
				<Properties>
					<bool name="Looped">false</bool>
					<string name="Name">FireSound</string>
					<float name="Pitch">0.300000012</float>
					<bool name="PlayOnRemove">false</bool>
					<Content name="SoundId"><url>rbxasset://sounds//Rubber band sling shot.wav</url></Content>
					<float name="Volume">1</float>
				</Properties>
			</Item>
			<Item class="Sound" referent="RBX5">
				<Properties>
					<bool name="Looped">false</bool>
					<string name="Name">FieldSound</string>
					<float name="Pitch">0.600000024</float>
					<bool name="PlayOnRemove">true</bool>
					<Content name="SoundId"><url>http://www.roblox.com/asset?id=1369158</url></Content>
					<float name="Volume">1</float>
				</Properties>
			</Item>
		</Item>
		<Item class="LocalScript" referent="RBX6">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">SnakeStaffLocal</string>
				<ProtectedString name="Source">do
&#9;function CreateSignal()
&#9;&#9;local this = {}
&#9;&#9;local mListeners = {}
&#9;&#9;local mListenerCount = 0
&#9;&#9;local mWaitProxy = nil
&#9;&#9;local mWaitReturns = nil
&#9;&#9;local mHasWaiters = false
&#9;&#9;function this:connect(func)
&#9;&#9;&#9;if self ~= this then error(&quot;connect must be called with `:`, not `.`&quot;, 2) end
&#9;&#9;&#9;if type(func) ~= &apos;function&apos; then
&#9;&#9;&#9;&#9;error(&quot;Argument #1 of connect must be a function, got a &quot;..type(func), 2)
&#9;&#9;&#9;end
&#9;&#9;&#9;mListenerCount = mListenerCount + 1
&#9;&#9;&#9;local conn = {}
&#9;&#9;&#9;function conn:disconnect()
&#9;&#9;&#9;&#9;if mListeners[conn] then
&#9;&#9;&#9;&#9;&#9;mListeners[conn] = nil
&#9;&#9;&#9;&#9;&#9;mListenerCount = mListenerCount - 1
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;mListeners[conn] = func
&#9;&#9;&#9;return conn
&#9;&#9;end
&#9;&#9;function this:disconnect()
&#9;&#9;&#9;if self ~= this then error(&quot;disconnect must be called with `:`, not `.`&quot;, 2) end
&#9;&#9;&#9;for k, v in pairs(mListeners) do
&#9;&#9;&#9;&#9;mListeners[k] = nil
&#9;&#9;&#9;end
&#9;&#9;&#9;mListenerCount = 0
&#9;&#9;end
&#9;&#9;function this:wait()
&#9;&#9;&#9;if self ~= this then error(&quot;wait must be called with `:`, not `.`&quot;, 2) end
&#9;&#9;&#9;if not mWaitProxy then
&#9;&#9;&#9;&#9;mWaitProxy = Instance.new(&apos;BoolValue&apos;)
&#9;&#9;&#9;end
&#9;&#9;&#9;mHasWaiters = true
&#9;&#9;&#9;mWaitProxy.Changed:wait()
&#9;&#9;&#9;return unpack(mWaitReturns)
&#9;&#9;end
&#9;&#9;function this:fire(...)
&#9;&#9;&#9;if self ~= this then error(&quot;fire must be called with `:`, not `.`&quot;, 2) end
&#9;&#9;&#9;local arguments;
&#9;&#9;&#9;if mListenerCount &gt; 0 or mHasWaiters then
&#9;&#9;&#9;&#9;arguments = {...}
&#9;&#9;&#9;end
&#9;&#9;&#9;if mHasWaiters then
&#9;&#9;&#9;&#9;mHasWaiters = false
&#9;&#9;&#9;&#9;mWaitReturns = arguments
&#9;&#9;&#9;&#9;mWaitProxy.Value = not mWaitProxy.Value
&#9;&#9;&#9;&#9;mWaitReturns = nil
&#9;&#9;&#9;end
&#9;&#9;&#9;if mListenerCount &gt; 0 then
&#9;&#9;&#9;&#9;for _, handlerFunc in pairs(mListeners) do
&#9;&#9;&#9;&#9;&#9;Spawn(function()
&#9;&#9;&#9;&#9;&#9;&#9;handlerFunc(unpack(arguments))
&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;function this:fireSync(...)
&#9;&#9;&#9;if self ~= this then error(&quot;fire must be called with `:`, not `.`&quot;, 2) end
&#9;&#9;&#9;local arguments;
&#9;&#9;&#9;if mListenerCount &gt; 0 or mHasWaiters then
&#9;&#9;&#9;&#9;arguments = {...}
&#9;&#9;&#9;end
&#9;&#9;&#9;if mHasWaiters then
&#9;&#9;&#9;&#9;mHasWaiters = false
&#9;&#9;&#9;&#9;mWaitReturns = arguments
&#9;&#9;&#9;&#9;mWaitProxy.Value = not mWaitProxy.Value
&#9;&#9;&#9;&#9;mWaitReturns = nil
&#9;&#9;&#9;end
&#9;&#9;&#9;if mListenerCount &gt; 0 then
&#9;&#9;&#9;&#9;for _, handlerFunc in pairs(mListeners) do
&#9;&#9;&#9;&#9;&#9;handlerFunc(unpack(arguments))
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end&#9;&#9;
&#9;&#9;end
&#9;&#9;return this
&#9;end
&#9;local function Create_PrivImpl(objectType)
&#9;&#9;if type(objectType) ~= &apos;string&apos; then
&#9;&#9;&#9;error(&quot;Argument of Create must be a string&quot;, 2)
&#9;&#9;end
&#9;&#9;return function(dat)
&#9;&#9;&#9;dat = dat or {}
&#9;&#9;&#9;local obj = Instance.new(objectType)
&#9;&#9;&#9;local ctor = nil
&#9;&#9;&#9;for k, v in pairs(dat) do
&#9;&#9;&#9;&#9;if type(k) == &apos;string&apos; then
&#9;&#9;&#9;&#9;&#9;obj[k] = v
&#9;&#9;&#9;&#9;elseif type(k) == &apos;number&apos; then
&#9;&#9;&#9;&#9;&#9;if type(v) ~= &apos;userdata&apos; then
&#9;&#9;&#9;&#9;&#9;&#9;error(&quot;Bad entry in Create body: Numeric keys must be paired with children, got a: &quot;..type(v), 2)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;v.Parent = obj
&#9;&#9;&#9;&#9;elseif type(k) == &apos;table&apos; and k.__eventname then
&#9;&#9;&#9;&#9;&#9;if type(v) ~= &apos;function&apos; then
&#9;&#9;&#9;&#9;&#9;&#9;error(&quot;Bad entry in Create body: Key `[Create.E\&apos;&quot;..k.__eventname..&quot;\&apos;]` must have a function value\
&#9;&#9;&#9;&#9;&#9;&#9;       got: &quot;..tostring(v), 2)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;obj[k.__eventname]:connect(v)
&#9;&#9;&#9;&#9;elseif k == Create then
&#9;&#9;&#9;&#9;&#9;if type(v) ~= &apos;function&apos; then
&#9;&#9;&#9;&#9;&#9;&#9;error(&quot;Bad entry in Create body: Key `[Create]` should be paired with a constructor function, \
&#9;&#9;&#9;&#9;&#9;&#9;       got: &quot;..tostring(v), 2)
&#9;&#9;&#9;&#9;&#9;elseif ctor then
&#9;&#9;&#9;&#9;&#9;&#9;error(&quot;Bad entry in Create body: Only one constructor function is allowed&quot;, 2)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;ctor = v
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;error(&quot;Bad entry (&quot;..tostring(k)..&quot; =&gt; &quot;..tostring(v)..&quot;) in Create body&quot;, 2)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;if ctor then
&#9;&#9;&#9;&#9;ctor(obj)
&#9;&#9;&#9;end
&#9;&#9;&#9;return obj
&#9;&#9;end
&#9;end
&#9;Create = setmetatable({}, {__call = function(tb, ...) return Create_PrivImpl(...) end})
&#9;Create.E = function(eventName)
&#9;&#9;return {__eventname = eventName}
&#9;end
&#9;function class(classname)
&#9;&#9;local classDef = {}
&#9;&#9;local mPublicMethods = {}
&#9;&#9;local mAllMethods = {}
&#9;&#9;local mGetters = {__ClassName = true}
&#9;&#9;local mSetters = {}
&#9;&#9;local mEvents = {}
&#9;&#9;local function fmtKey(key)
&#9;&#9;&#9;if type(key) == &apos;string&apos; then
&#9;&#9;&#9;&#9;return &apos;.&apos;..key
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;return &apos;[&apos;..tostring(key)..&apos;]&apos;
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;return function(implementer)
&#9;&#9;&#9;if type(implementer) ~= &apos;function&apos; then
&#9;&#9;&#9;&#9;error(&quot;Only functions ay be used as a class body definition, got a &quot;..type(implementer), 2)
&#9;&#9;&#9;end
&#9;&#9;&#9;local setProxy = setmetatable({}, {
&#9;&#9;&#9;&#9;__index = function(tb, key)
&#9;&#9;&#9;&#9;&#9;return setmetatable({}, {
&#9;&#9;&#9;&#9;&#9;&#9;__call = function(tb, ...)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if #{...} &gt; 0 then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;error(&apos;Passing arguments to classdef.set&apos;..fmtKey(key)..&apos;() has no meaning, \
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;       see documentation for correct usage.&apos;, 2)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if mSetters[key] then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;error(&apos;Redefinition of setter for &apos;..tostring(key), 2)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;mSetters[key] = true
&#9;&#9;&#9;&#9;&#9;&#9;end;
&#9;&#9;&#9;&#9;&#9;})
&#9;&#9;&#9;&#9;end;
&#9;&#9;&#9;&#9;__newindex = function(tb, key, val)
&#9;&#9;&#9;&#9;&#9;if type(key) == &apos;string&apos; and type(val) == &apos;function&apos; then
&#9;&#9;&#9;&#9;&#9;&#9;if mSetters[key] then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;error(&apos;Redefinition of setter for &apos;..tostring(key), 2)
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;mSetters[key] = val
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;error(&apos;Can\&apos;t set classdef.set&apos;..fmtKey(key)..&apos; = &apos;..tostring(val), 2)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end;
&#9;&#9;&#9;})
&#9;&#9;&#9;local getProxy = setmetatable({}, {
&#9;&#9;&#9;&#9;__index = function(tb, key)
&#9;&#9;&#9;&#9;&#9;return setmetatable({}, {
&#9;&#9;&#9;&#9;&#9;&#9;__call = function(tb, ...)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if #{...} &gt; 0 then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;error(&apos;Passing arguments to classdef.get&apos;..fmtKey(key)..&apos;() has no meaning, \
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;       see documentation for correct usage.&apos;, 2)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if mGetters[key] then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;error(&apos;Redefinition of getter for &apos;..tostring(key), 2)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;mGetters[key] = true
&#9;&#9;&#9;&#9;&#9;&#9;end;
&#9;&#9;&#9;&#9;&#9;})
&#9;&#9;&#9;&#9;end;
&#9;&#9;&#9;&#9;__newindex = function(tb, key, val)
&#9;&#9;&#9;&#9;&#9;if type(key) == &apos;string&apos; and type(val) == &apos;function&apos; then
&#9;&#9;&#9;&#9;&#9;&#9;if mGetters[key] then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;error(&apos;Redefinition of getter for &apos;..tostring(key), 2)
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;mGetters[key] = val
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;error(&apos;Can\&apos;t set classdef.get&apos;..fmtKey(key)..&apos; = &apos;..tostring(val), 2)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end;
&#9;&#9;&#9;})
&#9;&#9;&#9;local getsetProxy = setmetatable({}, {
&#9;&#9;&#9;&#9;__index = function(tb, key)
&#9;&#9;&#9;&#9;&#9;return setmetatable({}, {
&#9;&#9;&#9;&#9;&#9;&#9;__call = function(tb, ...)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if #{...} &gt; 0 then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;error(&apos;Passing arguments to classdef.getset&apos;..fmtKey(key)..&apos;() has no meaning, \
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;       see documentation for correct usage.&apos;, 2)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if mSetters[key] then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;error(&apos;Redefinition of setter for &apos;..tostring(key), 2)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if mGetters[key] then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;error(&apos;Redefinition of getter for &apos;..tostring(key), 2)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;mSetters[key] = true
&#9;&#9;&#9;&#9;&#9;&#9;&#9;mGetters[key] = true
&#9;&#9;&#9;&#9;&#9;&#9;end;
&#9;&#9;&#9;&#9;&#9;})
&#9;&#9;&#9;&#9;end;
&#9;&#9;&#9;&#9;__newindex = function(tb, key, val)
&#9;&#9;&#9;&#9;&#9;error(&apos;Can\&apos;t set classdef.set&apos;..fmtKey(key)..&apos; = &apos;..tostring(val), 2)
&#9;&#9;&#9;&#9;end;
&#9;&#9;&#9;})
&#9;&#9;&#9;local eventProxy = setmetatable({}, {
&#9;&#9;&#9;&#9;__index = function(tb, key)
&#9;&#9;&#9;&#9;&#9;return setmetatable({}, {
&#9;&#9;&#9;&#9;&#9;&#9;__call = function(tb, ...)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if #{...} &gt; 0 then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;error(&quot;Passing arguments to clasdef.event&quot;..fmtKey(key)..&quot;() has no meaning, \
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;       see documentation for correct usage.&quot;, 2)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if type(key) ~= &apos;string&apos; then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;error(&quot;Can&apos;t create event `&quot;..tostring(key)..&quot;` event names must be strings&quot;, 2)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if mEvents[key] then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;error(&quot;Redefinition of event `&quot;..key..&quot;`&quot;, 2)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;mEvents[key] = true
&#9;&#9;&#9;&#9;&#9;&#9;&#9;mGetters[key] = true
&#9;&#9;&#9;&#9;&#9;&#9;end;
&#9;&#9;&#9;&#9;&#9;&#9;__index = function()
&#9;&#9;&#9;&#9;&#9;&#9;&#9;error(&quot;classdef.event&quot;..fmtKey(key)..&quot; can only be called, not indexed&quot;, 2)
&#9;&#9;&#9;&#9;&#9;&#9;end;
&#9;&#9;&#9;&#9;&#9;&#9;__newindex = function()
&#9;&#9;&#9;&#9;&#9;&#9;&#9;error(&quot;classdef.event&quot;..fmtKey(key)..&quot; can only be called, not assigned to&quot;, 2)
&#9;&#9;&#9;&#9;&#9;&#9;end;
&#9;&#9;&#9;&#9;&#9;})
&#9;&#9;&#9;&#9;end;
&#9;&#9;&#9;&#9;__newindex = function(tb, key, val)
&#9;&#9;&#9;&#9;&#9;error(&quot;Can&apos;t set classdef.event&quot;..fmtKey(key)..&quot; = &quot;..tostring(val), 2)
&#9;&#9;&#9;&#9;end;
&#9;&#9;&#9;})
&#9;&#9;&#9;local staticProxy = setmetatable({}, {
&#9;&#9;&#9;&#9;__index = classDef,
&#9;&#9;&#9;&#9;__newindex = classDef,
&#9;&#9;&#9;})
&#9;&#9;&#9;local privateProxy = setmetatable({}, {
&#9;&#9;&#9;&#9;__newindex = function(tb, key, val)
&#9;&#9;&#9;&#9;&#9;if type(key) == &apos;string&apos; and type(val) == &apos;function&apos; then
&#9;&#9;&#9;&#9;&#9;&#9;mAllMethods[key] = val
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;error(&quot;Can&apos;t set classdef.private&quot;..fmtKey(key)..&quot; = &quot;..tostring(val), 2)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end;
&#9;&#9;&#9;&#9;__index = function(tb, key)
&#9;&#9;&#9;&#9;&#9;error(&quot;Can&apos;t get classdef.private&quot;..fmtKey(key), 2)
&#9;&#9;&#9;&#9;end;
&#9;&#9;&#9;})
&#9;&#9;&#9;local mainImplProxy = {}
&#9;&#9;&#9;mainImplProxy.get = getProxy
&#9;&#9;&#9;mainImplProxy.set = setProxy
&#9;&#9;&#9;mainImplProxy.getset = getsetProxy
&#9;&#9;&#9;mainImplProxy.event = eventProxy
&#9;&#9;&#9;mainImplProxy.private = privateProxy
&#9;&#9;&#9;mainImplProxy.static = staticProxy
&#9;&#9;&#9;setmetatable(mainImplProxy, {
&#9;&#9;&#9;&#9;__index = function(tb, key)
&#9;&#9;&#9;&#9;&#9;error(&apos;Can\&apos;t get classdef&apos;..fmtKey(key), 2)
&#9;&#9;&#9;&#9;end; 
&#9;&#9;&#9;&#9;__newindex = function(tb, key, val)
&#9;&#9;&#9;&#9;&#9;if type(key) == &apos;string&apos; and type(val) == &apos;function&apos; then
&#9;&#9;&#9;&#9;&#9;&#9;mPublicMethods[key] = val
&#9;&#9;&#9;&#9;&#9;&#9;mAllMethods[key] = val
&#9;&#9;&#9;&#9;&#9;&#9;mGetters[key] = true
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;error(&apos;Can\&apos;t set classdef&apos;..fmtKey(key)..&apos; = &apos;..tostring(val), 2)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end;
&#9;&#9;&#9;})
&#9;&#9;&#9;implementer(mainImplProxy)
&#9;&#9;&#9;for k, f in pairs(mAllMethods) do
&#9;&#9;&#9;&#9;if k ~= &apos;Create&apos; then
&#9;&#9;&#9;&#9;&#9;mAllMethods[k] = function(self, ...)
&#9;&#9;&#9;&#9;&#9;&#9;if type(self) ~= &apos;table&apos; or self.__ClassName ~= classname then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;error(&quot;Methods must be called with a &apos;:&apos;, not a &apos;.&apos;&quot;)
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;return f(rawget(self, &apos;__internal&apos;), ...)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;if mPublicMethods[k] then
&#9;&#9;&#9;&#9;&#9;&#9;mPublicMethods[k] = mAllMethods[k]
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;for k, f in pairs(mGetters) do
&#9;&#9;&#9;&#9;if type(f) == &apos;function&apos; then
&#9;&#9;&#9;&#9;&#9;mGetters[k] = function(self, ...)
&#9;&#9;&#9;&#9;&#9;&#9;return f(rawget(self, &apos;__internal&apos;), ...)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;for k, f in pairs(mSetters) do
&#9;&#9;&#9;&#9;if type(f) == &apos;function&apos; then
&#9;&#9;&#9;&#9;&#9;mSetters[k] = function(self, ...)
&#9;&#9;&#9;&#9;&#9;&#9;return f(rawget(self, &apos;__internal&apos;), ...)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;local internalMT = {
&#9;&#9;&#9;&#9;__index = mAllMethods;
&#9;&#9;&#9;}
&#9;&#9;&#9;local rawget = rawget 
&#9;&#9;&#9;local externalMT = {
&#9;&#9;&#9;&#9;__index = function(obj, key)
&#9;&#9;&#9;&#9;&#9;local method = mPublicMethods[key]
&#9;&#9;&#9;&#9;&#9;if method then
&#9;&#9;&#9;&#9;&#9;&#9;return method
&#9;&#9;&#9;&#9;&#9;elseif mGetters[key] == true then
&#9;&#9;&#9;&#9;&#9;&#9;return rawget(obj, &apos;__internal&apos;)[key]
&#9;&#9;&#9;&#9;&#9;elseif mGetters[key] then
&#9;&#9;&#9;&#9;&#9;&#9;return mGetters[key](obj)
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;error(&quot;Can&apos;t get &quot;..classname..&quot;::&quot;..key, 2)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end;
&#9;&#9;&#9;&#9;__newindex = function(obj, key, val)
&#9;&#9;&#9;&#9;&#9;if mSetters[key] == true then
&#9;&#9;&#9;&#9;&#9;&#9;rawget(obj, &apos;__internal&apos;)[key] = val
&#9;&#9;&#9;&#9;&#9;elseif mSetters[key] then
&#9;&#9;&#9;&#9;&#9;&#9;mSetters[key](obj, val)
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;error(&quot;Can&apos;t set &quot;..classname..&quot;::&quot;..key, 2)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end;
&#9;&#9;&#9;}
&#9;&#9;&#9;local constructor = function(...)
&#9;&#9;&#9;&#9;local internalThis = {__ClassName = classname}
&#9;&#9;&#9;&#9;internalThis.__internal = internalThis
&#9;&#9;&#9;&#9;setmetatable(internalThis, internalMT)
&#9;&#9;&#9;&#9;local externalThis = {__internal = internalThis}
&#9;&#9;&#9;&#9;setmetatable(externalThis, externalMT)
&#9;&#9;&#9;&#9;for eventName, _ in pairs(mEvents) do
&#9;&#9;&#9;&#9;&#9;internalThis[eventName] = CreateSignal()
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if mAllMethods.Create then
&#9;&#9;&#9;&#9;&#9;mAllMethods.Create(internalThis, ...)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;return externalThis
&#9;&#9;&#9;end
&#9;&#9;&#9;classDef.Create = constructor
&#9;&#9;&#9;getfenv(0)[&apos;Create&apos;..classname] = constructor
&#9;&#9;&#9;getfenv(0)[classname] = classDef
&#9;&#9;end
&#9;end


&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------

&#9;--===============================================================================
&#9;-- A tree object for quick verification of the object hierarchy that a game or
&#9;-- gear may need to be present. The tree returns a &quot;filter&quot; function which can
&#9;-- be called on an instance to flatten it into a tag map, so that in the future
&#9;-- the objects in the hierarchy can safely be accessed through the tag map
&#9;-- without need for extra checks of existance. If the hierarchy is not valid
&#9;-- then nothing is returned from the call to the filter.
&#9;--
&#9;-- Below some common examples of how to construct a tree are given, and the
&#9;-- Gearlib includes the most common examples which veryify various parts of
&#9;-- the character depending on the needs of the gear.
&#9;--
&#9;--===============================================================================
&#9;function tree(name)
&#9;&#9;if type(name) == &apos;string&apos; then
&#9;&#9;&#9;return function(dat)
&#9;&#9;&#9;&#9;return function(instance, ctx)
&#9;&#9;&#9;&#9;&#9;local child = instance:FindFirstChild(name)
&#9;&#9;&#9;&#9;&#9;if not child then return false end 
&#9;&#9;&#9;&#9;&#9;if dat.IsA and not child:IsA(dat.IsA) then return false end
&#9;&#9;&#9;&#9;&#9;if dat.Tag then
&#9;&#9;&#9;&#9;&#9;&#9;ctx[dat.Tag] = child
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;for i = 1, #dat do
&#9;&#9;&#9;&#9;&#9;&#9;if not dat[i](child, ctx) then return false end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;return true
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;return function(dat)
&#9;&#9;&#9;&#9;return function(instance)
&#9;&#9;&#9;&#9;&#9;local ctx = {}
&#9;&#9;&#9;&#9;&#9;if dat.IsA and not instance:IsA(dat.IsA) then return nil end
&#9;&#9;&#9;&#9;&#9;if dat.Tag then ctx[dat.Tag] = instance end
&#9;&#9;&#9;&#9;&#9;for i = 1, #dat do
&#9;&#9;&#9;&#9;&#9;&#9;if not dat[i](instance, ctx) then return nil end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;return ctx
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;--===============================================================================
&#9;-- A tree which verifys all parts of a character including legs.
&#9;-- Tags Declared:
&#9;--  Character: the root character model
&#9;--  LeftArm, RightArm, LeftLeg, RightLeg, Head: The appendages
&#9;--  Humanoid: The humanoid
&#9;--  
&#9;local CharacterFullTree = tree{
&#9;&#9;IsA = &apos;Model&apos;;
&#9;&#9;Tag = &apos;Character&apos;;
&#9;&#9;--
&#9;&#9;tree&apos;Left Arm&apos;{
&#9;&#9;&#9;IsA = &apos;BasePart&apos;;
&#9;&#9;&#9;Tag = &apos;LeftArm&apos;;
&#9;&#9;};
&#9;&#9;tree&apos;Right Arm&apos;{
&#9;&#9;&#9;IsA = &apos;BasePart&apos;;
&#9;&#9;&#9;Tag = &apos;RightArm&apos;;
&#9;&#9;};
&#9;&#9;tree&apos;Left Arm&apos;{
&#9;&#9;&#9;IsA = &apos;BasePart&apos;;
&#9;&#9;&#9;Tag = &apos;LeftArm&apos;;
&#9;&#9;};
&#9;&#9;tree&apos;Right Arm&apos;{
&#9;&#9;&#9;IsA = &apos;BasePart&apos;;
&#9;&#9;&#9;Tag = &apos;RightArm&apos;;
&#9;&#9;};
&#9;&#9;tree&apos;Head&apos;{
&#9;&#9;&#9;IsA = &apos;BasePart&apos;;
&#9;&#9;&#9;Tag = &apos;Head&apos;;
&#9;&#9;};
&#9;&#9;tree&apos;Humanoid&apos;{
&#9;&#9;&#9;IsA = &apos;Humanoid&apos;;
&#9;&#9;&#9;Tag = &apos;Humanoid&apos;;
&#9;&#9;};
&#9;}

&#9;--===============================================================================
&#9;-- A tree with just the parts for a basic gear.
&#9;-- Tags Declared:
&#9;--  Character: The root character object
&#9;--  RightArm
&#9;--  Torso
&#9;--  Humanoid
&#9;local CharacterRightArmTree = tree{
&#9;&#9;IsA = &apos;Model&apos;;
&#9;&#9;Tag = &apos;Character&apos;;
&#9;&#9;--
&#9;&#9;tree&apos;Right Arm&apos;{
&#9;&#9;&#9;IsA = &apos;BasePart&apos;;
&#9;&#9;&#9;Tag = &apos;RightArm&apos;;
&#9;&#9;};
&#9;&#9;tree&apos;Torso&apos;{
&#9;&#9;&#9;IsA = &apos;BasePart&apos;;
&#9;&#9;&#9;Tag = &apos;Torso&apos;;
&#9;&#9;};
&#9;&#9;tree&apos;Humanoid&apos;{
&#9;&#9;&#9;IsA = &apos;BasePart&apos;;
&#9;&#9;&#9;Tag = &apos;Humanoid&apos;;
&#9;&#9;};
&#9;}


&#9;--===============================================================================
&#9;-- A class for maintaining a list of assets that the gear uses. The assets can
&#9;-- be added as a list or one by one, and then requested as for various purposes,
&#9;-- such as as individual sounds or meshes, or more specifically such as for a set
&#9;-- of animations on a given humanoid.
&#9;class&apos;AssetProvider&apos;(function(def)
&#9;&#9;function def:Create()
&#9;&#9;&#9;self.Model = script.Parent:FindFirstChild(&apos;assets&apos;)
&#9;&#9;&#9;if not self.Model then
&#9;&#9;&#9;&#9;self.Model = Create&apos;Model&apos;{
&#9;&#9;&#9;&#9;&#9;Name = &quot;assets&quot;;
&#9;&#9;&#9;&#9;&#9;Parent = script.Parent;
&#9;&#9;&#9;&#9;}
&#9;&#9;&#9;end
&#9;&#9;end



&#9;&#9;--functionality to register various types of asset
&#9;&#9;function def:RegisterMesh(tag, id, scale)
&#9;&#9;&#9;if not self.Model:FindFirstChild(tag) then
&#9;&#9;&#9;&#9;local mesh = Create&apos;SpecialMesh&apos;{
&#9;&#9;&#9;&#9;&#9;Name = tag;
&#9;&#9;&#9;&#9;&#9;MeshId = self:ToAssetId(id);
&#9;&#9;&#9;&#9;&#9;Parent = self.Model;
&#9;&#9;&#9;&#9;}
&#9;&#9;&#9;&#9;if scale then
&#9;&#9;&#9;&#9;&#9;mesh.Scale = scale
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;function def:RegisterAnim(tag, id, speed, fadeTime)
&#9;&#9;&#9;if not self.Model:FindFirstChild(tag) then
&#9;&#9;&#9;&#9;local obj = Create&apos;Animation&apos;{
&#9;&#9;&#9;&#9;&#9;Name = tag;
&#9;&#9;&#9;&#9;&#9;AnimationId = self:ToAssetId(id);
&#9;&#9;&#9;&#9;&#9;Parent = self.Model;
&#9;&#9;&#9;&#9;}
&#9;&#9;&#9;&#9;if speed then
&#9;&#9;&#9;&#9;&#9;Create&apos;NumberValue&apos;{
&#9;&#9;&#9;&#9;&#9;&#9;Name = &apos;speed&apos;;
&#9;&#9;&#9;&#9;&#9;&#9;Value = speed;
&#9;&#9;&#9;&#9;&#9;&#9;Parent = obj;
&#9;&#9;&#9;&#9;&#9;}
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if fadeTime then
&#9;&#9;&#9;&#9;&#9;Create&apos;NumberValue&apos;{
&#9;&#9;&#9;&#9;&#9;&#9;Name = &apos;fadeTime&apos;;
&#9;&#9;&#9;&#9;&#9;&#9;Value = fadeTime;
&#9;&#9;&#9;&#9;&#9;&#9;Parent = obj;
&#9;&#9;&#9;&#9;&#9;}
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;function def:RegisterSound(tag, id, volume, pitch)
&#9;&#9;&#9;if not self.Model:FindFirstChild(tag) then
&#9;&#9;&#9;&#9;local sound = Create&apos;Sound&apos;{
&#9;&#9;&#9;&#9;&#9;Name = tag;
&#9;&#9;&#9;&#9;&#9;SoundId = self:ToAssetId(id);
&#9;&#9;&#9;&#9;&#9;Parent = self.Model;
&#9;&#9;&#9;&#9;}
&#9;&#9;&#9;&#9;if volume then
&#9;&#9;&#9;&#9;&#9;sound.Volume = volume
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if pitch then
&#9;&#9;&#9;&#9;&#9;sound.Pitch = pitch
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end



&#9;&#9;--functionality to create instances of various asset types
&#9;&#9;function def:CreateSound(tag, volume, pitch)
&#9;&#9;&#9;if self.Model:FindFirstChild(tag) then
&#9;&#9;&#9;&#9;local obj = self.Model:FindFirstChild(tag):Clone()
&#9;&#9;&#9;&#9;if volume then
&#9;&#9;&#9;&#9;&#9;obj.Volume = volume
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if pitch then
&#9;&#9;&#9;&#9;&#9;obj.Pitch = pitch
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;return obj
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;function def:CreateMesh(tag, scale)
&#9;&#9;&#9;if self.Model:FindFirstChild(tag) then
&#9;&#9;&#9;&#9;local obj = self.Model:FindFirstChild(tag):Clone()
&#9;&#9;&#9;&#9;if scale then
&#9;&#9;&#9;&#9;&#9;obj.Scale = scale
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;return obj
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;function def:CreateAnimator(humanoid)
&#9;&#9;&#9;local anims = {}
&#9;&#9;&#9;for _, anim in pairs(self.Model:GetChildren()) do
&#9;&#9;&#9;&#9;if anim:IsA(&apos;Animation&apos;) then
&#9;&#9;&#9;&#9;&#9;local track = humanoid:LoadAnimation(anim)
&#9;&#9;&#9;&#9;&#9;--
&#9;&#9;&#9;&#9;&#9;local proxy = {}
&#9;&#9;&#9;&#9;&#9;local defaultSpeed, defaultFade;
&#9;&#9;&#9;&#9;&#9;if anim:FindFirstChild(&apos;speed&apos;) then
&#9;&#9;&#9;&#9;&#9;&#9;defaultSpeed = anim:FindFirstChild(&apos;speed&apos;).Value
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;if anim:FindFirstChild(&apos;fadeTime&apos;) then
&#9;&#9;&#9;&#9;&#9;&#9;defaultFade = anim:FindFirstChild(&apos;fadeTime&apos;).Value
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;function proxy:Play(speed, fadeTime)
&#9;&#9;&#9;&#9;&#9;&#9;track:Play(fadeTime or defaultFade or 0.1, 1, speed or defaultSpeed or 1)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;function proxy:Stop(fadeTime)
&#9;&#9;&#9;&#9;&#9;&#9;track:Stop(fadeTime or defaultFade or 0.1)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;proxy.KeyframeReached = track.KeyframeReached
&#9;&#9;&#9;&#9;&#9;--
&#9;&#9;&#9;&#9;&#9;anims[anim.Name] = proxy
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;--
&#9;&#9;&#9;local animator = setmetatable({}, {__index=anims})
&#9;&#9;&#9;function animator:StopAll(fadeTime)
&#9;&#9;&#9;&#9;for _, anim in pairs(anims) do
&#9;&#9;&#9;&#9;&#9;anim:Stop(fadeTime)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;return animator
&#9;&#9;end

&#9;&#9;function def.private:ToAssetId(id)
&#9;&#9;&#9;if type(id) == &apos;string&apos; then
&#9;&#9;&#9;&#9;return id
&#9;&#9;&#9;elseif type(id) == &apos;number&apos; then
&#9;&#9;&#9;&#9;return &apos;http://www.roblox.com/asset/?id=&apos;..id
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end)


&#9;function CreateMutexFunction(task)
&#9;&#9;local running = false
&#9;&#9;return function(...)
&#9;&#9;&#9;if not running then
&#9;&#9;&#9;&#9;return task(...)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end


&#9;function CreateGlobalVarList()
&#9;&#9;local this = {}
&#9;&#9;local waitingOn = {}
&#9;&#9;--
&#9;&#9;local data = script.Parent:FindFirstChild(&apos;data&apos;)
&#9;&#9;if not data then
&#9;&#9;&#9;if script:IsA(&apos;LocalScript&apos;) then
&#9;&#9;&#9;&#9;data = Create&apos;Model&apos;{
&#9;&#9;&#9;&#9;&#9;Name = &apos;data&apos;;
&#9;&#9;&#9;&#9;&#9;Parent = script.Parent;
&#9;&#9;&#9;&#9;}&#9;
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;repeat wait() until script.Parent:FindFirstChild(&apos;data&apos;)
&#9;&#9;&#9;&#9;data = script.Parent:FindFirstChild(&apos;data&apos;)&#9;&#9;&#9;
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;--
&#9;&#9;function this:Create(tag, type, default)
&#9;&#9;&#9;if not data:FindFirstChild(tag) then
&#9;&#9;&#9;&#9;if script:IsA(&apos;LocalScript&apos;) then
&#9;&#9;&#9;&#9;&#9;Create(type..&apos;Value&apos;){
&#9;&#9;&#9;&#9;&#9;&#9;Name = tag;
&#9;&#9;&#9;&#9;&#9;&#9;Parent = data;
&#9;&#9;&#9;&#9;&#9;&#9;Value = default;
&#9;&#9;&#9;&#9;&#9;}
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;waitingOn[tag] = true
&#9;&#9;&#9;&#9;&#9;repeat wait() until data:FindFirstChild(tag)
&#9;&#9;&#9;&#9;&#9;waitingOn[tag] = nil
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;--
&#9;&#9;setmetatable(this, {
&#9;&#9;&#9;__index = function(tb, inx)
&#9;&#9;&#9;&#9;if inx == &apos;Create&apos; then
&#9;&#9;&#9;&#9;&#9;return this.Create
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;local val = data:FindFirstChild(inx)
&#9;&#9;&#9;&#9;&#9;if val then
&#9;&#9;&#9;&#9;&#9;&#9;return val.Value
&#9;&#9;&#9;&#9;&#9;elseif waitingOn[inx] then
&#9;&#9;&#9;&#9;&#9;&#9;repeat wait() until not waitingOn[inx]
&#9;&#9;&#9;&#9;&#9;&#9;return data[inx].Value
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;error(&apos;Can\&apos;t set global `&apos;..inx..&apos;`, does not exist.&apos;)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end;
&#9;&#9;&#9;__newindex = function(tb, inx, val)
&#9;&#9;&#9;&#9;local obj = data:FindFirstChild(inx)
&#9;&#9;&#9;&#9;if obj then
&#9;&#9;&#9;&#9;&#9;obj.Value = val
&#9;&#9;&#9;&#9;elseif waitingOn[inx] then
&#9;&#9;&#9;&#9;&#9;repeat wait() until not waitingOn[inx]
&#9;&#9;&#9;&#9;&#9;data:FindFirstChild(inx).Value = val
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;error(&apos;Can\&apos;t get global `&apos;..inx..&apos;`, does not exist.&apos;)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end;
&#9;&#9;})
&#9;&#9;return this
&#9;end


&#9;class&apos;Tool&apos;(function(def)
&#9;&#9;function def:Create()
&#9;&#9;&#9;self.Tool = script.Parent
&#9;&#9;&#9;local tool = script.Parent
&#9;&#9;&#9;self.Handle = tool:FindFirstChild(&apos;Handle&apos;)
&#9;&#9;&#9;if not self.Handle then
&#9;&#9;&#9;&#9;if script:IsA(&apos;LocalScript&apos;) then
&#9;&#9;&#9;&#9;&#9;repeat wait() until tool:FindFirstChild(&apos;Handle&apos;)
&#9;&#9;&#9;&#9;&#9;self.Handle = tool.Handle
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;error(&quot;Tool has no `Handle`, did you forget to add one?&quot;)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end

&#9;&#9;&#9;--see which side we&apos;re on, localscript or normal script:
&#9;&#9;&#9;local IsLocal = script:IsA(&apos;LocalScript&apos;)

&#9;&#9;&#9;--set up the damage bin in the tool, so that damage can be inflicted
&#9;&#9;&#9;--from a localscript. The global script side has to create a &quot;damagebin&quot;
&#9;&#9;&#9;--in the tool, and the local side of the tool then puts notifications
&#9;&#9;&#9;--into that madel.
&#9;&#9;&#9;if IsLocal then
&#9;&#9;&#9;&#9;Spawn(function()
&#9;&#9;&#9;&#9;&#9;while not tool:FindFirstChild(&apos;damagebin&apos;) do
&#9;&#9;&#9;&#9;&#9;&#9;tool.ChildAdded:wait()
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;self.DamageBin = tool:FindFirstChild(&apos;damagebin&apos;)
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;self.DamageBin = tool:FindFirstChild(&apos;damagebin&apos;)
&#9;&#9;&#9;&#9;if not self.DamageBin then
&#9;&#9;&#9;&#9;&#9;self.DamageBin = Create&apos;Model&apos;{
&#9;&#9;&#9;&#9;&#9;&#9;Name = &apos;damagebin&apos;;
&#9;&#9;&#9;&#9;&#9;&#9;Parent = tool;
&#9;&#9;&#9;&#9;&#9;}
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;--and listen on the damage bin
&#9;&#9;&#9;&#9;self.DamageBin.ChildAdded:connect(function(ch)
&#9;&#9;&#9;&#9;&#9;local dmg = tonumber(ch.Name)
&#9;&#9;&#9;&#9;&#9;--tag the humanoid
&#9;&#9;&#9;&#9;&#9;local creator = Create&apos;ObjectValue&apos;{
&#9;&#9;&#9;&#9;&#9;&#9;Name = &apos;creator&apos;;
&#9;&#9;&#9;&#9;&#9;&#9;Value = self.Player;
&#9;&#9;&#9;&#9;&#9;&#9;Parent = ch.Value;
&#9;&#9;&#9;&#9;&#9;}
&#9;&#9;&#9;&#9;&#9;wait()
&#9;&#9;&#9;&#9;&#9;ch.Value:TakeDamage(dmg)
&#9;&#9;&#9;&#9;&#9;game.Debris:AddItem(ch, 2)
&#9;&#9;&#9;&#9;&#9;game.Debris:AddItem(creator, 2)
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;end

&#9;&#9;&#9;--create the asset manager
&#9;&#9;&#9;self.Asset = CreateAssetProvider()

&#9;&#9;&#9;--create the global var list
&#9;&#9;&#9;self.Var = CreateGlobalVarList()

&#9;&#9;&#9;--
&#9;&#9;&#9;tool.Equipped:connect(function(mouse)
&#9;&#9;&#9;&#9;--main properties set on selection
&#9;&#9;&#9;&#9;self.Mouse = mouse
&#9;&#9;&#9;&#9;self.MouseDown = false
&#9;&#9;&#9;&#9;self.Selected = true
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;--set up convinience properties
&#9;&#9;&#9;&#9;self.Character = tool.Parent
&#9;&#9;&#9;&#9;self.Player = game.Players:GetPlayerFromCharacter(self.Character)
&#9;&#9;&#9;&#9;self.Head = self.Character:FindFirstChild(&apos;Head&apos;)
&#9;&#9;&#9;&#9;self.Torso = self.Character:FindFirstChild(&apos;Torso&apos;)
&#9;&#9;&#9;&#9;self.Humanoid = self.Character:FindFirstChild(&apos;Humanoid&apos;)
&#9;&#9;&#9;&#9;self.LeftLeg = self.Character:FindFirstChild(&apos;Left Leg&apos;)
&#9;&#9;&#9;&#9;self.RightLeg = self.Character:FindFirstChild(&apos;Right Leg&apos;)
&#9;&#9;&#9;&#9;self.LeftArm = self.Character:FindFirstChild(&apos;Left Arm&apos;)
&#9;&#9;&#9;&#9;self.RightArm = self.Character:FindFirstChild(&apos;Right Arm&apos;)

&#9;&#9;&#9;&#9;--create main the animator for this instance. It won&apos;t be usefull from the
&#9;&#9;&#9;&#9;--global side right now, but it may be in the future, and it is an abstraction
&#9;&#9;&#9;&#9;--so it is possible to make it work even from the global side.
&#9;&#9;&#9;&#9;self.Animator = self.Asset:CreateAnimator(self.Humanoid)
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;--if local, set up the mouse events
&#9;&#9;&#9;&#9;if IsLocal then
&#9;&#9;&#9;&#9;&#9;mouse.Button1Down:connect(function()
&#9;&#9;&#9;&#9;&#9;&#9;self.MouseDown = true
&#9;&#9;&#9;&#9;&#9;&#9;self.Button1Down:fire()
&#9;&#9;&#9;&#9;&#9;end)&#9;
&#9;&#9;&#9;&#9;&#9;mouse.Button1Up:connect(function()
&#9;&#9;&#9;&#9;&#9;&#9;self.MouseDown = false
&#9;&#9;&#9;&#9;&#9;&#9;self.Button1Up:fire()
&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;&#9;&#9;mouse.KeyDown:connect(function(key)
&#9;&#9;&#9;&#9;&#9;&#9;self.KeyDown:fire(key)
&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;&#9;&#9;mouse.KeyUp:connect(function(key)
&#9;&#9;&#9;&#9;&#9;&#9;self.KeyUp:fire(key)
&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;--finally, pass off to the user
&#9;&#9;&#9;&#9;Spawn(function()
&#9;&#9;&#9;&#9;&#9;self.Equipped:fire()
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;end)
&#9;&#9;&#9;tool.Unequipped:connect(function()
&#9;&#9;&#9;&#9;-- FIRST give the tool a chance to do stuff with these properties
&#9;&#9;&#9;&#9;-- before we kill them. That is, the unequipped event fires before
&#9;&#9;&#9;&#9;-- the thing is really unequipped.
&#9;&#9;&#9;&#9;self.Unequipped:fireSync()

&#9;&#9;&#9;&#9;--unset convinience properties
&#9;&#9;&#9;&#9;self.Selected = false
&#9;&#9;&#9;&#9;self.MouseDown = false
&#9;&#9;&#9;&#9;self.Mouse = nil
&#9;&#9;&#9;&#9;self.Character = nil
&#9;&#9;&#9;&#9;--
&#9;&#9;&#9;&#9;self.Head = nil
&#9;&#9;&#9;&#9;self.Torso = nil
&#9;&#9;&#9;&#9;self.Humanoid = nil
&#9;&#9;&#9;&#9;self.LeftArm = nil
&#9;&#9;&#9;&#9;self.RightArm = nil
&#9;&#9;&#9;&#9;self.LeftLeg = nil
&#9;&#9;&#9;&#9;self.RightLeg = nil
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;--kill the old animator. We may be able to reuse it some of the time
&#9;&#9;&#9;&#9;--but the most common use cases are ones where it&apos;s not possible to save, so
&#9;&#9;&#9;&#9;--it&apos;s not worth the extra code comlexity to figure out when we can save it.
&#9;&#9;&#9;&#9;self.Animator = nil
&#9;&#9;&#9;end)
&#9;&#9;end

&#9;&#9;function def:DamageHumanoid(humanoid, damage)
&#9;&#9;&#9;if self.DamageBin then
&#9;&#9;&#9;&#9;(Create&apos;ObjectValue&apos;{
&#9;&#9;&#9;&#9;&#9;Name = tostring(damage);
&#9;&#9;&#9;&#9;&#9;Value = humanoid;
&#9;&#9;&#9;&#9;}).Parent = self.DamageBin
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;Spawn(function()
&#9;&#9;&#9;&#9;&#9;repeat wait() until self.DamageBin
&#9;&#9;&#9;&#9;&#9;Create&apos;ObjectValue&apos;{
&#9;&#9;&#9;&#9;&#9;&#9;Name = tostring(damage);
&#9;&#9;&#9;&#9;&#9;&#9;Value = humanoid;
&#9;&#9;&#9;&#9;&#9;}.Parent = self.DamageBin
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;--============================
&#9;&#9;def.get.Tool()
&#9;&#9;def.get.Player()
&#9;&#9;def.get.Mouse()
&#9;&#9;def.get.MouseDown()
&#9;&#9;def.get.Selected()
&#9;&#9;function def.get:MouseTarget()
&#9;&#9;&#9;if self.Mouse then
&#9;&#9;&#9;&#9;return self.Mouse.Target
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;function def.get:MouseHit()
&#9;&#9;&#9;if self.Mouse then
&#9;&#9;&#9;&#9;return self.Mouse.Hit
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;function def.get:MouseIcon()
&#9;&#9;&#9;if self.Mouse then
&#9;&#9;&#9;&#9;return self.Mouse.Icon
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;function def.set:MouseIcon(icon)
&#9;&#9;&#9;if not self.Mouse then
&#9;&#9;&#9;&#9;error(&quot;Error, Can&apos;t set MouseIcon from a global script!&quot;)
&#9;&#9;&#9;end
&#9;&#9;&#9;self.Mouse.Icon = icon
&#9;&#9;end
&#9;&#9;--
&#9;&#9;def.get.Character()
&#9;&#9;def.get.Humanoid()
&#9;&#9;def.get.LeftArm()
&#9;&#9;def.get.RightArm()
&#9;&#9;def.get.LeftLeg()
&#9;&#9;def.get.RightLeg()
&#9;&#9;def.get.Head()
&#9;&#9;def.get.Torso()
&#9;&#9;def.get.Handle()
&#9;&#9;--
&#9;&#9;def.get.Asset()
&#9;&#9;def.get.Animator()
&#9;&#9;def.get.Var()

&#9;&#9;--=============================
&#9;&#9;def.event.Equipped()
&#9;&#9;def.event.Unequipped()
&#9;&#9;--
&#9;&#9;def.event.Button1Down()
&#9;&#9;def.event.Button1Up()
&#9;&#9;def.event.KeyDown()
&#9;&#9;def.event.KeyUp()
&#9;end)

&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
end
local Tool = CreateTool()

--====================================================================================--
--                                 asset setup code
--====================================================================================--

--animations
Tool.Asset:RegisterAnim(&apos;equip&apos;, 82272273, 4, 0.1)
Tool.Asset:RegisterAnim(&apos;fire&apos;,  82272303, 4, 0.0)
Tool.Asset:RegisterAnim(&apos;slash&apos;, 82272327, 3, 0.0)

--sounds
Tool.Asset:RegisterSound(&apos;slashsharp&apos;,  45885030)

--settings
local DoubleClickThreshold = 0.1

local Reloading = false

local function SingleClick()
&#9;if Reloading then return end
&#9;Reloading = true
&#9;Tool.Mouse.Icon = &apos;rbxasset://textures\\advCursor-default.png&apos;

&#9;--fire a shot
&#9;Tool.Handle.FireSound:Play()
&#9;Tool.Animator.fire:Play()

&#9;--get the heading
&#9;local fireFrom = (Tool.RightArm.CFrame*CFrame.new(0,-2,0)).p
&#9;local fireTo = Tool.Mouse.Hit.p

&#9;--put in the script
&#9;local sc = script.Parent.ShotScript:Clone()
&#9;sc.cframe.Value = CFrame.new(fireFrom, fireTo)
&#9;sc.creator.Value = Tool.Player
&#9;sc.Disabled = false
&#9;sc.Parent = game.Workspace

&#9;wait(1.8)
&#9;Reloading = false
&#9;Tool.Mouse.Icon = &apos;rbxasset://textures\\advCursor-white.png&apos;
end

local ClickId = 0
local function DoubleClick()
&#9;if Reloading then return end
&#9;Reloading = true
&#9;ClickId = ClickId+1
&#9;local ThisClickId = ClickId
&#9;Tool.Mouse.Icon = &apos;rbxasset://textures\\advCursor-default.png&apos;

&#9;--slash
&#9;Tool.Handle.SlashSound:Play()
&#9;Tool.Animator.slash:Play()

&#9;--put in the script
&#9;local sc = script.Parent.SlashScript:Clone()
&#9;sc.position.Value = Tool.Torso.Position
&#9;sc.creator.Value = Tool.Player
&#9;sc.Disabled = false
&#9;sc.Parent = game.Workspace

&#9;wait(0.2)
&#9;Tool.Handle.FieldSound.Volume = 1
&#9;Tool.Handle.FieldSound:Play()
&#9;Spawn(function()
&#9;&#9;for i = 1, 0, -0.03 do
&#9;&#9;&#9;wait(0.03)
&#9;&#9;&#9;if ClickId ~= ThisClickId then return end
&#9;&#9;&#9;Tool.Handle.FieldSound.Volume = i
&#9;&#9;end
&#9;end)

&#9;wait(1.2)
&#9;Reloading = false
&#9;Tool.Mouse.Icon = &apos;rbxasset://textures\\advCursor-white.png&apos;
end

--handlers
local LastClickTime = 0
local DiddoubleClick = false

--the main handler
Tool.Button1Down:connect(function()
&#9;local t = tick()
&#9;if (t-LastClickTime) &lt; 0.25 then
&#9;&#9;LastClickTime = 0
&#9;&#9;DiddoubleClick = true
&#9;&#9;print(&quot;Double&quot;)
&#9;&#9;DoubleClick()
&#9;else
&#9;&#9;LastClickTime = t
&#9;&#9;wait(0.25)
&#9;&#9;if DiddoubleClick then
&#9;&#9;&#9;DiddoubleClick = false
&#9;&#9;else
&#9;&#9;&#9;print(&quot;Single&quot;)
&#9;&#9;&#9;SingleClick()
&#9;&#9;end
&#9;end
end)

Tool.Equipped:connect(function()
&#9;Tool.Mouse.Icon = &apos;rbxasset://textures\\advCursor-white.png&apos;
&#9;Tool.Animator.equip:Play()
end)

Tool.Unequipped:connect(function()
&#9;Tool.Animator.equip:Stop()
end)</ProtectedString>
			</Properties>
			<Item class="Script" referent="RBX7">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">MotorizeRightGrip</string>
					<ProtectedString name="Source">function Create(ty)
&#9;return function(data)
&#9;&#9;local obj = Instance.new(ty)
&#9;&#9;for k, v in pairs(data) do
&#9;&#9;&#9;if type(k) == &apos;number&apos; then
&#9;&#9;&#9;&#9;v.Parent = obj
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;obj[k] = v
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;return obj
&#9;end
end

local Tool = script.Parent.Parent

local armChildRemovedConn = nil
local Motor6DGrip = nil
local EquippedNum = 0

Tool.Equipped:connect(function()
&#9;EquippedNum = EquippedNum + 1
&#9;local myEquip = EquippedNum
&#9;--some vars
&#9;local Player = game.Players:GetPlayerFromCharacter(Tool.Parent)
&#9;local Character = Player.Character

&#9;local rightarm = Character:FindFirstChild(&apos;Right Arm&apos;)
&#9;if rightarm and rightarm:FindFirstChild(&apos;RightGrip&apos;) then
&#9;&#9;local rightGrip = rightarm[&apos;RightGrip&apos;]
&#9;&#9;local handle = rightGrip.Part1

&#9;&#9;--kill my joint when the normal joint is removed
&#9;&#9;--this must be done here so that the joint is removed 
&#9;&#9;--_right away_ after unequipping and the character doesn&apos;t 
&#9;&#9;--glitch up.
&#9;&#9;local armChildRemovedConn = rightarm.ChildRemoved:connect(function(ch)
&#9;&#9;&#9;if ch == rightGrip then
&#9;&#9;&#9;&#9;Motor6DGrip:Remove()
&#9;&#9;&#9;&#9;Motor6DGrip = nil
&#9;&#9;&#9;&#9;--
&#9;&#9;&#9;&#9;if handle and Character:FindFirstChild(&apos;Torso&apos;) then
&#9;&#9;&#9;&#9;&#9;if Tool.Parent.Parent:IsA(&apos;Player&apos;) then
&#9;&#9;&#9;&#9;&#9;&#9;--the sword has been deselected
&#9;&#9;&#9;&#9;&#9;&#9;--put the sword far away so the user doesn&apos;t notice that the handle doesn&apos;t
&#9;&#9;&#9;&#9;&#9;&#9;--update for about 0.1 seconds after selecting the tool.
&#9;&#9;&#9;&#9;&#9;&#9;handle.CFrame = CFrame.new(100000, 100000, 100000)
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;--if in the workspace, position the handle where it should be dropped
&#9;&#9;&#9;&#9;&#9;&#9;--use the size of the handle to make sure it&apos;s dropped far enough away
&#9;&#9;&#9;&#9;&#9;&#9;handle.CFrame = Character.Torso.CFrame * CFrame.new(0, 0, -(handle.Size.magnitude+2))
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end)

&#9;&#9;--make my new joint
&#9;&#9;Motor6DGrip = Create&apos;Motor6D&apos;{
&#9;&#9;&#9;Name = &apos;RightGrip_Motor&apos;,
&#9;&#9;&#9;Part0 = rightarm,
&#9;&#9;&#9;Part1 = handle,
&#9;&#9;}
&#9;&#9;--kill the old weld
&#9;&#9;rightGrip.Part1 = nil
&#9;&#9;rightGrip.Part0 = nil
&#9;&#9;Motor6DGrip.Parent = rightGrip.Parent
&#9;end
end)

Tool.Unequipped:connect(function()
&#9;EquippedNum = EquippedNum + 1
&#9;if armChildRemovedConn then
&#9;&#9;armChildRemovedConn:disconnect()
&#9;&#9;armChildRemovedConn = nil
&#9;end
end)
</ProtectedString>
				</Properties>
			</Item>
		</Item>
		<Item class="Script" referent="RBX8">
			<Properties>
				<bool name="Disabled">true</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">ShotScript</string>
				<ProtectedString name="Source">function WaitFor(name)
&#9;while not script:FindFirstChild(name) do script.ChildAdded:wait() end
&#9;return script[name].Value
end

--get vars
local cframe = WaitFor(&apos;cframe&apos;)
local creator = WaitFor(&apos;creator&apos;)

--get my humanoid
local myHum = creator.Character:FindFirstChild(&apos;Humanoid&apos;)

--main effect code

--the snake bit code. We will be using a lot of &apos;snake bits&apos;
function MakeSnakeBit()
&#9;local part = Instance.new(&apos;Part&apos;)
&#9;part.FormFactor = &apos;Custom&apos;
&#9;part.Size = Vector3.new(1,1,1)
&#9;part.TopSurface = &apos;Weld&apos;
&#9;part.BottomSurface = &apos;Weld&apos;
&#9;part.RightSurface = &apos;Weld&apos;
&#9;part.LeftSurface = &apos;Weld&apos;
&#9;part.FrontSurface = &apos;Weld&apos;
&#9;part.BackSurface = &apos;Weld&apos;
&#9;--part.Material = &apos;Wood&apos;
&#9;part.CanCollide = false
&#9;part.Anchored = true
&#9;part.BrickColor = BrickColor.new(1021) --1021=`Camo`
&#9;local mesh = Instance.new(&apos;SpecialMesh&apos;, part)
&#9;mesh.MeshType = &apos;Sphere&apos;
&#9;return part
end

--slerp function that I need
local function Slerp(t, a, b)
&#9;local om = math.acos(a:Dot(b))
&#9;local sin_om = math.sin(om)
&#9;return (math.sin((1-t)*om)/sin_om)*a + (math.sin(t*om)/sin_om)*b
end

--first, make one bit which will be the &quot;shot&quot; that flies through the air
local shot = MakeSnakeBit()
shot.Parent = game.Workspace
shot.CFrame = cframe --set the initial CFrame

local ShotSpeed = 50
local FlightDist = 0
local FlightMaxDist = 300
local HeatSeekingDistance = 20

--make the shot fly using raycasting. It&apos;s also heat-seeking for nearby players
local LastTime = tick()
local IT = 0
local HeatSeekingTarget = nil


--
function SnareHumanoid(hum, dir)
&#9;--make sure they have a torso
&#9;local torso = hum.Parent:FindFirstChild(&apos;Torso&apos;)
&#9;if not torso then return end

&#9;--set them to platformstanding
&#9;hum.PlatformStand = true

&#9;--tag them. We award KOs for shoving people off of odges
&#9;-- trolollololol
&#9;local tag = script.creator:Clone()
&#9;tag.Parent = hum
&#9;game.Debris:AddItem(tag, 4)

&#9;--and shove them in the direction we were travelling
&#9;local Shove = Instance.new(&apos;BodyVelocity&apos;)
&#9;Shove.Name = &apos;Shove&apos;
&#9;Shove.velocity = dir*100
&#9;Shove.maxForce = Vector3.new(5000,5000,5000)
&#9;Shove.Parent = torso
&#9;game.Debris:AddItem(Shove, 0.2)

&#9;--also do same damage
&#9;hum:TakeDamage(35)

&#9;--create ensnare pieces
&#9;local parts = {}
&#9;for theta = 0, math.pi*4, math.pi/3 do 
&#9;&#9;local dat = {}
&#9;&#9;dat.Part = MakeSnakeBit()
&#9;&#9;dat.Part.Parent = game.Workspace
&#9;&#9;dat.Offset = CFrame.new(math.sin(theta)*2.5, theta/2, math.cos(theta)*2.5)
&#9;&#9;parts[#parts+1] = dat
&#9;end
&#9;for i = 1, #parts-1 do
&#9;&#9;local dat = parts[i]
&#9;&#9;local datNext = parts[i+1]
&#9;&#9;--
&#9;&#9;dat.Part.Size = Vector3.new(0.6, 0.6, (dat.Offset.p-datNext.Offset.p).magnitude+0.4)
&#9;&#9;dat.HOffset = -(dat.Offset.p-datNext.Offset.p).magnitude/2
&#9;end

&#9;--now draw ensnace pieces
&#9;local startT = tick()
&#9;for t = 1, 45 do
&#9;&#9;local elapsed = tick()-startT
&#9;&#9;local trans = math.min(elapsed/1.5, 1)
&#9;&#9;local torsocf = torso.CFrame*CFrame.new(0, elapsed*2-4, 0)*CFrame.Angles(0, (tick()%10000)*6, 0)
&#9;&#9;local thisPos = (torsocf*parts[1].Offset).p
&#9;&#9;for i = 1, #parts-1 do
&#9;&#9;&#9;local this = parts[i]
&#9;&#9;&#9;local nextPos = (torsocf*parts[i+1].Offset).p
&#9;&#9;&#9;this.Part.CFrame = CFrame.new(thisPos, nextPos)*
&#9;&#9;&#9;                   CFrame.new(0, 0, this.HOffset)
&#9;&#9;&#9;this.Part.Transparency = trans
&#9;&#9;&#9;thisPos = nextPos
&#9;&#9;end
&#9;&#9;--
&#9;&#9;wait(0.03)
&#9;end

&#9;--end anim
&#9;for _, dat in pairs(parts) do
&#9;&#9;dat.Part:Destroy()
&#9;end

&#9;--stop standing
&#9;hum.PlatformStand = false
end


while true do
&#9;wait()
&#9;--update the iteration counter
&#9;IT = IT+1

&#9;--get the timestep
&#9;local t = tick()
&#9;local dt = (t-LastTime)
&#9;LastTime = t

&#9;--distance to travel
&#9;local distToTravel = dt*ShotSpeed
&#9;FlightDist = FlightDist + distToTravel

&#9;--max flight distance
&#9;if FlightDist &gt; FlightMaxDist then
&#9;&#9;shot:Destroy()
&#9;&#9;script:Destroy()
&#9;&#9;break
&#9;end

&#9;--first, cast a  ray to see if we will hit anything
&#9;local ray = Ray.new(shot.Position, shot.CFrame.lookVector*(distToTravel+2))
&#9;local part, at = game.Workspace:FindPartOnRay(ray)
&#9;if part and (not part.CanCollide 
&#9;&#9;or part.Parent == creator.Character
&#9;&#9;or part.Parent.Parent == creator.Character) 
&#9;then
&#9;&#9;--&quot;tunnel&quot; through cancollide false parts
&#9;&#9;local ignore = {}
&#9;&#9;while part and (not part.CanCollide
&#9;&#9;&#9;or part.Parent == creator.Character 
&#9;&#9;&#9;or part.Parent.Parent == creator.Character)
&#9;&#9;do
&#9;&#9;&#9;ignore[#ignore+1] = part
&#9;&#9;&#9;part, at = game.Workspace:FindPartOnRayWithIgnoreList(ray, ignore)
&#9;&#9;end
&#9;end

&#9;--did we hit something?
&#9;if part then
&#9;&#9;local dir = shot.CFrame.lookVector
&#9;&#9;shot:Destroy() --no need for the shot anymore
&#9;&#9;--
&#9;&#9;local hum = (part.Parent or game):FindFirstChild(&apos;Humanoid&apos;)
&#9;&#9;if hum then
&#9;&#9;&#9;--entangle the humanoid
&#9;&#9;&#9;print(&quot;Hit, &quot;, part.Name)
&#9;&#9;&#9;SnareHumanoid(hum, dir)
&#9;&#9;&#9;script:Destroy()
&#9;&#9;&#9;break
&#9;&#9;else
&#9;&#9;&#9;--get rid of us, nothing to do
&#9;&#9;&#9;script:Destroy()
&#9;&#9;&#9;break
&#9;&#9;end
&#9;end

&#9;--move the shot ahead
&#9;local newCF = shot.CFrame*CFrame.new(0,0,-distToTravel)

&#9;--resize the shot
&#9;shot.Size = Vector3.new(1+0.5*math.sin(7*t), 1+0.5*math.cos(5*t), 4+math.cos(9*t))

&#9;--clear heatseeking if the target went away
&#9;if HeatSeekingTarget and not HeatSeekingTarget.Parent then
&#9;&#9;HeatSeekingTarget = nil
&#9;end

&#9;--only update heat seeking every 5&apos;th frame if we don&apos;t have a target, or
&#9;--every second or so if we do
&#9;if (not HeatSeekingTarget and IT%5 == 0) or IT%30 == 0 then 
&#9;&#9;local dir = newCF.lookVector
&#9;&#9;local at = newCF.p
&#9;&#9;local function DistToPath(pos)
&#9;&#9;&#9;local relPos = pos - at
&#9;&#9;&#9;local proj = dir*(dir:Dot(relPos))
&#9;&#9;&#9;return (relPos - proj).magnitude
&#9;&#9;end
&#9;&#9;local NearestTorso = nil
&#9;&#9;local Distance = math.huge
&#9;&#9;for _, p in pairs(game.Players:GetChildren()) do
&#9;&#9;&#9;if p ~= creator then
&#9;&#9;&#9;&#9;local torso = p.Character:FindFirstChild(&apos;Torso&apos;)
&#9;&#9;&#9;&#9;if torso then
&#9;&#9;&#9;&#9;&#9;local mag = (shot.Position-torso.Position).magnitude
&#9;&#9;&#9;&#9;&#9;local dist = DistToPath(torso.Position)
&#9;&#9;&#9;&#9;&#9;if dist &lt; Distance and dist &lt; HeatSeekingDistance and mag &lt; 140 then
&#9;&#9;&#9;&#9;&#9;&#9;NearestTorso = torso
&#9;&#9;&#9;&#9;&#9;&#9;Distance = dist
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
 &#9;&#9;end
&#9;&#9;--too expensive to search the workspace in a real game, just search players
&#9;&#9;--[[
&#9;&#9;for _, ob in pairs(game.Workspace:GetChildren()) do
&#9;&#9;&#9;if ob:FindFirstChild(&apos;Humanoid&apos;) and 
&#9;&#9;&#9;&#9;ob:FindFirstChild(&apos;Torso&apos;) and 
&#9;&#9;&#9;&#9;not game.Players:GetPlayerFromCharacter(ob)
&#9;&#9;&#9;then
&#9;&#9;&#9;&#9;local torso = ob.Torso
&#9;&#9;&#9;&#9;local mag = (shot.Position-torso.Position).magnitude
&#9;&#9;&#9;&#9;local dist = DistToPath(torso.Position)
&#9;&#9;&#9;&#9;if dist &lt; Distance and dist &lt; HeatSeekingDistance and mag &lt; 140 then
&#9;&#9;&#9;&#9;&#9;NearestTorso = torso
&#9;&#9;&#9;&#9;&#9;Distance = dist
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;]]
&#9;&#9;if NearestTorso then
&#9;&#9;&#9;HeatSeekingTarget = NearestTorso
&#9;&#9;end
&#9;end

&#9;--use heat-seeking
&#9;if HeatSeekingTarget then
&#9;&#9;--we need to bend towards the target at a fixed angular rate
&#9;&#9;local dir = newCF.lookVector
&#9;&#9;local dirToTarget = (HeatSeekingTarget.Position-newCF.p).unit
&#9;&#9;--get the angle between them
&#9;&#9;local theta = math.acos(dir:Dot(dirToTarget))
&#9;&#9;if theta &gt; 0.01 then
&#9;&#9;&#9;local thetaToTurn = dt*1.0
&#9;&#9;&#9;thetaToTurn = math.min(theta, thetaToTurn)
&#9;&#9;&#9;--now do a slerp
&#9;&#9;&#9;local newDir = Slerp(thetaToTurn/theta, dir, dirToTarget)
&#9;&#9;&#9;--and edit the CFrame
&#9;&#9;&#9;newCF = CFrame.new(newCF.p, newCF.p+newDir)
&#9;&#9;end
&#9;end

&#9;--and apply the new CFrame
&#9;shot.CFrame = newCF
end

script:Destroy()



</ProtectedString>
			</Properties>
			<Item class="ObjectValue" referent="RBX9">
				<Properties>
					<string name="Name">creator</string>
					<Ref name="Value">null</Ref>
				</Properties>
			</Item>
			<Item class="CFrameValue" referent="RBX10">
				<Properties>
					<string name="Name">cframe</string>
					<CoordinateFrame name="Value">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
				</Properties>
			</Item>
		</Item>
		<Item class="Script" referent="RBX11">
			<Properties>
				<bool name="Disabled">true</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">SlashScript</string>
				<ProtectedString name="Source">--failsafe
Delay(30, function() 
&#9;script:Destroy()
end)

function WaitFor(name)
&#9;while not script:FindFirstChild(name) do script.ChildAdded:wait() end
&#9;return script[name].Value
end

--get vars
local position = WaitFor(&apos;position&apos;)
local creator = WaitFor(&apos;creator&apos;)

--main effect code
function MakeSnakeBit()
&#9;local part = Instance.new(&apos;Part&apos;)
&#9;part.FormFactor = &apos;Custom&apos;
&#9;part.Size = Vector3.new(1,1,1)
&#9;--part.TopSurface = &apos;Weld&apos;
&#9;--part.BottomSurface = &apos;Weld&apos;
&#9;--part.RightSurface = &apos;Weld&apos;
&#9;--part.LeftSurface = &apos;Weld&apos;
&#9;--part.FrontSurface = &apos;Weld&apos;
&#9;--part.BackSurface = &apos;Weld&apos;
&#9;--part.Material = &apos;Wood&apos;
&#9;part.CanCollide = false
&#9;part.Anchored = true
&#9;part.BrickColor = BrickColor.new(1021) --1021=`Camo`
&#9;local mesh = Instance.new(&apos;SpecialMesh&apos;, part)
&#9;mesh.MeshType = &apos;Sphere&apos;
&#9;return part
end

--first, get the torso of the creator to use
local torso = creator.Character:FindFirstChild(&apos;Torso&apos;)
if not torso then
&#9;script:Destroy()
&#9;return
end

function RunSnake()
&#9;--
&#9;Spawn(function()
&#9;--
&#9;local startT = tick()
&#9;local LastT = startT
&#9;--
&#9;local baseR = 7+math.random()*4
&#9;local baseT = math.random()
&#9;--
&#9;local modT = LastT+baseT
&#9;--
&#9;local thetaDir = math.random(0,1)*2-1
&#9;local currentTheta = -1 - math.random()*2
&#9;local currentSnakeH = 3 + 3*math.sin(4*modT)
&#9;local currentRadius = baseR + 2.5*math.cos(5*modT)
&#9;--
&#9;local function getCurrentPoint()
&#9;&#9;return Vector3.new(math.sin(currentTheta)*currentRadius, 
&#9;&#9;                   currentSnakeH,
&#9;&#9;                   math.cos(currentTheta)*currentRadius)
&#9;end

&#9;--now, we need to `drag arroud` the player in a circle creating a
&#9;--trail, and also making the trail dissappear after a certair duration
&#9;local currentTail = {}
&#9;local bit1 = MakeSnakeBit()
&#9;bit1.Parent = game.Workspace
&#9;bit1.Anchored = false
&#9;local bit1Weld = Instance.new(&apos;Weld&apos;, newBit)
&#9;bit1Weld.Part0 = centerPart
&#9;bit1Weld.Part1 = bit1
&#9;currentTail[1] = { 
&#9;&#9;Part = bit1;
&#9;&#9;At = getCurrentPoint(); 
&#9;&#9;Timestamp = LastT;
&#9;&#9;Weld = bit1Weld;
&#9;}

&#9;--centerPart
&#9;local centerPart = Instance.new(&apos;Part&apos;, game.Workspace)
&#9;centerPart.CanCollide = false
&#9;centerPart.CFrame = CFrame.new(torso.Position)
&#9;centerPart.Size = Vector3.new(2,2,2)
&#9;centerPart.Transparency = 1
&#9;local hold = Instance.new(&apos;BodyPosition&apos;, centerPart)
&#9;hold.Name = &apos;Hold&apos;
&#9;hold.maxForce = Vector3.new(1000000,1000000,10000000)
&#9;hold.position = torso.Position
&#9;hold.P = 1000000
&#9;hold.D = 1000
&#9;game.Debris:AddItem(centerPart, 2)

&#9;--now loop
&#9;while tick()-startT &lt; 1 do
&#9;&#9;local t = tick()
&#9;&#9;local dt = t-LastT
&#9;&#9;LastT = t
&#9;&#9;local modT = LastT+baseT
&#9;&#9;--------------------------
&#9;&#9;--rotate at 6 radians per second
&#9;&#9;currentTheta = currentTheta + 7*dt*thetaDir
&#9;&#9;currentSnakeH = 3 + 3*math.sin(4*modT)
&#9;&#9;currentRadius = baseR + 2.5*math.cos(5*modT)

&#9;&#9;--update the currently expanding function
&#9;&#9;local pos = getCurrentPoint()
&#9;&#9;local lastSeg = currentTail[#currentTail]
&#9;&#9;local distFromLast = (lastSeg.At-pos).magnitude
&#9;&#9;lastSeg.Weld.Part1 = nil
&#9;&#9;lastSeg.Part.Size = Vector3.new(0.6,0.6,distFromLast)
&#9;&#9;lastSeg.Weld.Part1 = lastSeg.Part
&#9;&#9;lastSeg.Weld.C0 = CFrame.new(lastSeg.At, pos)*CFrame.new(0,0,-distFromLast/2)

&#9;&#9;--make a new seg
&#9;&#9;if distFromLast &gt; 1.5 then
&#9;&#9;&#9;local newBit = MakeSnakeBit()
&#9;&#9;&#9;newBit.Parent = game.Workspace
&#9;&#9;&#9;newBit.Size = Vector3.new(0.6,0.6,0.6)
&#9;&#9;&#9;newBit.Anchored = false
&#9;&#9;&#9;--
&#9;&#9;&#9;local newBitWeld = Instance.new(&apos;Weld&apos;, newBit)
&#9;&#9;&#9;newBitWeld.Part0 = centerPart
&#9;&#9;&#9;newBitWeld.Part1 = newBit
&#9;&#9;&#9;newBitWeld.C0 = CFrame.new(pos)
&#9;&#9;&#9;--
&#9;&#9;&#9;game.Debris:AddItem(newBit, 2)
&#9;&#9;&#9;--
&#9;&#9;&#9;currentTail[#currentTail+1] = {
&#9;&#9;&#9;&#9;Part = newBit;
&#9;&#9;&#9;&#9;At = pos;
&#9;&#9;&#9;&#9;Timestamp = LastT;
&#9;&#9;&#9;&#9;Weld = newBitWeld;
&#9;&#9;&#9;}
&#9;&#9;end

&#9;&#9;--now fade the other segments
&#9;&#9;for _, seg in pairs(currentTail) do
&#9;&#9;&#9;local segTime = math.min(1, (t-seg.Timestamp)/0.5)
&#9;&#9;&#9;seg.Part.Transparency = segTime
&#9;&#9;end

&#9;&#9;--update centerpart
&#9;&#9;centerPart.Hold.position = torso.Position

&#9;&#9;---------------------------
&#9;&#9;wait()
&#9;end
&#9;--
&#9;for _, seg in pairs(currentTail) do
&#9;&#9;seg.Part:Destroy()
&#9;end
&#9;centerPart:Destroy()
&#9;--
&#9;end)
end


--the main script. Create 3 snakes
RunSnake()
wait(0.1)
RunSnake()
wait(0.1)
RunSnake()
wait(0.1)
RunSnake()

--now damage all the people around me
for _, p in pairs(game.Players:GetChildren()) do
&#9;local torso = p.Character:FindFirstChild(&apos;Torso&apos;)
&#9;if torso and (torso.Position-position).magnitude &lt; 12 then
&#9;&#9;if p ~= creator then
&#9;&#9;&#9;local dir = (torso.Position-position).unit
&#9;&#9;------------ stolen from dagger of time to push the character
&#9;&#9;&#9;local force = Instance.new(&quot;BodyVelocity&quot;)
&#9;&#9;&#9;force.velocity = Vector3.new(0,1,0)
&#9;&#9;&#9;force.Parent = torso
&#9;&#9;&#9;torso.Velocity = dir*250
&#9;&#9;&#9;game.Debris:AddItem(force, 0.5)
&#9;&#9;------------
&#9;&#9;&#9;local hum = torso.Parent:FindFirstChild(&apos;Humanoid&apos;)
&#9;&#9;&#9;local tag = script.creator:Clone()
&#9;&#9;&#9;tag.Parent = hum
&#9;&#9;&#9;game.Debris:AddItem(tag, 2)
&#9;&#9;&#9;if hum then
&#9;&#9;&#9;&#9;hum:TakeDamage(100)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

--and kill the script
wait(2)
script:Destroy()
</ProtectedString>
			</Properties>
			<Item class="ObjectValue" referent="RBX12">
				<Properties>
					<string name="Name">creator</string>
					<Ref name="Value">null</Ref>
				</Properties>
			</Item>
			<Item class="Vector3Value" referent="RBX13">
				<Properties>
					<string name="Name">position</string>
					<Vector3 name="Value">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
				</Properties>
			</Item>
		</Item>
		<Item class="Script" referent="RBX14">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">SnakeStaffGlobal</string>
				<ProtectedString name="Source">do
&#9;function CreateSignal()
&#9;&#9;local this = {}
&#9;&#9;local mListeners = {}
&#9;&#9;local mListenerCount = 0
&#9;&#9;local mWaitProxy = nil
&#9;&#9;local mWaitReturns = nil
&#9;&#9;local mHasWaiters = false
&#9;&#9;function this:connect(func)
&#9;&#9;&#9;if self ~= this then error(&quot;connect must be called with `:`, not `.`&quot;, 2) end
&#9;&#9;&#9;if type(func) ~= &apos;function&apos; then
&#9;&#9;&#9;&#9;error(&quot;Argument #1 of connect must be a function, got a &quot;..type(func), 2)
&#9;&#9;&#9;end
&#9;&#9;&#9;mListenerCount = mListenerCount + 1
&#9;&#9;&#9;local conn = {}
&#9;&#9;&#9;function conn:disconnect()
&#9;&#9;&#9;&#9;if mListeners[conn] then
&#9;&#9;&#9;&#9;&#9;mListeners[conn] = nil
&#9;&#9;&#9;&#9;&#9;mListenerCount = mListenerCount - 1
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;mListeners[conn] = func
&#9;&#9;&#9;return conn
&#9;&#9;end
&#9;&#9;function this:disconnect()
&#9;&#9;&#9;if self ~= this then error(&quot;disconnect must be called with `:`, not `.`&quot;, 2) end
&#9;&#9;&#9;for k, v in pairs(mListeners) do
&#9;&#9;&#9;&#9;mListeners[k] = nil
&#9;&#9;&#9;end
&#9;&#9;&#9;mListenerCount = 0
&#9;&#9;end
&#9;&#9;function this:wait()
&#9;&#9;&#9;if self ~= this then error(&quot;wait must be called with `:`, not `.`&quot;, 2) end
&#9;&#9;&#9;if not mWaitProxy then
&#9;&#9;&#9;&#9;mWaitProxy = Instance.new(&apos;BoolValue&apos;)
&#9;&#9;&#9;end
&#9;&#9;&#9;mHasWaiters = true
&#9;&#9;&#9;mWaitProxy.Changed:wait()
&#9;&#9;&#9;return unpack(mWaitReturns)
&#9;&#9;end
&#9;&#9;function this:fire(...)
&#9;&#9;&#9;if self ~= this then error(&quot;fire must be called with `:`, not `.`&quot;, 2) end
&#9;&#9;&#9;local arguments;
&#9;&#9;&#9;if mListenerCount &gt; 0 or mHasWaiters then
&#9;&#9;&#9;&#9;arguments = {...}
&#9;&#9;&#9;end
&#9;&#9;&#9;if mHasWaiters then
&#9;&#9;&#9;&#9;mHasWaiters = false
&#9;&#9;&#9;&#9;mWaitReturns = arguments
&#9;&#9;&#9;&#9;mWaitProxy.Value = not mWaitProxy.Value
&#9;&#9;&#9;&#9;mWaitReturns = nil
&#9;&#9;&#9;end
&#9;&#9;&#9;if mListenerCount &gt; 0 then
&#9;&#9;&#9;&#9;for _, handlerFunc in pairs(mListeners) do
&#9;&#9;&#9;&#9;&#9;Spawn(function()
&#9;&#9;&#9;&#9;&#9;&#9;handlerFunc(unpack(arguments))
&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;function this:fireSync(...)
&#9;&#9;&#9;if self ~= this then error(&quot;fire must be called with `:`, not `.`&quot;, 2) end
&#9;&#9;&#9;local arguments;
&#9;&#9;&#9;if mListenerCount &gt; 0 or mHasWaiters then
&#9;&#9;&#9;&#9;arguments = {...}
&#9;&#9;&#9;end
&#9;&#9;&#9;if mHasWaiters then
&#9;&#9;&#9;&#9;mHasWaiters = false
&#9;&#9;&#9;&#9;mWaitReturns = arguments
&#9;&#9;&#9;&#9;mWaitProxy.Value = not mWaitProxy.Value
&#9;&#9;&#9;&#9;mWaitReturns = nil
&#9;&#9;&#9;end
&#9;&#9;&#9;if mListenerCount &gt; 0 then
&#9;&#9;&#9;&#9;for _, handlerFunc in pairs(mListeners) do
&#9;&#9;&#9;&#9;&#9;handlerFunc(unpack(arguments))
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end&#9;&#9;
&#9;&#9;end
&#9;&#9;return this
&#9;end
&#9;local function Create_PrivImpl(objectType)
&#9;&#9;if type(objectType) ~= &apos;string&apos; then
&#9;&#9;&#9;error(&quot;Argument of Create must be a string&quot;, 2)
&#9;&#9;end
&#9;&#9;return function(dat)
&#9;&#9;&#9;dat = dat or {}
&#9;&#9;&#9;local obj = Instance.new(objectType)
&#9;&#9;&#9;local ctor = nil
&#9;&#9;&#9;for k, v in pairs(dat) do
&#9;&#9;&#9;&#9;if type(k) == &apos;string&apos; then
&#9;&#9;&#9;&#9;&#9;obj[k] = v
&#9;&#9;&#9;&#9;elseif type(k) == &apos;number&apos; then
&#9;&#9;&#9;&#9;&#9;if type(v) ~= &apos;userdata&apos; then
&#9;&#9;&#9;&#9;&#9;&#9;error(&quot;Bad entry in Create body: Numeric keys must be paired with children, got a: &quot;..type(v), 2)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;v.Parent = obj
&#9;&#9;&#9;&#9;elseif type(k) == &apos;table&apos; and k.__eventname then
&#9;&#9;&#9;&#9;&#9;if type(v) ~= &apos;function&apos; then
&#9;&#9;&#9;&#9;&#9;&#9;error(&quot;Bad entry in Create body: Key `[Create.E\&apos;&quot;..k.__eventname..&quot;\&apos;]` must have a function value\
&#9;&#9;&#9;&#9;&#9;&#9;       got: &quot;..tostring(v), 2)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;obj[k.__eventname]:connect(v)
&#9;&#9;&#9;&#9;elseif k == Create then
&#9;&#9;&#9;&#9;&#9;if type(v) ~= &apos;function&apos; then
&#9;&#9;&#9;&#9;&#9;&#9;error(&quot;Bad entry in Create body: Key `[Create]` should be paired with a constructor function, \
&#9;&#9;&#9;&#9;&#9;&#9;       got: &quot;..tostring(v), 2)
&#9;&#9;&#9;&#9;&#9;elseif ctor then
&#9;&#9;&#9;&#9;&#9;&#9;error(&quot;Bad entry in Create body: Only one constructor function is allowed&quot;, 2)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;ctor = v
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;error(&quot;Bad entry (&quot;..tostring(k)..&quot; =&gt; &quot;..tostring(v)..&quot;) in Create body&quot;, 2)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;if ctor then
&#9;&#9;&#9;&#9;ctor(obj)
&#9;&#9;&#9;end
&#9;&#9;&#9;return obj
&#9;&#9;end
&#9;end
&#9;Create = setmetatable({}, {__call = function(tb, ...) return Create_PrivImpl(...) end})
&#9;Create.E = function(eventName)
&#9;&#9;return {__eventname = eventName}
&#9;end
&#9;function class(classname)
&#9;&#9;local classDef = {}
&#9;&#9;local mPublicMethods = {}
&#9;&#9;local mAllMethods = {}
&#9;&#9;local mGetters = {__ClassName = true}
&#9;&#9;local mSetters = {}
&#9;&#9;local mEvents = {}
&#9;&#9;local function fmtKey(key)
&#9;&#9;&#9;if type(key) == &apos;string&apos; then
&#9;&#9;&#9;&#9;return &apos;.&apos;..key
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;return &apos;[&apos;..tostring(key)..&apos;]&apos;
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;return function(implementer)
&#9;&#9;&#9;if type(implementer) ~= &apos;function&apos; then
&#9;&#9;&#9;&#9;error(&quot;Only functions ay be used as a class body definition, got a &quot;..type(implementer), 2)
&#9;&#9;&#9;end
&#9;&#9;&#9;local setProxy = setmetatable({}, {
&#9;&#9;&#9;&#9;__index = function(tb, key)
&#9;&#9;&#9;&#9;&#9;return setmetatable({}, {
&#9;&#9;&#9;&#9;&#9;&#9;__call = function(tb, ...)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if #{...} &gt; 0 then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;error(&apos;Passing arguments to classdef.set&apos;..fmtKey(key)..&apos;() has no meaning, \
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;       see documentation for correct usage.&apos;, 2)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if mSetters[key] then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;error(&apos;Redefinition of setter for &apos;..tostring(key), 2)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;mSetters[key] = true
&#9;&#9;&#9;&#9;&#9;&#9;end;
&#9;&#9;&#9;&#9;&#9;})
&#9;&#9;&#9;&#9;end;
&#9;&#9;&#9;&#9;__newindex = function(tb, key, val)
&#9;&#9;&#9;&#9;&#9;if type(key) == &apos;string&apos; and type(val) == &apos;function&apos; then
&#9;&#9;&#9;&#9;&#9;&#9;if mSetters[key] then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;error(&apos;Redefinition of setter for &apos;..tostring(key), 2)
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;mSetters[key] = val
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;error(&apos;Can\&apos;t set classdef.set&apos;..fmtKey(key)..&apos; = &apos;..tostring(val), 2)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end;
&#9;&#9;&#9;})
&#9;&#9;&#9;local getProxy = setmetatable({}, {
&#9;&#9;&#9;&#9;__index = function(tb, key)
&#9;&#9;&#9;&#9;&#9;return setmetatable({}, {
&#9;&#9;&#9;&#9;&#9;&#9;__call = function(tb, ...)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if #{...} &gt; 0 then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;error(&apos;Passing arguments to classdef.get&apos;..fmtKey(key)..&apos;() has no meaning, \
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;       see documentation for correct usage.&apos;, 2)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if mGetters[key] then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;error(&apos;Redefinition of getter for &apos;..tostring(key), 2)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;mGetters[key] = true
&#9;&#9;&#9;&#9;&#9;&#9;end;
&#9;&#9;&#9;&#9;&#9;})
&#9;&#9;&#9;&#9;end;
&#9;&#9;&#9;&#9;__newindex = function(tb, key, val)
&#9;&#9;&#9;&#9;&#9;if type(key) == &apos;string&apos; and type(val) == &apos;function&apos; then
&#9;&#9;&#9;&#9;&#9;&#9;if mGetters[key] then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;error(&apos;Redefinition of getter for &apos;..tostring(key), 2)
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;mGetters[key] = val
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;error(&apos;Can\&apos;t set classdef.get&apos;..fmtKey(key)..&apos; = &apos;..tostring(val), 2)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end;
&#9;&#9;&#9;})
&#9;&#9;&#9;local getsetProxy = setmetatable({}, {
&#9;&#9;&#9;&#9;__index = function(tb, key)
&#9;&#9;&#9;&#9;&#9;return setmetatable({}, {
&#9;&#9;&#9;&#9;&#9;&#9;__call = function(tb, ...)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if #{...} &gt; 0 then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;error(&apos;Passing arguments to classdef.getset&apos;..fmtKey(key)..&apos;() has no meaning, \
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;       see documentation for correct usage.&apos;, 2)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if mSetters[key] then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;error(&apos;Redefinition of setter for &apos;..tostring(key), 2)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if mGetters[key] then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;error(&apos;Redefinition of getter for &apos;..tostring(key), 2)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;mSetters[key] = true
&#9;&#9;&#9;&#9;&#9;&#9;&#9;mGetters[key] = true
&#9;&#9;&#9;&#9;&#9;&#9;end;
&#9;&#9;&#9;&#9;&#9;})
&#9;&#9;&#9;&#9;end;
&#9;&#9;&#9;&#9;__newindex = function(tb, key, val)
&#9;&#9;&#9;&#9;&#9;error(&apos;Can\&apos;t set classdef.set&apos;..fmtKey(key)..&apos; = &apos;..tostring(val), 2)
&#9;&#9;&#9;&#9;end;
&#9;&#9;&#9;})
&#9;&#9;&#9;local eventProxy = setmetatable({}, {
&#9;&#9;&#9;&#9;__index = function(tb, key)
&#9;&#9;&#9;&#9;&#9;return setmetatable({}, {
&#9;&#9;&#9;&#9;&#9;&#9;__call = function(tb, ...)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if #{...} &gt; 0 then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;error(&quot;Passing arguments to clasdef.event&quot;..fmtKey(key)..&quot;() has no meaning, \
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;       see documentation for correct usage.&quot;, 2)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if type(key) ~= &apos;string&apos; then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;error(&quot;Can&apos;t create event `&quot;..tostring(key)..&quot;` event names must be strings&quot;, 2)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if mEvents[key] then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;error(&quot;Redefinition of event `&quot;..key..&quot;`&quot;, 2)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;mEvents[key] = true
&#9;&#9;&#9;&#9;&#9;&#9;&#9;mGetters[key] = true
&#9;&#9;&#9;&#9;&#9;&#9;end;
&#9;&#9;&#9;&#9;&#9;&#9;__index = function()
&#9;&#9;&#9;&#9;&#9;&#9;&#9;error(&quot;classdef.event&quot;..fmtKey(key)..&quot; can only be called, not indexed&quot;, 2)
&#9;&#9;&#9;&#9;&#9;&#9;end;
&#9;&#9;&#9;&#9;&#9;&#9;__newindex = function()
&#9;&#9;&#9;&#9;&#9;&#9;&#9;error(&quot;classdef.event&quot;..fmtKey(key)..&quot; can only be called, not assigned to&quot;, 2)
&#9;&#9;&#9;&#9;&#9;&#9;end;
&#9;&#9;&#9;&#9;&#9;})
&#9;&#9;&#9;&#9;end;
&#9;&#9;&#9;&#9;__newindex = function(tb, key, val)
&#9;&#9;&#9;&#9;&#9;error(&quot;Can&apos;t set classdef.event&quot;..fmtKey(key)..&quot; = &quot;..tostring(val), 2)
&#9;&#9;&#9;&#9;end;
&#9;&#9;&#9;})
&#9;&#9;&#9;local staticProxy = setmetatable({}, {
&#9;&#9;&#9;&#9;__index = classDef,
&#9;&#9;&#9;&#9;__newindex = classDef,
&#9;&#9;&#9;})
&#9;&#9;&#9;local privateProxy = setmetatable({}, {
&#9;&#9;&#9;&#9;__newindex = function(tb, key, val)
&#9;&#9;&#9;&#9;&#9;if type(key) == &apos;string&apos; and type(val) == &apos;function&apos; then
&#9;&#9;&#9;&#9;&#9;&#9;mAllMethods[key] = val
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;error(&quot;Can&apos;t set classdef.private&quot;..fmtKey(key)..&quot; = &quot;..tostring(val), 2)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end;
&#9;&#9;&#9;&#9;__index = function(tb, key)
&#9;&#9;&#9;&#9;&#9;error(&quot;Can&apos;t get classdef.private&quot;..fmtKey(key), 2)
&#9;&#9;&#9;&#9;end;
&#9;&#9;&#9;})
&#9;&#9;&#9;local mainImplProxy = {}
&#9;&#9;&#9;mainImplProxy.get = getProxy
&#9;&#9;&#9;mainImplProxy.set = setProxy
&#9;&#9;&#9;mainImplProxy.getset = getsetProxy
&#9;&#9;&#9;mainImplProxy.event = eventProxy
&#9;&#9;&#9;mainImplProxy.private = privateProxy
&#9;&#9;&#9;mainImplProxy.static = staticProxy
&#9;&#9;&#9;setmetatable(mainImplProxy, {
&#9;&#9;&#9;&#9;__index = function(tb, key)
&#9;&#9;&#9;&#9;&#9;error(&apos;Can\&apos;t get classdef&apos;..fmtKey(key), 2)
&#9;&#9;&#9;&#9;end; 
&#9;&#9;&#9;&#9;__newindex = function(tb, key, val)
&#9;&#9;&#9;&#9;&#9;if type(key) == &apos;string&apos; and type(val) == &apos;function&apos; then
&#9;&#9;&#9;&#9;&#9;&#9;mPublicMethods[key] = val
&#9;&#9;&#9;&#9;&#9;&#9;mAllMethods[key] = val
&#9;&#9;&#9;&#9;&#9;&#9;mGetters[key] = true
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;error(&apos;Can\&apos;t set classdef&apos;..fmtKey(key)..&apos; = &apos;..tostring(val), 2)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end;
&#9;&#9;&#9;})
&#9;&#9;&#9;implementer(mainImplProxy)
&#9;&#9;&#9;for k, f in pairs(mAllMethods) do
&#9;&#9;&#9;&#9;if k ~= &apos;Create&apos; then
&#9;&#9;&#9;&#9;&#9;mAllMethods[k] = function(self, ...)
&#9;&#9;&#9;&#9;&#9;&#9;if type(self) ~= &apos;table&apos; or self.__ClassName ~= classname then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;error(&quot;Methods must be called with a &apos;:&apos;, not a &apos;.&apos;&quot;)
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;return f(rawget(self, &apos;__internal&apos;), ...)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;if mPublicMethods[k] then
&#9;&#9;&#9;&#9;&#9;&#9;mPublicMethods[k] = mAllMethods[k]
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;for k, f in pairs(mGetters) do
&#9;&#9;&#9;&#9;if type(f) == &apos;function&apos; then
&#9;&#9;&#9;&#9;&#9;mGetters[k] = function(self, ...)
&#9;&#9;&#9;&#9;&#9;&#9;return f(rawget(self, &apos;__internal&apos;), ...)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;for k, f in pairs(mSetters) do
&#9;&#9;&#9;&#9;if type(f) == &apos;function&apos; then
&#9;&#9;&#9;&#9;&#9;mSetters[k] = function(self, ...)
&#9;&#9;&#9;&#9;&#9;&#9;return f(rawget(self, &apos;__internal&apos;), ...)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;local internalMT = {
&#9;&#9;&#9;&#9;__index = mAllMethods;
&#9;&#9;&#9;}
&#9;&#9;&#9;local rawget = rawget 
&#9;&#9;&#9;local externalMT = {
&#9;&#9;&#9;&#9;__index = function(obj, key)
&#9;&#9;&#9;&#9;&#9;local method = mPublicMethods[key]
&#9;&#9;&#9;&#9;&#9;if method then
&#9;&#9;&#9;&#9;&#9;&#9;return method
&#9;&#9;&#9;&#9;&#9;elseif mGetters[key] == true then
&#9;&#9;&#9;&#9;&#9;&#9;return rawget(obj, &apos;__internal&apos;)[key]
&#9;&#9;&#9;&#9;&#9;elseif mGetters[key] then
&#9;&#9;&#9;&#9;&#9;&#9;return mGetters[key](obj)
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;error(&quot;Can&apos;t get &quot;..classname..&quot;::&quot;..key, 2)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end;
&#9;&#9;&#9;&#9;__newindex = function(obj, key, val)
&#9;&#9;&#9;&#9;&#9;if mSetters[key] == true then
&#9;&#9;&#9;&#9;&#9;&#9;rawget(obj, &apos;__internal&apos;)[key] = val
&#9;&#9;&#9;&#9;&#9;elseif mSetters[key] then
&#9;&#9;&#9;&#9;&#9;&#9;mSetters[key](obj, val)
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;error(&quot;Can&apos;t set &quot;..classname..&quot;::&quot;..key, 2)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end;
&#9;&#9;&#9;}
&#9;&#9;&#9;local constructor = function(...)
&#9;&#9;&#9;&#9;local internalThis = {__ClassName = classname}
&#9;&#9;&#9;&#9;internalThis.__internal = internalThis
&#9;&#9;&#9;&#9;setmetatable(internalThis, internalMT)
&#9;&#9;&#9;&#9;local externalThis = {__internal = internalThis}
&#9;&#9;&#9;&#9;setmetatable(externalThis, externalMT)
&#9;&#9;&#9;&#9;for eventName, _ in pairs(mEvents) do
&#9;&#9;&#9;&#9;&#9;internalThis[eventName] = CreateSignal()
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if mAllMethods.Create then
&#9;&#9;&#9;&#9;&#9;mAllMethods.Create(internalThis, ...)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;return externalThis
&#9;&#9;&#9;end
&#9;&#9;&#9;classDef.Create = constructor
&#9;&#9;&#9;getfenv(0)[&apos;Create&apos;..classname] = constructor
&#9;&#9;&#9;getfenv(0)[classname] = classDef
&#9;&#9;end
&#9;end


&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------

&#9;--===============================================================================
&#9;-- A tree object for quick verification of the object hierarchy that a game or
&#9;-- gear may need to be present. The tree returns a &quot;filter&quot; function which can
&#9;-- be called on an instance to flatten it into a tag map, so that in the future
&#9;-- the objects in the hierarchy can safely be accessed through the tag map
&#9;-- without need for extra checks of existance. If the hierarchy is not valid
&#9;-- then nothing is returned from the call to the filter.
&#9;--
&#9;-- Below some common examples of how to construct a tree are given, and the
&#9;-- Gearlib includes the most common examples which veryify various parts of
&#9;-- the character depending on the needs of the gear.
&#9;--
&#9;--===============================================================================
&#9;function tree(name)
&#9;&#9;if type(name) == &apos;string&apos; then
&#9;&#9;&#9;return function(dat)
&#9;&#9;&#9;&#9;return function(instance, ctx)
&#9;&#9;&#9;&#9;&#9;local child = instance:FindFirstChild(name)
&#9;&#9;&#9;&#9;&#9;if not child then return false end 
&#9;&#9;&#9;&#9;&#9;if dat.IsA and not child:IsA(dat.IsA) then return false end
&#9;&#9;&#9;&#9;&#9;if dat.Tag then
&#9;&#9;&#9;&#9;&#9;&#9;ctx[dat.Tag] = child
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;for i = 1, #dat do
&#9;&#9;&#9;&#9;&#9;&#9;if not dat[i](child, ctx) then return false end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;return true
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;return function(dat)
&#9;&#9;&#9;&#9;return function(instance)
&#9;&#9;&#9;&#9;&#9;local ctx = {}
&#9;&#9;&#9;&#9;&#9;if dat.IsA and not instance:IsA(dat.IsA) then return nil end
&#9;&#9;&#9;&#9;&#9;if dat.Tag then ctx[dat.Tag] = instance end
&#9;&#9;&#9;&#9;&#9;for i = 1, #dat do
&#9;&#9;&#9;&#9;&#9;&#9;if not dat[i](instance, ctx) then return nil end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;return ctx
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;--===============================================================================
&#9;-- A tree which verifys all parts of a character including legs.
&#9;-- Tags Declared:
&#9;--  Character: the root character model
&#9;--  LeftArm, RightArm, LeftLeg, RightLeg, Head: The appendages
&#9;--  Humanoid: The humanoid
&#9;--  
&#9;local CharacterFullTree = tree{
&#9;&#9;IsA = &apos;Model&apos;;
&#9;&#9;Tag = &apos;Character&apos;;
&#9;&#9;--
&#9;&#9;tree&apos;Left Arm&apos;{
&#9;&#9;&#9;IsA = &apos;BasePart&apos;;
&#9;&#9;&#9;Tag = &apos;LeftArm&apos;;
&#9;&#9;};
&#9;&#9;tree&apos;Right Arm&apos;{
&#9;&#9;&#9;IsA = &apos;BasePart&apos;;
&#9;&#9;&#9;Tag = &apos;RightArm&apos;;
&#9;&#9;};
&#9;&#9;tree&apos;Left Arm&apos;{
&#9;&#9;&#9;IsA = &apos;BasePart&apos;;
&#9;&#9;&#9;Tag = &apos;LeftArm&apos;;
&#9;&#9;};
&#9;&#9;tree&apos;Right Arm&apos;{
&#9;&#9;&#9;IsA = &apos;BasePart&apos;;
&#9;&#9;&#9;Tag = &apos;RightArm&apos;;
&#9;&#9;};
&#9;&#9;tree&apos;Head&apos;{
&#9;&#9;&#9;IsA = &apos;BasePart&apos;;
&#9;&#9;&#9;Tag = &apos;Head&apos;;
&#9;&#9;};
&#9;&#9;tree&apos;Humanoid&apos;{
&#9;&#9;&#9;IsA = &apos;Humanoid&apos;;
&#9;&#9;&#9;Tag = &apos;Humanoid&apos;;
&#9;&#9;};
&#9;}

&#9;--===============================================================================
&#9;-- A tree with just the parts for a basic gear.
&#9;-- Tags Declared:
&#9;--  Character: The root character object
&#9;--  RightArm
&#9;--  Torso
&#9;--  Humanoid
&#9;local CharacterRightArmTree = tree{
&#9;&#9;IsA = &apos;Model&apos;;
&#9;&#9;Tag = &apos;Character&apos;;
&#9;&#9;--
&#9;&#9;tree&apos;Right Arm&apos;{
&#9;&#9;&#9;IsA = &apos;BasePart&apos;;
&#9;&#9;&#9;Tag = &apos;RightArm&apos;;
&#9;&#9;};
&#9;&#9;tree&apos;Torso&apos;{
&#9;&#9;&#9;IsA = &apos;BasePart&apos;;
&#9;&#9;&#9;Tag = &apos;Torso&apos;;
&#9;&#9;};
&#9;&#9;tree&apos;Humanoid&apos;{
&#9;&#9;&#9;IsA = &apos;BasePart&apos;;
&#9;&#9;&#9;Tag = &apos;Humanoid&apos;;
&#9;&#9;};
&#9;}


&#9;--===============================================================================
&#9;-- A class for maintaining a list of assets that the gear uses. The assets can
&#9;-- be added as a list or one by one, and then requested as for various purposes,
&#9;-- such as as individual sounds or meshes, or more specifically such as for a set
&#9;-- of animations on a given humanoid.
&#9;class&apos;AssetProvider&apos;(function(def)
&#9;&#9;function def:Create()
&#9;&#9;&#9;self.Model = script.Parent:FindFirstChild(&apos;assets&apos;)
&#9;&#9;&#9;if not self.Model then
&#9;&#9;&#9;&#9;self.Model = Create&apos;Model&apos;{
&#9;&#9;&#9;&#9;&#9;Name = &quot;assets&quot;;
&#9;&#9;&#9;&#9;&#9;Parent = script.Parent;
&#9;&#9;&#9;&#9;}
&#9;&#9;&#9;end
&#9;&#9;end



&#9;&#9;--functionality to register various types of asset
&#9;&#9;function def:RegisterMesh(tag, id, scale)
&#9;&#9;&#9;if not self.Model:FindFirstChild(tag) then
&#9;&#9;&#9;&#9;local mesh = Create&apos;SpecialMesh&apos;{
&#9;&#9;&#9;&#9;&#9;Name = tag;
&#9;&#9;&#9;&#9;&#9;MeshId = self:ToAssetId(id);
&#9;&#9;&#9;&#9;&#9;Parent = self.Model;
&#9;&#9;&#9;&#9;}
&#9;&#9;&#9;&#9;if scale then
&#9;&#9;&#9;&#9;&#9;mesh.Scale = scale
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;function def:RegisterAnim(tag, id, speed, fadeTime)
&#9;&#9;&#9;if not self.Model:FindFirstChild(tag) then
&#9;&#9;&#9;&#9;local obj = Create&apos;Animation&apos;{
&#9;&#9;&#9;&#9;&#9;Name = tag;
&#9;&#9;&#9;&#9;&#9;AnimationId = self:ToAssetId(id);
&#9;&#9;&#9;&#9;&#9;Parent = self.Model;
&#9;&#9;&#9;&#9;}
&#9;&#9;&#9;&#9;if speed then
&#9;&#9;&#9;&#9;&#9;Create&apos;NumberValue&apos;{
&#9;&#9;&#9;&#9;&#9;&#9;Name = &apos;speed&apos;;
&#9;&#9;&#9;&#9;&#9;&#9;Value = speed;
&#9;&#9;&#9;&#9;&#9;&#9;Parent = obj;
&#9;&#9;&#9;&#9;&#9;}
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if fadeTime then
&#9;&#9;&#9;&#9;&#9;Create&apos;NumberValue&apos;{
&#9;&#9;&#9;&#9;&#9;&#9;Name = &apos;fadeTime&apos;;
&#9;&#9;&#9;&#9;&#9;&#9;Value = fadeTime;
&#9;&#9;&#9;&#9;&#9;&#9;Parent = obj;
&#9;&#9;&#9;&#9;&#9;}
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;function def:RegisterSound(tag, id, volume, pitch)
&#9;&#9;&#9;if not self.Model:FindFirstChild(tag) then
&#9;&#9;&#9;&#9;local sound = Create&apos;Sound&apos;{
&#9;&#9;&#9;&#9;&#9;Name = tag;
&#9;&#9;&#9;&#9;&#9;SoundId = self:ToAssetId(id);
&#9;&#9;&#9;&#9;&#9;Parent = self.Model;
&#9;&#9;&#9;&#9;}
&#9;&#9;&#9;&#9;if volume then
&#9;&#9;&#9;&#9;&#9;sound.Volume = volume
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if pitch then
&#9;&#9;&#9;&#9;&#9;sound.Pitch = pitch
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end



&#9;&#9;--functionality to create instances of various asset types
&#9;&#9;function def:CreateSound(tag, volume, pitch)
&#9;&#9;&#9;if self.Model:FindFirstChild(tag) then
&#9;&#9;&#9;&#9;local obj = self.Model:FindFirstChild(tag):Clone()
&#9;&#9;&#9;&#9;if volume then
&#9;&#9;&#9;&#9;&#9;obj.Volume = volume
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if pitch then
&#9;&#9;&#9;&#9;&#9;obj.Pitch = pitch
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;return obj
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;function def:CreateMesh(tag, scale)
&#9;&#9;&#9;if self.Model:FindFirstChild(tag) then
&#9;&#9;&#9;&#9;local obj = self.Model:FindFirstChild(tag):Clone()
&#9;&#9;&#9;&#9;if scale then
&#9;&#9;&#9;&#9;&#9;obj.Scale = scale
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;return obj
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;function def:CreateAnimator(humanoid)
&#9;&#9;&#9;local anims = {}
&#9;&#9;&#9;for _, anim in pairs(self.Model:GetChildren()) do
&#9;&#9;&#9;&#9;if anim:IsA(&apos;Animation&apos;) then
&#9;&#9;&#9;&#9;&#9;local track = humanoid:LoadAnimation(anim)
&#9;&#9;&#9;&#9;&#9;--
&#9;&#9;&#9;&#9;&#9;local proxy = {}
&#9;&#9;&#9;&#9;&#9;local defaultSpeed, defaultFade;
&#9;&#9;&#9;&#9;&#9;if anim:FindFirstChild(&apos;speed&apos;) then
&#9;&#9;&#9;&#9;&#9;&#9;defaultSpeed = anim:FindFirstChild(&apos;speed&apos;).Value
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;if anim:FindFirstChild(&apos;fadeTime&apos;) then
&#9;&#9;&#9;&#9;&#9;&#9;defaultFade = anim:FindFirstChild(&apos;fadeTime&apos;).Value
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;function proxy:Play(speed, fadeTime)
&#9;&#9;&#9;&#9;&#9;&#9;track:Play(fadeTime or defaultFade or 0.1, 1, speed or defaultSpeed or 1)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;function proxy:Stop(fadeTime)
&#9;&#9;&#9;&#9;&#9;&#9;track:Stop(fadeTime or defaultFade or 0.1)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;proxy.KeyframeReached = track.KeyframeReached
&#9;&#9;&#9;&#9;&#9;--
&#9;&#9;&#9;&#9;&#9;anims[anim.Name] = proxy
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;--
&#9;&#9;&#9;local animator = setmetatable({}, {__index=anims})
&#9;&#9;&#9;function animator:StopAll(fadeTime)
&#9;&#9;&#9;&#9;for _, anim in pairs(anims) do
&#9;&#9;&#9;&#9;&#9;anim:Stop(fadeTime)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;return animator
&#9;&#9;end

&#9;&#9;function def.private:ToAssetId(id)
&#9;&#9;&#9;if type(id) == &apos;string&apos; then
&#9;&#9;&#9;&#9;return id
&#9;&#9;&#9;elseif type(id) == &apos;number&apos; then
&#9;&#9;&#9;&#9;return &apos;http://www.roblox.com/asset/?id=&apos;..id
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end)


&#9;function CreateMutexFunction(task)
&#9;&#9;local running = false
&#9;&#9;return function(...)
&#9;&#9;&#9;if not running then
&#9;&#9;&#9;&#9;return task(...)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end


&#9;function CreateGlobalVarList()
&#9;&#9;local this = {}
&#9;&#9;local waitingOn = {}
&#9;&#9;--
&#9;&#9;local data = script.Parent:FindFirstChild(&apos;data&apos;)
&#9;&#9;if not data then
&#9;&#9;&#9;if script:IsA(&apos;LocalScript&apos;) then
&#9;&#9;&#9;&#9;data = Create&apos;Model&apos;{
&#9;&#9;&#9;&#9;&#9;Name = &apos;data&apos;;
&#9;&#9;&#9;&#9;&#9;Parent = script.Parent;
&#9;&#9;&#9;&#9;}&#9;
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;repeat wait() until script.Parent:FindFirstChild(&apos;data&apos;)
&#9;&#9;&#9;&#9;data = script.Parent:FindFirstChild(&apos;data&apos;)&#9;&#9;&#9;
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;--
&#9;&#9;function this:Create(tag, type, default)
&#9;&#9;&#9;if not data:FindFirstChild(tag) then
&#9;&#9;&#9;&#9;if script:IsA(&apos;LocalScript&apos;) then
&#9;&#9;&#9;&#9;&#9;Create(type..&apos;Value&apos;){
&#9;&#9;&#9;&#9;&#9;&#9;Name = tag;
&#9;&#9;&#9;&#9;&#9;&#9;Parent = data;
&#9;&#9;&#9;&#9;&#9;&#9;Value = default;
&#9;&#9;&#9;&#9;&#9;}
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;waitingOn[tag] = true
&#9;&#9;&#9;&#9;&#9;repeat wait() until data:FindFirstChild(tag)
&#9;&#9;&#9;&#9;&#9;waitingOn[tag] = nil
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;--
&#9;&#9;setmetatable(this, {
&#9;&#9;&#9;__index = function(tb, inx)
&#9;&#9;&#9;&#9;if inx == &apos;Create&apos; then
&#9;&#9;&#9;&#9;&#9;return this.Create
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;local val = data:FindFirstChild(inx)
&#9;&#9;&#9;&#9;&#9;if val then
&#9;&#9;&#9;&#9;&#9;&#9;return val.Value
&#9;&#9;&#9;&#9;&#9;elseif waitingOn[inx] then
&#9;&#9;&#9;&#9;&#9;&#9;repeat wait() until not waitingOn[inx]
&#9;&#9;&#9;&#9;&#9;&#9;return data[inx].Value
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;error(&apos;Can\&apos;t set global `&apos;..inx..&apos;`, does not exist.&apos;)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end;
&#9;&#9;&#9;__newindex = function(tb, inx, val)
&#9;&#9;&#9;&#9;local obj = data:FindFirstChild(inx)
&#9;&#9;&#9;&#9;if obj then
&#9;&#9;&#9;&#9;&#9;obj.Value = val
&#9;&#9;&#9;&#9;elseif waitingOn[inx] then
&#9;&#9;&#9;&#9;&#9;repeat wait() until not waitingOn[inx]
&#9;&#9;&#9;&#9;&#9;data:FindFirstChild(inx).Value = val
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;error(&apos;Can\&apos;t get global `&apos;..inx..&apos;`, does not exist.&apos;)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end;
&#9;&#9;})
&#9;&#9;return this
&#9;end


&#9;class&apos;Tool&apos;(function(def)
&#9;&#9;function def:Create()
&#9;&#9;&#9;self.Tool = script.Parent
&#9;&#9;&#9;local tool = script.Parent
&#9;&#9;&#9;self.Handle = tool:FindFirstChild(&apos;Handle&apos;)
&#9;&#9;&#9;if not self.Handle then
&#9;&#9;&#9;&#9;if script:IsA(&apos;LocalScript&apos;) then
&#9;&#9;&#9;&#9;&#9;repeat wait() until tool:FindFirstChild(&apos;Handle&apos;)
&#9;&#9;&#9;&#9;&#9;self.Handle = tool.Handle
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;error(&quot;Tool has no `Handle`, did you forget to add one?&quot;)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end

&#9;&#9;&#9;--see which side we&apos;re on, localscript or normal script:
&#9;&#9;&#9;local IsLocal = script:IsA(&apos;LocalScript&apos;)

&#9;&#9;&#9;--set up the damage bin in the tool, so that damage can be inflicted
&#9;&#9;&#9;--from a localscript. The global script side has to create a &quot;damagebin&quot;
&#9;&#9;&#9;--in the tool, and the local side of the tool then puts notifications
&#9;&#9;&#9;--into that madel.
&#9;&#9;&#9;if IsLocal then
&#9;&#9;&#9;&#9;Spawn(function()
&#9;&#9;&#9;&#9;&#9;while not tool:FindFirstChild(&apos;damagebin&apos;) do
&#9;&#9;&#9;&#9;&#9;&#9;tool.ChildAdded:wait()
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;self.DamageBin = tool:FindFirstChild(&apos;damagebin&apos;)
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;self.DamageBin = tool:FindFirstChild(&apos;damagebin&apos;)
&#9;&#9;&#9;&#9;if not self.DamageBin then
&#9;&#9;&#9;&#9;&#9;self.DamageBin = Create&apos;Model&apos;{
&#9;&#9;&#9;&#9;&#9;&#9;Name = &apos;damagebin&apos;;
&#9;&#9;&#9;&#9;&#9;&#9;Parent = tool;
&#9;&#9;&#9;&#9;&#9;}
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;--and listen on the damage bin
&#9;&#9;&#9;&#9;self.DamageBin.ChildAdded:connect(function(ch)
&#9;&#9;&#9;&#9;&#9;local dmg = tonumber(ch.Name)
&#9;&#9;&#9;&#9;&#9;--tag the humanoid
&#9;&#9;&#9;&#9;&#9;local creator = Create&apos;ObjectValue&apos;{
&#9;&#9;&#9;&#9;&#9;&#9;Name = &apos;creator&apos;;
&#9;&#9;&#9;&#9;&#9;&#9;Value = self.Player;
&#9;&#9;&#9;&#9;&#9;&#9;Parent = ch.Value;
&#9;&#9;&#9;&#9;&#9;}
&#9;&#9;&#9;&#9;&#9;wait()
&#9;&#9;&#9;&#9;&#9;ch.Value:TakeDamage(dmg)
&#9;&#9;&#9;&#9;&#9;game.Debris:AddItem(ch, 2)
&#9;&#9;&#9;&#9;&#9;game.Debris:AddItem(creator, 2)
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;end

&#9;&#9;&#9;--create the asset manager
&#9;&#9;&#9;self.Asset = CreateAssetProvider()

&#9;&#9;&#9;--create the global var list
&#9;&#9;&#9;self.Var = CreateGlobalVarList()

&#9;&#9;&#9;--
&#9;&#9;&#9;tool.Equipped:connect(function(mouse)
&#9;&#9;&#9;&#9;--main properties set on selection
&#9;&#9;&#9;&#9;self.Mouse = mouse
&#9;&#9;&#9;&#9;self.MouseDown = false
&#9;&#9;&#9;&#9;self.Selected = true
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;--set up convinience properties
&#9;&#9;&#9;&#9;self.Character = tool.Parent
&#9;&#9;&#9;&#9;self.Player = game.Players:GetPlayerFromCharacter(self.Character)
&#9;&#9;&#9;&#9;self.Head = self.Character:FindFirstChild(&apos;Head&apos;)
&#9;&#9;&#9;&#9;self.Torso = self.Character:FindFirstChild(&apos;Torso&apos;)
&#9;&#9;&#9;&#9;self.Humanoid = self.Character:FindFirstChild(&apos;Humanoid&apos;)
&#9;&#9;&#9;&#9;self.LeftLeg = self.Character:FindFirstChild(&apos;Left Leg&apos;)
&#9;&#9;&#9;&#9;self.RightLeg = self.Character:FindFirstChild(&apos;Right Leg&apos;)
&#9;&#9;&#9;&#9;self.LeftArm = self.Character:FindFirstChild(&apos;Left Arm&apos;)
&#9;&#9;&#9;&#9;self.RightArm = self.Character:FindFirstChild(&apos;Right Arm&apos;)

&#9;&#9;&#9;&#9;--create main the animator for this instance. It won&apos;t be usefull from the
&#9;&#9;&#9;&#9;--global side right now, but it may be in the future, and it is an abstraction
&#9;&#9;&#9;&#9;--so it is possible to make it work even from the global side.
&#9;&#9;&#9;&#9;self.Animator = self.Asset:CreateAnimator(self.Humanoid)
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;--if local, set up the mouse events
&#9;&#9;&#9;&#9;if IsLocal then
&#9;&#9;&#9;&#9;&#9;mouse.Button1Down:connect(function()
&#9;&#9;&#9;&#9;&#9;&#9;self.MouseDown = true
&#9;&#9;&#9;&#9;&#9;&#9;self.Button1Down:fire()
&#9;&#9;&#9;&#9;&#9;end)&#9;
&#9;&#9;&#9;&#9;&#9;mouse.Button1Up:connect(function()
&#9;&#9;&#9;&#9;&#9;&#9;self.MouseDown = false
&#9;&#9;&#9;&#9;&#9;&#9;self.Button1Up:fire()
&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;&#9;&#9;mouse.KeyDown:connect(function(key)
&#9;&#9;&#9;&#9;&#9;&#9;self.KeyDown:fire(key)
&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;&#9;&#9;mouse.KeyUp:connect(function(key)
&#9;&#9;&#9;&#9;&#9;&#9;self.KeyUp:fire(key)
&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;--finally, pass off to the user
&#9;&#9;&#9;&#9;Spawn(function()
&#9;&#9;&#9;&#9;&#9;self.Equipped:fire()
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;end)
&#9;&#9;&#9;tool.Unequipped:connect(function()
&#9;&#9;&#9;&#9;-- FIRST give the tool a chance to do stuff with these properties
&#9;&#9;&#9;&#9;-- before we kill them. That is, the unequipped event fires before
&#9;&#9;&#9;&#9;-- the thing is really unequipped.
&#9;&#9;&#9;&#9;self.Unequipped:fireSync()

&#9;&#9;&#9;&#9;--unset convinience properties
&#9;&#9;&#9;&#9;self.Selected = false
&#9;&#9;&#9;&#9;self.MouseDown = false
&#9;&#9;&#9;&#9;self.Mouse = nil
&#9;&#9;&#9;&#9;self.Character = nil
&#9;&#9;&#9;&#9;--
&#9;&#9;&#9;&#9;self.Head = nil
&#9;&#9;&#9;&#9;self.Torso = nil
&#9;&#9;&#9;&#9;self.Humanoid = nil
&#9;&#9;&#9;&#9;self.LeftArm = nil
&#9;&#9;&#9;&#9;self.RightArm = nil
&#9;&#9;&#9;&#9;self.LeftLeg = nil
&#9;&#9;&#9;&#9;self.RightLeg = nil
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;--kill the old animator. We may be able to reuse it some of the time
&#9;&#9;&#9;&#9;--but the most common use cases are ones where it&apos;s not possible to save, so
&#9;&#9;&#9;&#9;--it&apos;s not worth the extra code comlexity to figure out when we can save it.
&#9;&#9;&#9;&#9;self.Animator = nil
&#9;&#9;&#9;end)
&#9;&#9;end

&#9;&#9;function def:DamageHumanoid(humanoid, damage)
&#9;&#9;&#9;if self.DamageBin then
&#9;&#9;&#9;&#9;(Create&apos;ObjectValue&apos;{
&#9;&#9;&#9;&#9;&#9;Name = tostring(damage);
&#9;&#9;&#9;&#9;&#9;Value = humanoid;
&#9;&#9;&#9;&#9;}).Parent = self.DamageBin
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;Spawn(function()
&#9;&#9;&#9;&#9;&#9;repeat wait() until self.DamageBin
&#9;&#9;&#9;&#9;&#9;Create&apos;ObjectValue&apos;{
&#9;&#9;&#9;&#9;&#9;&#9;Name = tostring(damage);
&#9;&#9;&#9;&#9;&#9;&#9;Value = humanoid;
&#9;&#9;&#9;&#9;&#9;}.Parent = self.DamageBin
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;--============================
&#9;&#9;def.get.Tool()
&#9;&#9;def.get.Player()
&#9;&#9;def.get.Mouse()
&#9;&#9;def.get.MouseDown()
&#9;&#9;def.get.Selected()
&#9;&#9;function def.get:MouseTarget()
&#9;&#9;&#9;if self.Mouse then
&#9;&#9;&#9;&#9;return self.Mouse.Target
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;function def.get:MouseHit()
&#9;&#9;&#9;if self.Mouse then
&#9;&#9;&#9;&#9;return self.Mouse.Hit
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;function def.get:MouseIcon()
&#9;&#9;&#9;if self.Mouse then
&#9;&#9;&#9;&#9;return self.Mouse.Icon
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;function def.set:MouseIcon(icon)
&#9;&#9;&#9;if not self.Mouse then
&#9;&#9;&#9;&#9;error(&quot;Error, Can&apos;t set MouseIcon from a global script!&quot;)
&#9;&#9;&#9;end
&#9;&#9;&#9;self.Mouse.Icon = icon
&#9;&#9;end
&#9;&#9;--
&#9;&#9;def.get.Character()
&#9;&#9;def.get.Humanoid()
&#9;&#9;def.get.LeftArm()
&#9;&#9;def.get.RightArm()
&#9;&#9;def.get.LeftLeg()
&#9;&#9;def.get.RightLeg()
&#9;&#9;def.get.Head()
&#9;&#9;def.get.Torso()
&#9;&#9;def.get.Handle()
&#9;&#9;--
&#9;&#9;def.get.Asset()
&#9;&#9;def.get.Animator()
&#9;&#9;def.get.Var()

&#9;&#9;--=============================
&#9;&#9;def.event.Equipped()
&#9;&#9;def.event.Unequipped()
&#9;&#9;--
&#9;&#9;def.event.Button1Down()
&#9;&#9;def.event.Button1Up()
&#9;&#9;def.event.KeyDown()
&#9;&#9;def.event.KeyUp()
&#9;end)

&#9;local Tool = CreateTool()

&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
&#9;-----------------------------------------------------------------------
end
</ProtectedString>
			</Properties>
		</Item>
		<Item class="Camera" referent="RBX15">
			<Properties>
				<Ref name="CameraSubject">null</Ref>
				<token name="CameraType">0</token>
				<CoordinateFrame name="CoordinateFrame">
					<X>0.675471067</X>
					<Y>3.14007473</Y>
					<Z>5.0048461</Z>
					<R00>0.999902606</R00>
					<R01>-0.000876689563</R01>
					<R02>0.0139346113</R02>
					<R10>-0</R10>
					<R11>0.998026788</R11>
					<R12>0.0627903789</R12>
					<R20>-0.0139621636</R20>
					<R21>-0.062784262</R21>
					<R22>0.997929454</R22>
				</CoordinateFrame>
				<float name="FieldOfView">70</float>
				<CoordinateFrame name="Focus">
					<X>0.600000381</X>
					<Y>2.79999828</Y>
					<Z>-0.399999619</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<string name="Name">ThumbnailCamera</string>
			</Properties>
		</Item>
	</Item>
</roblox>