<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Tool" referent="RBX0">
		<Properties>
			<bool name="Enabled">true</bool>
			<CoordinateFrame name="Grip">
				<X>0</X>
				<Y>0</Y>
				<Z>0</Z>
				<R00>1</R00>
				<R01>0</R01>
				<R02>-0</R02>
				<R10>0</R10>
				<R11>0</R11>
				<R12>-1</R12>
				<R20>0</R20>
				<R21>1</R21>
				<R22>-0</R22>
			</CoordinateFrame>
			<string name="Name">Gamaboi</string>
			<Content name="TextureId"><url>http://www.roblox.com/asset/?id=66342939 </url></Content>
		</Properties>
		<Item class="Part" referent="RBX1">
			<Properties>
				<bool name="Anchored">false</bool>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">4</token>
				<token name="BottomSurfaceInput">0</token>
				<int name="BrickColor">194</int>
				<CoordinateFrame name="CFrame">
					<X>-0.980000019</X>
					<Y>14.7099953</Y>
					<Z>0.410000026</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<float name="Elasticity">0.5</float>
				<float name="Friction">0.300000012</float>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">false</bool>
				<token name="Material">256</token>
				<string name="Name">Handle</string>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">3</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<token name="formFactorRaw">3</token>
				<token name="shape">1</token>
				<Vector3 name="size">
					<X>0.920001268</X>
					<Y>0.220000371</Y>
					<Z>1.17999959</Z>
				</Vector3>
			</Properties>
			<Item class="SpecialMesh" referent="RBX2">
				<Properties>
					<token name="LODX">2</token>
					<token name="LODY">2</token>
					<Content name="MeshId"><url>http://www.roblox.com/asset/?id=66342195 </url></Content>
					<token name="MeshType">5</token>
					<string name="Name">Mesh</string>
					<Vector3 name="Offset">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<Vector3 name="Scale">
						<X>1</X>
						<Y>1</Y>
						<Z>1</Z>
					</Vector3>
					<Content name="TextureId"><url>http://www.roblox.com/asset/?id=66342225 </url></Content>
					<Vector3 name="VertexColor">
						<X>1</X>
						<Y>1</Y>
						<Z>1</Z>
					</Vector3>
				</Properties>
			</Item>
			<Item class="Sound" referent="RBX3">
				<Properties>
					<bool name="Looped">false</bool>
					<string name="Name">ProjectileSound</string>
					<float name="Pitch">1</float>
					<bool name="PlayOnRemove">false</bool>
					<Content name="SoundId"><url>http://www.roblox.com/asset?id=58479648</url></Content>
					<float name="Volume">0.400000006</float>
				</Properties>
			</Item>
			<Item class="Sound" referent="RBX4">
				<Properties>
					<bool name="Looped">false</bool>
					<string name="Name">BossSound</string>
					<float name="Pitch">1</float>
					<bool name="PlayOnRemove">false</bool>
					<Content name="SoundId"><url>http://www.roblox.com/asset?id=58479849</url></Content>
					<float name="Volume">0.75</float>
				</Properties>
			</Item>
			<Item class="Sound" referent="RBX5">
				<Properties>
					<bool name="Looped">false</bool>
					<string name="Name">ScreamSound</string>
					<float name="Pitch">1</float>
					<bool name="PlayOnRemove">false</bool>
					<Content name="SoundId"><url>http://www.roblox.com/asset?id=58520081 </url></Content>
					<float name="Volume">0.200000003</float>
				</Properties>
			</Item>
			<Item class="Sound" referent="RBX6">
				<Properties>
					<bool name="Looped">true</bool>
					<string name="Name">GameSound</string>
					<float name="Pitch">1</float>
					<bool name="PlayOnRemove">false</bool>
					<Content name="SoundId"><url>http://www.roblox.com/asset?id=58479849</url></Content>
					<float name="Volume">0.300000012</float>
				</Properties>
			</Item>
		</Item>
		<Item class="LocalScript" referent="RBX7">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Game Script</string>
				<ProtectedString name="Source">-- Game BG size is 800x600 

-- With 45 small blocks, only getting about 8 FPS, not good -- need to spatial partition the physics objects

-- Version 0.11 -- Elastic bodies

-- Version 0.2 -- making collision boxes to 100% 

-- Version 0.21 -- decoupled the character movement from the physics

-- Version 0.3 -- Quad Tree based physics 

-- Version 0.4 -- decoupled/removed the Quad Tree physics as the game requires less moving bodies, and less bugs 

-- Version 0.41 -- Added functional sprites for characters in the game, need to make this a generic class 

-- Version 0.45 -- Re-coupled the character movement to the physics and added health bar

-- Version 0.5 -- Now the world scrolls! 

-- Version 0.55 -- Added projectiles as separate things from the physics system, this isn&apos;t ideal. Need to couple it with the physics system and use a touch event 

-- Version 0.60 -- Added the clone boss to the game, and fixed lots of little bugs 

-- Version 0.70 -- Initiating the Water and Desert Levels 

-- Version 0.80 -- Medusa boss fight!

-- Version 0.90 -- Melee Enemies and 2 level scrolling 

-- Version 1.0 --  Sun boss fight and bug fixes


local Tool = script.Parent
local RPG = Tool.Handle

local vCharacter
local myTorso
local myHumanoid

Tool.Enabled = true

--- PRELOAD ASSETS OYUS -- 

Game:GetService(&quot;ContentProvider&quot;):Preload(&quot;http://www.roblox.com/asset/?id=65908682&quot;) -- Grass Mountains
Game:GetService(&quot;ContentProvider&quot;):Preload(&quot;http://www.roblox.com/asset/?id=65915569&quot;) -- Main Character
Game:GetService(&quot;ContentProvider&quot;):Preload(&quot;http://www.roblox.com/asset/?id=65909301&quot;) -- Grass Sky Image
Game:GetService(&quot;ContentProvider&quot;):Preload(&quot;http://www.roblox.com/asset/?id=65911902&quot;) -- Grass Level Ground
Game:GetService(&quot;ContentProvider&quot;):Preload(&quot;http://www.roblox.com/asset/?id=59460030&quot;) -- Block
Game:GetService(&quot;ContentProvider&quot;):Preload(&quot;http://www.roblox.com/asset/?id=59620891&quot;) -- Block
Game:GetService(&quot;ContentProvider&quot;):Preload(&quot;http://www.roblox.com/asset/?id=59620923&quot;) -- Block
Game:GetService(&quot;ContentProvider&quot;):Preload(&quot;http://www.roblox.com/asset/?id=59620949&quot;) -- Block
Game:GetService(&quot;ContentProvider&quot;):Preload(&quot;http://www.roblox.com/asset/?id=61243294&quot;) -- Circle
Game:GetService(&quot;ContentProvider&quot;):Preload(&quot;http://www.roblox.com/asset/?id=65910153&quot;) -- Sun

Game:GetService(&quot;ContentProvider&quot;):Preload(&quot;http://www.roblox.com/asset/?id=66188209&quot;) -- Melee Bot 
Game:GetService(&quot;ContentProvider&quot;):Preload(&quot;http://www.roblox.com/asset/?id=66188274&quot;) -- Melee Bot swing

Game:GetService(&quot;ContentProvider&quot;):Preload(&quot;http://www.roblox.com/asset/?id=66189603&quot;) -- Ranged enemy
Game:GetService(&quot;ContentProvider&quot;):Preload(&quot;http://www.roblox.com/asset/?id=66189620&quot;) -- Float
Game:GetService(&quot;ContentProvider&quot;):Preload(&quot;http://www.roblox.com/asset/?id=66189699&quot;) -- Projectile
Game:GetService(&quot;ContentProvider&quot;):Preload(&quot;http://www.roblox.com/asset/?id=66189656&quot;) -- Enemy Hand 

-- Water Level 
Game:GetService(&quot;ContentProvider&quot;):Preload(&quot;http://www.roblox.com/asset/?id=66225675&quot;) -- Water Sun
Game:GetService(&quot;ContentProvider&quot;):Preload(&quot;http://www.roblox.com/asset/?id=66225731&quot;) -- Water level Sky 
Game:GetService(&quot;ContentProvider&quot;):Preload(&quot;http://www.roblox.com/asset/?id=66225756&quot;) -- Water level Rocks Close
Game:GetService(&quot;ContentProvider&quot;):Preload(&quot;http://www.roblox.com/asset/?id=66225894&quot;) -- Water level Rocks Mid
Game:GetService(&quot;ContentProvider&quot;):Preload(&quot;http://www.roblox.com/asset/?id=66225914&quot;) -- Water level Rocks far
Game:GetService(&quot;ContentProvider&quot;):Preload(&quot;http://www.roblox.com/asset/?id=66225949&quot;) -- Water level Plants 
Game:GetService(&quot;ContentProvider&quot;):Preload(&quot;http://www.roblox.com/asset/?id=66225966&quot;) 
Game:GetService(&quot;ContentProvider&quot;):Preload(&quot;http://www.roblox.com/asset/?id=66225981&quot;) 
Game:GetService(&quot;ContentProvider&quot;):Preload(&quot;http://www.roblox.com/asset/?id=66225995&quot;) 

-- Sand Level 
Game:GetService(&quot;ContentProvider&quot;):Preload(&quot;http://www.roblox.com/asset/?id=66356580&quot;) -- Desert Sun
Game:GetService(&quot;ContentProvider&quot;):Preload(&quot;http://www.roblox.com/asset/?id=66226104&quot;) -- Desert Sky 
Game:GetService(&quot;ContentProvider&quot;):Preload(&quot;http://www.roblox.com/asset/?id=66226069&quot;) -- Desert Floor 
Game:GetService(&quot;ContentProvider&quot;):Preload(&quot;http://www.roblox.com/asset/?id=66226112&quot;) -- Desert dunes close
Game:GetService(&quot;ContentProvider&quot;):Preload(&quot;http://www.roblox.com/asset/?id=66226129&quot;) -- Desert dunes far
-- Bosses
----------------------------------------------------------------------- 
-- Game Stuff
local gameScreen
local gameBackground
local gameBackground2
local gameFrame 
local gameChar
local gameCharObj
local gameFloor
local skyFrame
local sunImage

local gameBackground3 
local gameBackground4

local waterLevelRocksClose
local waterLevelRocksClose2
local waterLevelRocksMid
local waterLevelRocksMid2
local waterLevelRocksFar
local waterLevelRocksFar2

local gameCharHealthbarAssets = {66298629, 66298644, 66298656, 66298686, 66298698, 66298712}

for i = 1, #gameCharHealthbarAssets do 
&#9;game:GetService(&quot;ContentProvider&quot;):Preload(&quot;http://www.roblox.com/asset/?id=&quot; ..  gameCharHealthbarAssets[i]) 
end

local gameProjectile

local gameFloorObj = {}
local gameFloorObj2 = {}

local gameIntroScreen
local gameStartButton

local enemies = {}
enemies.NumEnemies = 0

local characterSprites = {65915569, 
&#9;65915609, 
&#9;65915569, 
&#9;65915630}

characterSprites[&quot;Jumping&quot;] = 65915653 
characterSprites[&quot;Default&quot;] = 65915569 

local meleeEnemySprites = {66197277} -- 66194981} 
meleeEnemySprites[&quot;Attack&quot;] = 66195009 

local rangedEnemySprites = {66189603, 66189620}
rangedEnemySprites[&quot;Attack&quot;] = 66189656
rangedEnemySprites[&quot;Projectile&quot;] = 66189699 

local cloneBossSprites = {66243554, 66243575, 66243591, 66243609} 
cloneBossSprites[&quot;Jumping&quot;] = 66243524 
cloneBossSprites[&quot;Default&quot;] = 66243554
cloneBossSprites[&quot;Attack&quot;] = 66249162 

for i, assetId in pairs(cloneBossSprites) do 
&#9;game:GetService(&quot;ContentProvider&quot;):Preload(&quot;http://www.roblox.com/asset/?id=&quot; .. assetId)
end

local enemyProjectiles = {}
local gameProjectileClones = {}


-- Coroutines -- Here they come
local jumpCo

-- Game World
local World = {}
World.BossActive = false
World.SpawnAllowed = true
World.LivesRemaining = 3
World.CloneBossObj = {}
World.MedusaBossObj = {}
World.SunBossObj = {}
World.LevelName = &quot;Grass&quot; 
World.WorldDistance = 8.25 -- 8.0

World.Platforms = {}

-- Physics Objects
local physicsObjects = {}
local gravity = 0.000981

-- Assume that the origin is in the center of the world

-- Right now defining the quad size as 1/10 of the size of the screen minimum 
-- that would give us about a 100 nodes total in the QuadTree

local Node = {}
local QuadTree = {}   
QuadTree.MinQuadSize = 0.05
QuadTree.RootNode = nil

function Node:new(x1, y1, x2, y2, parent, name)
&#9;local node = {}
&#9;node.x1 = x1
&#9;node.x2 = x2
&#9;node.y1 = y1
&#9;node.y2 = y2&#9;

&#9;node.Area = (x2 - x1) * (y2 - y1) 
&#9;
&#9;node.Objects = {} -- List of game objects that the given quad contains
&#9;node.Parent = parent -- Parent node of the object , for root node this would be nil &#9;
&#9;if name == nil or parent == nil then 
&#9;&#9;node.Name = &quot;Root&quot; 
&#9;else 
&#9;&#9;node.Name = parent.Name .. name
&#9;end 
&#9;print(node.Name, &quot; - &quot;,  node.x1, node.x2, node.y1, node.y2)
&#9;table.insert(QuadTree, node)
&#9;node.Children = QuadTree:ComputeChildren(node) -- 4 children per level 
&#9;return node
end

-- Given a frame or image Gui, this splits it up into regions and returns the tree 
function QuadTree:CreateTree(img)
&#9;local rootNode = Node:new(0, 0, img.Size.X.Scale, img.Size.Y.Scale, nil, &quot;Root&quot;)&#9;
&#9;return rootNode 
end 

function QuadTree:ComputeChildren(node)&#9;
&#9;-- Quad Size area is 0.05, i.e the minimum quad size relative is 0.125 
&#9;if node.Area &lt; QuadTree.MinQuadSize then return end 

&#9;local midPoint = Vector2.new((node.x1 + node.x2)/2.0, (node.y1 + node.y2)/2.0)
&#9;local n1 = Node:new(node.x1, node.y1, midPoint.X, midPoint.Y, node, &quot;T1&quot;)
&#9;local n2 = Node:new(midPoint.X, node.y1, node.x2, midPoint.Y, node, &quot;T2&quot;)
&#9;local n3 = Node:new(node.x1, midPoint.Y, midPoint.X, node.y2, node, &quot;D1&quot;)
&#9;local n4 = Node:new(midPoint.X, midPoint.Y, node.x2, node.y2, node, &quot;D2&quot;)
&#9;
&#9;return {n1, n2, n3, n4} -- Return a table of children
end

function QuadTree:PrintTree(node)
&#9;if node == nil then 
&#9;&#9;node = QuadTree.RootNode&#9;&#9;&#9;&#9;
&#9;&#9;print(QuadTree.RootNode)
&#9;end
&#9;-- Iterate through the tree 
&#9;--print(node.Name)
&#9;if node.Children and #node.Children &gt; 0 then
&#9;&#9;for i = 1, #node.Children do
&#9;&#9;&#9;QuadTree:PrintTree(node.Children[i])
&#9;&#9;end
&#9;end
end

function QuadTree:InsertObjectIntoQuad(object, quad)
&#9;if quad == nil then 
&#9;&#9;print(&quot;So, we are inserting to a nil parent, so find the parent!&quot;) &#9;
&#9;&#9;local objectCoordinates = {Vector2.new(object.Position.X.Scale, object.Position.Y.Scale)}&#9;&#9;
&#9;end
end

function QuadTree:RemoveObjectFromQuad(object, quad)
&#9;if quad == nil then 
&#9;&#9;print(&quot;Can&apos;t remove the object, its not found in the tree in the first place!&quot;) 
&#9;end
end
--
local worldSpace = {} -- The entire grid 

-- Box Collision
function checkForCollision(object, object2, offset) -- Need to add in the effects of velocity 
&#9;local leftMostOfObject = object.Position.X.Scale --[[+ object.Size.X.Scale]] + offset.X
&#9;local rightMostOfObject = object.Position.X.Scale + (10/10 * object.Size.X.Scale) + offset.X
&#9;local topMostOfObject = object.Position.Y.Scale --[[+(1/10 * object.Size.Y.Scale)]] + offset.Y
&#9;local bottomMostOfObject = object.Position.Y.Scale + (10/10 * object.Size.Y.Scale) + offset.Y
&#9;
&#9;local leftMostOfObject2 = object2.Position.X.Scale 
&#9;local rightMostOfObject2 = object2.Position.X.Scale + object2.Size.X.Scale
&#9;local topMostOfObject2 = object2.Position.Y.Scale 
&#9;local bottomMostOfObject2 = object2.Position.Y.Scale + object2.Size.Y.Scale

&#9;if (rightMostOfObject &gt; leftMostOfObject2) and (bottomMostOfObject &gt; topMostOfObject2) 
&#9;&#9;and (rightMostOfObject2 &gt; leftMostOfObject) and (bottomMostOfObject2 &gt; topMostOfObject) then&#9;
&#9;&#9;return true
&#9;else &#9;&#9;
&#9;&#9;return false
&#9;end&#9;
end 

-- For circle collision, assume that its being fed square GUIs, otherwise, disaster strikes, so hard
function checkForCircleCollision(object, object2, offset)
&#9;local r1 = object.Size.X.Scale/2.0 -- 
&#9;local r2 = object2.Size.X.Scale/2.0

&#9;local diff = math.abs((object.Position.X.Scale + offset.X - object2.Position.X.Scale) * 2.0) + math.abs((object.Position.Y.Scale + offset.Y - object2.Position.Y.Scale) * 2.0) 
&#9;
&#9;if diff &lt; r1 + r2 then &#9;&#9;
&#9;end
end

function resolveCollision(object, object2, offset)&#9;
&#9;local correctionVector = Vector2.new(0, 0) -- The direction in which this collision is going to push this object
&#9;local leftMostOfObject = object.Position.X.Scale --[[+ (1/10 * object.Size.X.Scale)]] + offset.X
&#9;local rightMostOfObject = object.Position.X.Scale + (10/10 * object.Size.X.Scale) + offset.X 
&#9;local topMostOfObject = object.Position.Y.Scale --[[+ (1/10 * object.Size.Y.Scale)]] + offset.Y
&#9;local bottomMostOfObject = object.Position.Y.Scale + (10/10 * object.Size.Y.Scale) + offset.Y

&#9;local leftMostOfObject2 = object2.Position.X.Scale 
&#9;local rightMostOfObject2 = object2.Position.X.Scale + object2.Size.X.Scale
&#9;local topMostOfObject2 = object2.Position.Y.Scale 
&#9;local bottomMostOfObject2 = object2.Position.Y.Scale + object2.Size.Y.Scale

&#9;local x1 = rightMostOfObject - leftMostOfObject2 
&#9;local x2 = -leftMostOfObject + rightMostOfObject2 
&#9;local y1 = bottomMostOfObject - topMostOfObject2 
&#9;local y2 = -topMostOfObject + bottomMostOfObject2

&#9;local directionX = math.min(math.abs(x1), math.abs(x2))
&#9;local directionY = math.min(math.abs(y1), math.abs(y2))

&#9;if directionX &lt; directionY then&#9;&#9;
&#9;&#9;if directionX == math.abs(x1) then&#9;&#9;&#9;
&#9;&#9;&#9;correctionVector = correctionVector + Vector2.new(-x1, 0)
&#9;&#9;elseif directonX == math.abs(x2) then
&#9;&#9;&#9;correctionVector = correctionVector + Vector2.new(x2, 0)
&#9;&#9;end
&#9;elseif directionY &lt; directionX  then &#9;&#9;
&#9;&#9;if directionY == math.abs(y1) then &#9;&#9;&#9;
&#9;&#9;&#9;correctionVector = correctionVector + Vector2.new(0, -y1)
&#9;&#9;elseif directionY == math.abs(y2) then&#9;&#9;&#9;
&#9;&#9;&#9;correctionVector = correctionVector + Vector2.new(0, y2)
&#9;&#9;end
&#9;end&#9;
&#9;return correctionVector
end

-- O(N^2) problem 
-- If N &gt; 40, there is delay 
-- The general cap seems to be around 37 objects, tested in multiple machines
-- i.e Can&apos;t do more than 35*35 = 1225 collision checks a frame 
-- With QuadTree this becomes a lot nicer, about 70 - 80 objects should be supported
-- 75 log 75 base 2 should be 75 * 8, around 600 checks 
-- But of course we are introducing the overhead of inserting and removing from the region Quad Tree 
-- Still should be a LOT better once done 
-- NOTE: The draw calls are crazy expensive since they are drawn regardless of whether they will be visible or not 

function World:SimulatePhysics()
&#9;-- Have to check for collision between themselves
&#9;for i = 1, #physicsObjects do 
&#9;&#9;if physicsObjects[i] then
&#9;&#9;&#9;physicsObjects[i].ResolutionVectors = {} -- Null the table every time step
&#9;&#9;&#9;physicsObjects[i].CollidingObjects = {} -- Null the object table, as well
&#9;&#9;&#9;for j = 1, #physicsObjects do 
&#9;&#9;&#9;&#9;if physicsObjects[i] and physicsObjects[j] and physicsObjects[i] ~= physicsObjects[j] and physicsObjects[i].Anchored == false then
&#9;&#9;&#9;&#9;&#9;local collided = checkForCollision(physicsObjects[i][1], physicsObjects[j][1], physicsObjects[i].Velocity)&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;if collided then
&#9;&#9;&#9;&#9;&#9;&#9;if physicsObjects[j] ~= gameFloorObj and physicsObjects[j] ~= gameFloorObj2 then end --print(&quot;Colliding Objects&quot;, physicsObjects[i][1], physicsObjects[j][1]) end
&#9;&#9;&#9;&#9;&#9;&#9;local collidingObject = {}
&#9;&#9;&#9;&#9;&#9;&#9;collidingObject.Velocity = physicsObjects[j].Velocity
&#9;&#9;&#9;&#9;&#9;&#9;collidingObject.Mass = physicsObjects[j].Mass
&#9;&#9;&#9;&#9;&#9;&#9;collidingObject.Anchored = physicsObjects[j].Anchored
&#9;&#9;&#9;&#9;&#9;&#9;table.insert(physicsObjects[i].CollidingObjects, collidingObject) -- populate the COR table
&#9;&#9;&#9;&#9;&#9;&#9;local correctionVector, direction = resolveCollision(physicsObjects[i][1], physicsObjects[j][1], physicsObjects[i].Velocity)&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;&#9;if correctionVector then &#9;&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;table.insert(physicsObjects[i].ResolutionVectors, correctionVector) 
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;physicsObjects[i].FreeFall = false
&#9;&#9;&#9;&#9;&#9;&#9;if physicsObjects[i].ClassName == &quot;Bot&quot; then &#9;&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if physicsObjects[i].Type == &quot;Melee&quot; and physicsObjects[j] == gameCharObj then &#9;&#9;&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;physicsObjects[i].Attacking = true
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;gameCharObj.Health = gameCharObj.Health - physicsObjects[i].Damage
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end&#9;&#9;&#9;
&#9;&#9;&#9;end
&#9;&#9;&#9;physicsObjects[i].CollectiveResolutionVector = Vector2.new(0, 0)
&#9;&#9;&#9;if #physicsObjects[i].ResolutionVectors &gt;= 1 then
&#9;&#9;&#9;&#9;for a = 1, #physicsObjects[i].ResolutionVectors do  -- Add the returned list &#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;physicsObjects[i].CollectiveResolutionVector = physicsObjects[i].CollectiveResolutionVector + physicsObjects[i].ResolutionVectors[a] &#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;end&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;end&#9;&#9;&#9;
&#9;&#9;&#9;if physicsObjects[i].CollectiveResolutionVector.Y + gravity &lt; 0 then 
&#9;&#9;&#9;&#9;physicsObjects[i].FreeFall = false&#9;&#9;&#9;
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;if physicsObjects[i] ~= gameCharObj then
&#9;&#9;&#9;&#9;&#9;physicsObjects[i].FreeFall = true
&#9;&#9;&#9;&#9;else 
&#9;&#9;&#9;&#9;&#9;if physicsObjects[i].Jumping == false then 
&#9;&#9;&#9;&#9;&#9;&#9;physicsObjects[i].FreeFall = true
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end&#9;&#9;&#9;
&#9;&#9;&#9;end&#9;
&#9;&#9;end
&#9;end&#9;
end
----------------------------------------------------------------------- 

function World:SimulateMovement()
&#9;for i = 1, #physicsObjects do 
&#9;&#9;if physicsObjects[i] and physicsObjects[i].Anchored == false then
&#9;&#9;&#9;if physicsObjects[i].FreeFall == true then &#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;--physicsObjects[i].FreeFallCounter = physicsObjects[i].FreeFallCounter + 1
&#9;&#9;&#9;&#9;physicsObjects[i].Velocity = physicsObjects[i].Velocity + Vector2.new(0, gravity) 
&#9;&#9;&#9;&#9;if physicsObjects[i].Velocity.magnitude &gt; 0.030 then -- Make Terminal Velocity as 0.030, i.e. 33 frames i.e. 1 second to traverse the world from left to right, top to bottom
&#9;&#9;&#9;&#9;&#9;physicsObjects[i].Velocity = physicsObjects[i].Velocity.unit * 0.030&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;end&#9;&#9;&#9;&#9;
&#9;&#9;&#9;else 
&#9;&#9;&#9;&#9;physicsObjects[i].FreeFallCounter = 0&#9;&#9;&#9;&#9;
&#9;&#9;&#9;end&#9;&#9;&#9;&#9;
&#9;&#9;&#9;if physicsObjects[i] == gameCharObj and ((gameCharObj[1].Position.X.Scale &gt; 0.50 and gameCharObj.Velocity.X &gt; 0.0) or (gameCharObj[1].Position.X.Scale &lt; 0.0 and gameCharObj.Velocity.X &lt; 0.0)) then 
&#9;&#9;&#9;&#9;-- nullify X Velocity 
&#9;&#9;&#9;&#9;gameCharObj.Velocity = Vector2.new(0.0, gameCharObj.Velocity.Y)
&#9;&#9;&#9;&#9;gameCharObj.HitEnd = true 
&#9;&#9;&#9;else 
&#9;&#9;&#9;&#9;gameCharObj.HitEnd = false 
&#9;&#9;&#9;&#9;if gameCharObj[1].Position.Y.Scale &gt; 0.8 then print(&quot;I am falling&quot;) end 
&#9;&#9;&#9;&#9;if gameCharObj.Velocity.X ~= 0 then gameCharObj.PrevVelocity = gameCharObj.Velocity end
&#9;&#9;&#9;end
&#9;&#9;&#9;physicsObjects[i][1].Position = physicsObjects[i][1].Position + UDim2.new(physicsObjects[i].Velocity.X + physicsObjects[i].CollectiveResolutionVector.X, 0, physicsObjects[i].Velocity.Y + physicsObjects[i].CollectiveResolutionVector.Y, 0) 
&#9;&#9;&#9;
&#9;&#9;&#9;-- COR here ----------------------------------------------------------------- 
&#9;&#9;&#9;for j = 1, #physicsObjects[i].CollidingObjects do 
&#9;&#9;&#9;&#9;local mAuA = physicsObjects[i].Mass * physicsObjects[i].Velocity
&#9;&#9;&#9;&#9;local mBuB = physicsObjects[i].CollidingObjects[j].Mass * physicsObjects[i].CollidingObjects[j].Velocity
&#9;&#9;&#9;&#9;local mbCr = physicsObjects[i].CollidingObjects[j].Mass * physicsObjects[i].CR * (physicsObjects[i].CollidingObjects[j].Velocity - physicsObjects[i].Velocity)
&#9;&#9;&#9;&#9;local mAmB = physicsObjects[i].Mass + physicsObjects[i].CollidingObjects[j].Mass
&#9;&#9;&#9;&#9;if physicsObjects[i].CollidingObjects[j].Anchored == true then
&#9;&#9;&#9;&#9;&#9;if physicsObjects[i].CollectiveResolutionVector.Y then
&#9;&#9;&#9;&#9;&#9;&#9;physicsObjects[i].Velocity = Vector2.new(physicsObjects[i].Velocity.X * physicsObjects[i].CR, ((mAuA + mBuB + mbCr)/mAmB).Y) -- Apply in only 1 axis
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;physicsObjects[i].Velocity = Vector2.new(((mAuA + mBuB + mbCr)/mAmB).X, physicsObjects[i].Velocity.Y * physicsObjects[i].CR)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;else 
&#9;&#9;&#9;&#9;&#9;physicsObjects[i].Velocity = (mAuA + mBuB + mbCr)/mAmB
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;-----------------------------------------------------------------------------&#9;&#9;&#9;
&#9;&#9;&#9;if physicsObjects[i][1].Position.Y.Scale &gt; 1.0  then
&#9;&#9;&#9;&#9;if physicsObjects[i] ~= gameCharObj then &#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;physicsObjects[i][1]:Remove() 
&#9;&#9;&#9;&#9;&#9;physicsObjects[i][1] = nil
&#9;&#9;&#9;&#9;&#9;table.remove(physicsObjects, i) &#9;
&#9;&#9;&#9;&#9;else 
&#9;&#9;&#9;&#9;&#9;-- kill Character 
&#9;&#9;&#9;&#9;&#9;gameCharObj.Health = 0
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end 
&#9;&#9;end
&#9;end
end

-- Special animation for character as it might be more verbose
function characterAnimation()
&#9;local spriteCount = 0
&#9;while gameCharObj and gameCharObj[1] do 
&#9;&#9;wait(0.1)
&#9;&#9;if gameCharObj and gameCharObj.Jumping == true then 
&#9;&#9;&#9;gameCharObj[1].Image = &quot;http://www.roblox.com/asset/?id=&quot; .. characterSprites[&quot;Jumping&quot;]
&#9;&#9;&#9;wait(0.8)
&#9;&#9;elseif gameCharObj and gameCharObj.Moving == true then 
&#9;&#9;&#9;gameCharObj[1].Image = &quot;http://www.roblox.com/asset/?id=&quot; .. characterSprites[(spriteCount%4) + 1]
&#9;&#9;&#9;spriteCount = spriteCount + 1
&#9;&#9;else 
&#9;&#9;&#9;if gameCharObj then 
&#9;&#9;&#9;&#9;gameCharObj[1].Image = &quot;http://www.roblox.com/asset/?id=&quot; .. characterSprites[&quot;Default&quot;]
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end 
end

function cloneAnimation()
&#9;local spriteCount = 0 
&#9;while World.CloneBossObj do 
&#9;&#9;wait(0.1)
&#9;&#9;if World.CloneBossObj and gameCharObj and gameCharObj.Jumping == true then 
&#9;&#9;&#9;World.CloneBossObj[1].Image = &quot;http://www.roblox.com/asset/?id=&quot; .. cloneBossSprites[&quot;Jumping&quot;]
&#9;&#9;&#9;wait(0.8)
&#9;&#9;elseif World.CloneBossObj and gameCharObj and gameCharObj.Moving == true then 
&#9;&#9;&#9;World.CloneBossObj[1].Image = &quot;http://www.roblox.com/asset/?id=&quot; .. cloneBossSprites[(spriteCount%4) + 1] 
&#9;&#9;&#9;spriteCount = spriteCount + 1
&#9;&#9;else 
&#9;&#9;&#9;if World.CloneBossObj and gameCharObj then 
&#9;&#9;&#9;&#9;World.CloneBossObj[1].Image = &quot;http://www.roblox.com/asset/?id=&quot; .. cloneBossSprites[&quot;Default&quot;] 
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

function animateSprites(object)
&#9;local spriteCount= 1
&#9;while object do 
&#9;&#9;if object and object.Attacking == true then 
&#9;&#9;&#9;print(&quot;Attacking&quot;)
&#9;&#9;&#9;--object[1].Image = &quot;http://www.roblox.com/asset/?id=&quot; .. object.Sprites[&quot;Attack&quot;] 
&#9;&#9;&#9;wait(0.50)
&#9;&#9;else
&#9;&#9;&#9;--if object then object[1].Image = &quot;http://www.roblox.com/asset/?id=&quot; .. object.Sprites[spriteCount%(#object.Sprites - 1) + 1]  end
&#9;&#9;end 
&#9;&#9;wait(0.1)
&#9;end
end

function shootCharacter(direction, projectile, enemy, damage)&#9;
&#9;local collision 
&#9;while projectile do &#9;
&#9;&#9;local velocity = 0.010 
&#9;&#9;if enemy.Type == &quot;Boss&quot; then velocity = 0.020 end 
&#9;&#9;projectile.Position = projectile.Position + UDim2.new(direction.X * 0.020, 0, direction.Y * 0.020, 0)
&#9;&#9;if projectile.Position.X.Scale &gt; 1.0 or projectile.Position.X.Scale &lt; 0.0 or projectile.Position.Y.Scale &gt; 1.0 or projectile.Position.Y.Scale &lt; 0.0 then&#9;&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;projectile:Remove()
&#9;&#9;&#9;projectile = nil 
&#9;&#9;end
&#9;&#9;if projectile then &#9;&#9;
&#9;&#9;&#9;if projectile and gameCharObj then 
&#9;&#9;&#9;&#9;local collision = checkForCollision(projectile, gameCharObj[1], direction * 0.005) 
&#9;&#9;&#9;&#9;if collision then 
&#9;&#9;&#9;&#9;&#9;if projectile and gameCharObj and gameCharObj.ForceField == false then &#9;&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;&#9;gameCharObj.Health = gameCharObj.Health - damage 
&#9;&#9;&#9;&#9;&#9;&#9;projectile:Remove()
&#9;&#9;&#9;&#9;&#9;&#9;projectile = nil 
&#9;&#9;&#9;&#9;&#9;&#9;if gameCharObj.Health &lt; 0.0 then 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;gameCharObj.Dead = true 
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end 
&#9;&#9;wait()
&#9;end
&#9;wait(1.75)
&#9;if enemies[enemy] then enemies[enemy].CanFire = true end 
end

function World:AIUpdate()
&#9;for i, enemy in pairs (enemies) do&#9;&#9;
&#9;&#9;if enemy and enemy ~= enemies.NumEnemies and gameCharObj and enemy[1] then
&#9;&#9;&#9;local direction = Vector2.new(0, 0)
&#9;&#9;&#9;if enemy.Type == &quot;Melee&quot; then &#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;if gameCharObj.Jumping == true and enemy[1] then
&#9;&#9;&#9;&#9;&#9;direction = Vector2.new(gameCharObj[1].Position.X.Scale - enemy[1].Position.X.Scale, 0, 0, 0).unit
&#9;&#9;&#9;&#9;else 
&#9;&#9;&#9;&#9;&#9;direction = Vector2.new(gameCharObj[1].Position.X.Scale - enemy[1].Position.X.Scale, 0, 0, 0).unit
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;enemy.Velocity = direction * 0.004
&#9;&#9;&#9;elseif enemy.Type  == &quot;Ranged&quot; and gameCharObj then 
&#9;&#9;&#9;&#9;direction = Vector2.new(0 - enemy[1].Position.X.Scale, 0 - enemy[1].Position.Y.Scale).unit
&#9;&#9;&#9;&#9;enemy.Velocity = Vector2.new(direction.X, 0.0) * 0.004
&#9;&#9;&#9;&#9;if enemy.CanFire == true and enemy[1].Position.X.Scale &gt; gameCharObj[1].Position.X.Scale then
&#9;&#9;&#9;&#9;&#9;print(&quot;Ranged fire&quot;)
&#9;&#9;&#9;&#9;&#9;enemy.CanFire = false 
&#9;&#9;&#9;&#9;&#9;local projectile = Instance.new(&quot;ImageLabel&quot;)
&#9;&#9;&#9;&#9;&#9;projectile.Size = UDim2.new(0.03, 0, 0.03, 0)
&#9;&#9;&#9;&#9;&#9;projectile.Image = &quot;http://www.roblox.com/asset/?id=&quot; .. enemy.Sprites[&quot;Projectile&quot;]
&#9;&#9;&#9;&#9;&#9;projectile.Name = &quot;Attack&quot;
&#9;&#9;&#9;&#9;&#9;projectile.Parent = gameFrame 
&#9;&#9;&#9;&#9;&#9;print(projectile.Parent, projectile.Name)
&#9;&#9;&#9;&#9;&#9;projectile.BackgroundTransparency = 1.0
&#9;&#9;&#9;&#9;&#9;projectile.ZIndex = 5.0
&#9;&#9;&#9;&#9;&#9;projectile.Position = enemy[1].Position + UDim2.new(enemy.Velocity.X, 0, enemy.Velocity.Y, 0)&#9;
&#9;&#9;&#9;&#9;&#9;direction = Vector2.new(gameCharObj[1].Position.X.Scale - projectile.Position.X.Scale, gameCharObj[1].Position.Y.Scale - projectile.Position.Y.Scale).unit 
&#9;&#9;&#9;&#9;&#9;projectile.BackgroundTransparency = 1.0 
&#9;&#9;&#9;&#9;&#9;table.insert(enemyProjectiles, projectile)&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;coroutine.resume(coroutine.create(function() shootCharacter(direction, projectile, enemy, enemy.Damage) end))
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if enemy and enemy[1].Position.X.Scale &gt; 1.0 or enemy[1].Position.X.Scale &lt; 0.0 or enemy[1].Position.Y.Scale &gt; 1.0 or enemy[1].Position.Y.Scale &lt; 0.0 then&#9;&#9;
&#9;&#9;&#9;&#9;&#9;for i = 1, #physicsObjects do 
&#9;&#9;&#9;&#9;&#9;&#9;if physicsObjects[i] == enemy then table.remove(physicsObjects, i) end
&#9;&#9;&#9;&#9;&#9;end&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;enemy[1]:Remove()&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;enemies[enemy] = nil 
&#9;&#9;&#9;&#9;&#9;enemy = nil 
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end 
end

function World:ScrollWorld()&#9;
&#9;if gameCharObj then &#9;&#9;
&#9;&#9;if gameCharObj and gameCharObj[1] and gameCharObj[1].Position.X.Scale &gt; 0.05 and not World.BossActive then &#9;&#9;&#9;
&#9;&#9;&#9;if gameCharObj.PrevVelocity.X &gt; 0 then World.DistanceTravelled = World.DistanceTravelled + (gameCharObj.PrevVelocity.X * 5) end&#9;&#9;&#9;
&#9;&#9;&#9;if World.DistanceTravelled &gt; World.WorldDistance then 
&#9;&#9;&#9;&#9;print(World.DistanceTravelled)
&#9;&#9;&#9;&#9;World:SpawnBoss(World.LevelName)
&#9;&#9;&#9;end
&#9;&#9;&#9;if World.LevelName == &quot;Grass&quot; then 
&#9;&#9;&#9;&#9;if gameBackground.Position.X.Scale &lt; -1.0 or gameBackground2.Position.X.Scale &gt; 1.0 then 
&#9;&#9;&#9;&#9;&#9;gameBackground.Position = UDim2.new(1, 0, 0, 0)&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;gameBackground2.Position = UDim2.new(0, 0, 0, 0)&#9;&#9;&#9;
&#9;&#9;&#9;&#9;elseif gameBackground2.Position.X.Scale &lt; -1.0 or gameBackground.Position.X.Scale &gt; 1.0 then 
&#9;&#9;&#9;&#9;&#9;gameBackground.Position = UDim2.new(0, 0, 0, 0)
&#9;&#9;&#9;&#9;&#9;gameBackground2.Position = UDim2.new(1, 0, 0, 0)
&#9;&#9;&#9;&#9;else &#9;&#9;
&#9;&#9;&#9;&#9;&#9;--print(&quot;X - &quot;, gameCharObj.PrevVelocity.X)
&#9;&#9;&#9;&#9;&#9;gameBackground.Position = UDim2.new(gameBackground.Position.X.Scale - gameCharObj.PrevVelocity.X/10, 0, gameBackground.Position.Y.Scale, 0) &#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;gameBackground2.Position = UDim2.new(gameBackground2.Position.X.Scale - gameCharObj.PrevVelocity.X/10, 0, gameBackground2.Position.Y.Scale, 0) &#9;
&#9;&#9;&#9;&#9;&#9;sunImage.Position = UDim2.new(sunImage.Position.X.Scale + gameCharObj.PrevVelocity.X/20, 0, sunImage.Position.Y.Scale, 0)
&#9;&#9;&#9;&#9;end&#9;
&#9;&#9;&#9;end

&#9;&#9;&#9;if gameFloorObj[1].Position.X.Scale &lt; -1.0 or gameFloorObj2[1].Position.X.Scale &gt; 1.0 then
&#9;&#9;&#9;&#9;gameFloorObj[1].Position = UDim2.new(1, 0, 0.8, 0)
&#9;&#9;&#9;&#9;gameFloorObj2[1].Position = UDim2.new(0, 0, 0.8, 0)
&#9;&#9;&#9;elseif gameFloorObj2[1].Position.X.Scale &lt; -1.0 or gameFloorObj[1].Position.X.Scale &gt; 1.0 then 
&#9;&#9;&#9;&#9;gameFloorObj[1].Position = UDim2.new(0, 0, 0.8, 0)
&#9;&#9;&#9;&#9;gameFloorObj2[1].Position = UDim2.new(1, 0, 0.8, 0)
&#9;&#9;&#9;else &#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;gameFloorObj[1].Position = UDim2.new(gameFloorObj[1].Position.X.Scale - gameCharObj.PrevVelocity.X, 0, gameFloorObj[1].Position.Y.Scale, 0) &#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;gameFloorObj2[1].Position = UDim2.new(gameFloorObj2[1].Position.X.Scale - gameCharObj.PrevVelocity.X, 0, gameFloorObj2[1].Position.Y.Scale, 0) &#9;&#9;&#9;&#9;
&#9;&#9;&#9;end
&#9;&#9;&#9;if World.LevelName == &quot;Desert&quot; then 
&#9;&#9;&#9;&#9;if gameBackground.Position.X.Scale &lt; -1.0 or gameBackground2.Position.X.Scale &gt; 1.0 then 
&#9;&#9;&#9;&#9;&#9;gameBackground.Position = UDim2.new(1, 0, 0.5, 0)&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;gameBackground2.Position = UDim2.new(0, 0, 0.5, 0)&#9;&#9;&#9;
&#9;&#9;&#9;&#9;elseif gameBackground2.Position.X.Scale &lt; -1.0 or gameBackground.Position.X.Scale &gt; 1.0 then 
&#9;&#9;&#9;&#9;&#9;gameBackground.Position = UDim2.new(0, 0, 0.5, 0)
&#9;&#9;&#9;&#9;&#9;gameBackground2.Position = UDim2.new(1, 0, 0.5, 0)
&#9;&#9;&#9;&#9;else &#9;&#9;
&#9;&#9;&#9;&#9;&#9;--print(&quot;X - &quot;, gameCharObj.PrevVelocity.X)
&#9;&#9;&#9;&#9;&#9;gameBackground.Position = UDim2.new(gameBackground.Position.X.Scale - gameCharObj.PrevVelocity.X/10, 0, gameBackground.Position.Y.Scale, 0) &#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;gameBackground2.Position = UDim2.new(gameBackground2.Position.X.Scale - gameCharObj.PrevVelocity.X/10, 0, gameBackground2.Position.Y.Scale, 0) &#9;
&#9;&#9;&#9;&#9;&#9;sunImage.Position = UDim2.new(sunImage.Position.X.Scale + gameCharObj.PrevVelocity.X/20, 0, sunImage.Position.Y.Scale, 0)
&#9;&#9;&#9;&#9;end&#9;

&#9;&#9;&#9;&#9;if gameBackground3 and gameBackground4 then
&#9;&#9;&#9;&#9;&#9;if gameBackground3.Position.X.Scale &lt; -1.0 or gameBackground4.Position.X.Scale &gt; 1.0 then 
&#9;&#9;&#9;&#9;&#9;&#9;gameBackground3.Position = UDim2.new(1, 0, 0.6, 0)&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;&#9;gameBackground4.Position = UDim2.new(0, 0, 0.6, 0)&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;elseif gameBackground4.Position.X.Scale &lt; -1.0 or gameBackground3.Position.X.Scale &gt; 1.0 then 
&#9;&#9;&#9;&#9;&#9;&#9;gameBackground3.Position = UDim2.new(0, 0, 0.6, 0)
&#9;&#9;&#9;&#9;&#9;&#9;gameBackground4.Position = UDim2.new(1, 0, 0.6, 0)
&#9;&#9;&#9;&#9;&#9;else &#9;&#9;&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;&#9;gameBackground3.Position = UDim2.new(gameBackground3.Position.X.Scale - gameCharObj.PrevVelocity.X/5, 0, gameBackground3.Position.Y.Scale, 0) &#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;&#9;gameBackground4.Position = UDim2.new(gameBackground4.Position.X.Scale - gameCharObj.PrevVelocity.X/5, 0, gameBackground4.Position.Y.Scale, 0) &#9;&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end 
&#9;&#9;
&#9;&#9;&#9;if World.LevelName == &quot;Water&quot; then&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;if waterLevelRocksClose.Position.X.Scale &lt; -1.0 or waterLevelRocksClose2.Position.X.Scale &gt; 1.0  then 
&#9;&#9;&#9;&#9;&#9;waterLevelRocksClose.Position = UDim2.new(1, 0, 0.9, 0)
&#9;&#9;&#9;&#9;&#9;waterLevelRocksClose2.Position = UDim2.new(0, 0, 0.9,0)
&#9;&#9;&#9;&#9;elseif waterLevelRocksClose2.Position.X.Scale &lt; -1.0 or waterLevelRocksClose.Position.X.Scale &gt; 1.0 then 
&#9;&#9;&#9;&#9;&#9;waterLevelRocksClose.Position = UDim2.new(0, 0, 0.9, 0)
&#9;&#9;&#9;&#9;&#9;waterLevelRocksClose2.Position = UDim2.new(1, 0, 0.9, 0)
&#9;&#9;&#9;&#9;else 
&#9;&#9;&#9;&#9;&#9;waterLevelRocksClose.Position = UDim2.new(waterLevelRocksClose.Position.X.Scale - gameCharObj.PrevVelocity.X, 0, 0.9, 0)
&#9;&#9;&#9;&#9;&#9;waterLevelRocksClose2.Position = UDim2.new(waterLevelRocksClose2.Position.X.Scale - gameCharObj.PrevVelocity.X, 0, 0.9, 0)
&#9;&#9;&#9;&#9;end
&#9;
&#9;&#9;&#9;&#9;if waterLevelRocksMid.Position.X.Scale &lt; -1.0 or waterLevelRocksMid2.Position.X.Scale &gt; 1.0  then 
&#9;&#9;&#9;&#9;&#9;waterLevelRocksMid.Position = UDim2.new(1, 0, 0.9, 0)
&#9;&#9;&#9;&#9;&#9;waterLevelRocksMid2.Position = UDim2.new(0, 0, 0.9,0)
&#9;&#9;&#9;&#9;elseif waterLevelRocksMid2.Position.X.Scale &lt; -1.0 or waterLevelRocksMid.Position.X.Scale &gt; 1.0 then 
&#9;&#9;&#9;&#9;&#9;waterLevelRocksMid.Position = UDim2.new(0, 0, 0.9, 0)
&#9;&#9;&#9;&#9;&#9;waterLevelRocksMid2.Position = UDim2.new(1, 0, 0.9, 0)
&#9;&#9;&#9;&#9;else 
&#9;&#9;&#9;&#9;&#9;waterLevelRocksMid.Position = UDim2.new(waterLevelRocksMid.Position.X.Scale - gameCharObj.PrevVelocity.X/2.5, 0, 0.9, 0)
&#9;&#9;&#9;&#9;&#9;waterLevelRocksMid2.Position = UDim2.new(waterLevelRocksMid2.Position.X.Scale - gameCharObj.PrevVelocity.X/2.5, 0, 0.9, 0)
&#9;&#9;&#9;&#9;end
&#9;
&#9;&#9;&#9;&#9;if waterLevelRocksFar.Position.X.Scale &lt; -1.0 or waterLevelRocksFar2.Position.X.Scale &gt; 1.0  then 
&#9;&#9;&#9;&#9;&#9;waterLevelRocksFar.Position = UDim2.new(1, 0, 0.9, 0)
&#9;&#9;&#9;&#9;&#9;waterLevelRocksFar2.Position = UDim2.new(0, 0, 0.9,0)
&#9;&#9;&#9;&#9;elseif waterLevelRocksFar2.Position.X.Scale &lt; -1.0 or waterLevelRocksFar.Position.X.Scale &gt; 1.0 then 
&#9;&#9;&#9;&#9;&#9;waterLevelRocksFar.Position = UDim2.new(0, 0, 0.9, 0)
&#9;&#9;&#9;&#9;&#9;waterLevelRocksFar2.Position = UDim2.new(1, 0, 0.9, 0)
&#9;&#9;&#9;&#9;else 
&#9;&#9;&#9;&#9;&#9;waterLevelRocksFar.Position = UDim2.new(waterLevelRocksFar.Position.X.Scale - gameCharObj.PrevVelocity.X/5, 0, 0.9, 0)
&#9;&#9;&#9;&#9;&#9;waterLevelRocksFar2.Position = UDim2.new(waterLevelRocksFar2.Position.X.Scale - gameCharObj.PrevVelocity.X/5, 0, 0.9, 0)
&#9;&#9;&#9;&#9;end
&#9;&#9;
&#9;&#9;&#9;&#9;for i = 1, #World.Platforms do 
&#9;&#9;&#9;&#9;&#9;if World.Platforms[i][1].Position.X.Scale &lt; -0.25 then 
&#9;&#9;&#9;&#9;&#9;&#9;World.Platforms[i][1].Position = UDim2.new(1 - 0.13, 0, 0.80, 0)
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;World.Platforms[i][1].Position = UDim2.new(World.Platforms[i][1].Position.X.Scale - gameCharObj.PrevVelocity.X, 0, 0.80, 0)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;end 
&#9;&#9;end
&#9;end
end

function World:SpawnBoss(lvlName)
&#9;print(&quot;Spawning Boss&quot;)
&#9;World.BossActive = true 
&#9;World.DistanceTravelled = 0.0
&#9;wait(1.0)
&#9;for i, enemy in pairs(enemies) do 
&#9;&#9;if enemy ~= enemies.NumEnemies then
&#9;&#9;&#9;for i = 1, #physicsObjects do 
&#9;&#9;&#9;&#9;if physicsObjects[i] == enemy then 
&#9;&#9;&#9;&#9;&#9;table.remove(physicsObjects, i)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;enemy[1]:Remove()&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;enemies[enemy] = nil 
&#9;&#9;&#9;enemy = nil 
&#9;&#9;end
&#9;end
&#9;if lvlName == &quot;Grass&quot; and gameCharObj then&#9;&#9;
&#9;&#9;local cloneBoss = Instance.new(&quot;ImageLabel&quot;)
&#9;&#9;cloneBoss.Parent = gameFrame
&#9;&#9;cloneBoss.Size = UDim2.new(0.022, 0, 0.057, 0)
&#9;&#9;cloneBoss.Name = &quot;Clone Boss&quot;
&#9;&#9;cloneBoss.ZIndex = 5.0
&#9;&#9;cloneBoss.BackgroundTransparency = 1.0
&#9;&#9;cloneBoss.Position = UDim2.new((1 - gameCharObj[1].Position.X.Scale) + 0.1, 0, gameCharObj[1].Position.Y.Scale, 0)
&#9;&#9;cloneBoss.Image = &quot;http://www.roblox.com/asset/?id=66243554&quot;&#9;&#9;
&#9;&#9;table.insert(World.CloneBossObj, cloneBoss)
&#9;&#9;World.CloneBossObj.Velocity = Vector2.new(-gameCharObj.Velocity.X, gameCharObj.Velocity.Y)
&#9;&#9;World.CloneBossObj.Mass = cloneBoss.Size.X.Scale * cloneBoss.Size.Y.Scale * 50.0
&#9;&#9;World.CloneBossObj.CR = 0.3&#9;
&#9;&#9;World.CloneBossObj.CollidingObjects = {}
&#9;&#9;World.CloneBossObj.ResolutionVectors = {}
&#9;&#9;World.CloneBossObj.CollectiveResolutionVector = Vector2.new(0, 0)
&#9;&#9;World.CloneBossObj.FreeFall = false 
&#9;&#9;World.CloneBossObj.FreeFallCounter = 0.0
&#9;&#9;World.CloneBossObj.Anchored = false
&#9;&#9;World.CloneBossObj.Moving = false -- For character Movement
&#9;&#9;World.CloneBossObj.Forwards = false 
&#9;&#9;World.CloneBossObj.Backwards = false 
&#9;&#9;World.CloneBossObj.Jumping = false
&#9;&#9;World.CloneBossObj.HitEnd = false 
&#9;&#9;World.CloneBossObj.ForceField = false 
&#9;&#9;World.CloneBossObj.Dead = false 
&#9;&#9;World.CloneBossObj.Firing = false&#9;&#9;&#9;&#9;
&#9;&#9;World.CloneBossObj.Health = 120&#9;
&#9;&#9;World.CloneBossObj.Damage = 17
&#9;&#9;World.CloneBossObj.Type = &quot;Boss&quot;
&#9;&#9;World.CloneBossObj.Sprites = cloneBossSprites

&#9;&#9;table.insert(physicsObjects, World.CloneBossObj)
&#9;&#9;World.CloneBossObj.PositionInArray = #physicsObjects
&#9;&#9;coroutine.resume(coroutine.create(cloneAnimation))
&#9;&#9;print(gameCharObj.Anchored)
&#9;&#9;coroutine.resume(coroutine.create(function () 
&#9;&#9;&#9;while World.CloneBossObj and World.CloneBossObj.Health &gt; 0 do
&#9;&#9;&#9;&#9;if gameCharObj and gameCharObj.Anchored == false then
&#9;&#9;&#9;&#9;&#9;World.CloneBossObj.Velocity = Vector2.new(-gameCharObj.PrevVelocity.X, gameCharObj.Velocity.Y * 1.1) &#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;if gameCharObj.Velocity.Y &gt; 0.001 then World.CloneBossObj.Velocity = Vector2.new(-gameCharObj.PrevVelocity.X, gameCharObj.Velocity.Y * 1.1) end
&#9;&#9;&#9;&#9;&#9;if gameCharObj.Firing == true then &#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;&#9;if World.CloneBossObj.Firing == false then 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;for i = 1, #physicsObjects do 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;if physicsObjects[i][1] then print(physicsObjects[i][1]) end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;print(&quot;Physics&quot; .. i) 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;World.CloneBossObj.Firing = true 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;local projectile = Instance.new(&quot;ImageLabel&quot;)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;projectile.Size = UDim2.new(0.02, 0, 0.02, 0)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;projectile.Image = &quot;http://www.roblox.com/asset/?id=&quot; .. World.CloneBossObj.Sprites[&quot;Attack&quot;]
&#9;&#9;&#9;&#9;&#9;&#9;&#9;projectile.Name = &quot;Attack&quot;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;projectile.Parent = gameFrame 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;print(projectile.Parent, projectile.Name)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;projectile.BackgroundTransparency = 1.0
&#9;&#9;&#9;&#9;&#9;&#9;&#9;projectile.ZIndex = 5.0
&#9;&#9;&#9;&#9;&#9;&#9;&#9;projectile.Position = World.CloneBossObj[1].Position + UDim2.new(World.CloneBossObj.Velocity.X, 0, World.CloneBossObj.Velocity.Y, 0)&#9;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;direction = Vector2.new(gameCharObj[1].Position.X.Scale - projectile.Position.X.Scale, gameCharObj[1].Position.Y.Scale - projectile.Position.Y.Scale).unit 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;projectile.BackgroundTransparency = 1.0 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;table.insert(enemyProjectiles, projectile)&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;coroutine.resume(coroutine.create(function() &#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9; 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;shootCharacter(direction, projectile, World.CloneBossObj, World.CloneBossObj.Damage) &#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end))
&#9;&#9;&#9;&#9;&#9;&#9;&#9;coroutine.resume(coroutine.create(function() wait(0.65) if World.CloneBossObj then World.CloneBossObj.Firing = false end end))
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;wait()
&#9;&#9;&#9;end&#9;&#9;
&#9;&#9;&#9;wait(1.5)
&#9;&#9;&#9;World:InitiateWaterAssets()&#9;&#9;&#9;
&#9;&#9;&#9;World.BossActive = false &#9;&#9;&#9;
&#9;&#9;end))&#9;&#9;
&#9;elseif lvlName == &quot;Water&quot; and gameCharObj then
&#9;&#9;print(&quot;Spawning Medusa&quot;)
&#9;&#9;World.BossActive = true 
&#9;&#9;-- spawn Medusa&#9;&#9;
&#9;&#9;gameCharObj.Anchored = true 
&#9;&#9;for i = 1, #World.Platforms do 
&#9;&#9;&#9;if World.Platforms[i] and World.Platforms[i][1] and World.Platforms[i][1].Position.X.Scale &gt; 0.45 then &#9;&#9;&#9;
&#9;&#9;&#9;&#9;for j = 1, #physicsObjects do &#9;
&#9;&#9;&#9;&#9;&#9;if physicsObjects[j] == World.Platforms[i] then 
&#9;&#9;&#9;&#9;&#9;&#9;table.remove(physicsObjects, j)
&#9;&#9;&#9;&#9;&#9;end 
&#9;&#9;&#9;&#9;end 
&#9;&#9;&#9;&#9;World.Platforms[i][1]:Remove()
&#9;&#9;&#9;&#9;table.remove(World.Platforms, i)  
&#9;&#9;&#9;end 
&#9;&#9;end

&#9;&#9;local medusaPlatformObj = {}

&#9;&#9;local medusaPlatform = Instance.new(&quot;ImageLabel&quot;)&#9;&#9;
&#9;&#9;medusaPlatform.Parent = gameFrame 
&#9;&#9;medusaPlatform.Size = UDim2.new(0.35, 0, 0.25, 0)
&#9;&#9;medusaPlatform.ZIndex = 5.0 
&#9;&#9;medusaPlatform.Name = &quot;Medusa Platform&quot;
&#9;&#9;medusaPlatform.Position = UDim2.new(0.65, 0, 0.75, 0)
&#9;&#9;medusaPlatform.Image = &quot;http://www.roblox.com/asset/?id=66352383&quot; 
&#9;&#9;medusaPlatform.BackgroundTransparency = 1.0

&#9;&#9;table.insert(medusaPlatformObj, medusaPlatform)
&#9;&#9;medusaPlatformObj.Anchored = true 
&#9;&#9;medusaPlatformObj.Mass = 1.0 
&#9;&#9;medusaPlatformObj.Velocity = Vector2.new(0, 0, 0)
&#9;&#9;medusaPlatformObj.CR = 0.0

&#9;&#9;local medusaBoss = Instance.new(&quot;ImageLabel&quot;)
&#9;&#9;medusaBoss.Parent = gameFrame
&#9;&#9;medusaBoss.Size = UDim2.new(0.075, 0, 0.15, 0)
&#9;&#9;medusaBoss.Name = &quot;Medusa&quot;
&#9;&#9;medusaBoss.ZIndex = 5.0
&#9;&#9;medusaBoss.BackgroundTransparency = 1.0
&#9;&#9;medusaBoss.Position = UDim2.new(0.75, 0, 0.45, 0)
&#9;&#9;medusaBoss.Image = &quot;http://www.roblox.com/asset/?id=66352213&quot;&#9;&#9;
&#9;&#9;table.insert(World.MedusaBossObj, medusaBoss)
&#9;&#9;World.MedusaBossObj.Velocity = Vector2.new(0, 0)
&#9;&#9;World.MedusaBossObj.Mass = medusaBoss.Size.X.Scale * medusaBoss.Size.Y.Scale * 50.0
&#9;&#9;World.MedusaBossObj.CR = 0.3&#9;
&#9;&#9;World.MedusaBossObj.CollidingObjects = {}
&#9;&#9;World.MedusaBossObj.ResolutionVectors = {}
&#9;&#9;World.MedusaBossObj.CollectiveResolutionVector = Vector2.new(0, 0)
&#9;&#9;World.MedusaBossObj.FreeFall = false 
&#9;&#9;World.MedusaBossObj.FreeFallCounter = 0.0
&#9;&#9;World.MedusaBossObj.Anchored = false  
&#9;&#9;World.MedusaBossObj.Moving = false -- For character Movement
&#9;&#9;World.MedusaBossObj.Forwards = false 
&#9;&#9;World.MedusaBossObj.Backwards = false 
&#9;&#9;World.MedusaBossObj.Jumping = false
&#9;&#9;World.MedusaBossObj.HitEnd = false 
&#9;&#9;World.MedusaBossObj.ForceField = false 
&#9;&#9;World.MedusaBossObj.Dead = false 
&#9;&#9;World.MedusaBossObj.Firing = false&#9;&#9;&#9;&#9;
&#9;&#9;World.MedusaBossObj.Health = 200&#9;
&#9;&#9;World.MedusaBossObj.Damage = 19
&#9;&#9;World.MedusaBossObj.Type = &quot;Boss&quot;
&#9;&#9;World.MedusaBossObj.Platform = medusaPlatformObj
&#9;&#9;table.insert(physicsObjects, World.MedusaBossObj)
&#9;&#9;table.insert(physicsObjects, World.MedusaBossObj.Platform)&#9;&#9;&#9;&#9;&#9; 

&#9;&#9;for i = 1, #World.Platforms do 
&#9;&#9;&#9;local minXPlatform 
&#9;&#9;&#9;local minX = 2.0 
&#9;&#9;&#9;if World.Platforms[i] and World.Platforms[i][1] and World.Platforms[i][1].Position.X.Scale &lt; minX then 
&#9;&#9;&#9;&#9;minX = World.Platforms[i][1].Position.X.Scale 
&#9;&#9;&#9;&#9;gameCharObj[1].Position = UDim2.new(minX + 0.05, 0, 0.65, 0)
&#9;&#9;&#9;end 
&#9;&#9;end 
&#9;&#9;gameCharObj.Anchored = false 
&#9;&#9;coroutine.resume(coroutine.create(function() 
&#9;&#9;&#9;while World.MedusaBossObj and World.MedusaBossObj.Health &gt; 0 do 
&#9;&#9;&#9;&#9;if World.MedusaBossObj.Firing == false then 
&#9;&#9;&#9;&#9;&#9;World.MedusaBossObj.Firing = true
&#9;&#9;&#9;&#9;&#9;local randFire = math.random() 
&#9;&#9;&#9;&#9;&#9;local numProjectiles = 2
&#9;&#9;&#9;&#9;&#9;if randFire &lt; 0.5 then numProjectiles = 2 
&#9;&#9;&#9;&#9;&#9;elseif randFire &gt; 0.5 and randFire &lt; 0.8 then numProjectiles = 3 &#9;
&#9;&#9;&#9;&#9;&#9;elseif randFire &gt; 0.8 and randFire &lt; 0.8 then numProjectiles = 4 
&#9;&#9;&#9;&#9;&#9;else 
&#9;&#9;&#9;&#9;&#9;&#9;numProjectiles = 7
&#9;&#9;&#9;&#9;&#9;end 
&#9;&#9;&#9;&#9;&#9;for i = 0, numProjectiles - 1 do 
&#9;&#9;&#9;&#9;&#9;&#9;local projectile = Instance.new(&quot;ImageLabel&quot;)
&#9;&#9;&#9;&#9;&#9;&#9;projectile.Size = UDim2.new(0.04, 0, 0.02, 0)
&#9;&#9;&#9;&#9;&#9;&#9;projectile.Image = &quot;http://www.roblox.com/asset/?id=&quot; .. 66352726
&#9;&#9;&#9;&#9;&#9;&#9;projectile.Name = &quot;Attack&quot;
&#9;&#9;&#9;&#9;&#9;&#9;projectile.Parent = gameFrame &#9;&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;&#9;projectile.BackgroundTransparency = 1.0
&#9;&#9;&#9;&#9;&#9;&#9;projectile.ZIndex = 5.0
&#9;&#9;&#9;&#9;&#9;&#9;projectile.Position = World.MedusaBossObj[1].Position + UDim2.new(World.MedusaBossObj.Velocity.X, 0, World.MedusaBossObj.Velocity.Y, 0)&#9;
&#9;&#9;&#9;&#9;&#9;&#9;direction = Vector2.new(gameCharObj[1].Position.X.Scale - projectile.Position.X.Scale, (gameCharObj[1].Position.Y.Scale - projectile.Position.Y.Scale) + math.random(-0.5, 0.5)/40).unit 
&#9;&#9;&#9;&#9;&#9;&#9;projectile.BackgroundTransparency = 1.0 
&#9;&#9;&#9;&#9;&#9;&#9;table.insert(enemyProjectiles, projectile)&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;&#9;coroutine.resume(coroutine.create(function() &#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9; 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;shootCharacter(direction, projectile, World.MedusaBossObj, World.MedusaBossObj.Damage) &#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;&#9;end))
&#9;&#9;&#9;&#9;&#9;&#9;wait()
&#9;&#9;&#9;&#9;&#9;end 
&#9;&#9;&#9;&#9;&#9;coroutine.resume(coroutine.create(function() wait(0.79) if World.MedusaBossObj then World.MedusaBossObj.Firing = false end end))
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;wait()
&#9;&#9;&#9;end
&#9;&#9;&#9;wait(1.5)
&#9;&#9;&#9;World:InitiateDesertAssets()
&#9;&#9;&#9;World.BossActive = false &#9;
&#9;&#9;end))
&#9;else 
&#9;&#9;-- spawn da Sun
&#9;&#9;if sunImage then sunImage.Visible = false end 
&#9;&#9;gameCharObj.Anchored = true 
&#9;&#9;local sunBoss = Instance.new(&quot;ImageLabel&quot;)
&#9;&#9;sunBoss.Parent = gameFrame
&#9;&#9;sunBoss.Size = UDim2.new(0.25, 0, 0.3, 0)
&#9;&#9;sunBoss.Name = &quot;Teh Sun&quot;
&#9;&#9;sunBoss.ZIndex = 5.0
&#9;&#9;sunBoss.BackgroundTransparency = 1.0
&#9;&#9;sunBoss.Position = UDim2.new(0.75, 0, 0.45, 0)
&#9;&#9;sunBoss.Image = &quot;http://www.roblox.com/asset/?id=66360822&quot;&#9;&#9;
&#9;&#9;table.insert(World.SunBossObj, sunBoss)
&#9;&#9;World.SunBossObj.Velocity = Vector2.new(0, 0)
&#9;&#9;World.SunBossObj.Mass = sunBoss.Size.X.Scale * sunBoss.Size.Y.Scale * 50.0
&#9;&#9;World.SunBossObj.CR = 0.3&#9;
&#9;&#9;World.SunBossObj.CollidingObjects = {}
&#9;&#9;World.SunBossObj.ResolutionVectors = {}
&#9;&#9;World.SunBossObj.CollectiveResolutionVector = Vector2.new(0, 0)
&#9;&#9;World.SunBossObj.FreeFall = false 
&#9;&#9;World.SunBossObj.FreeFallCounter = 0.0
&#9;&#9;World.SunBossObj.Anchored = true  
&#9;&#9;World.SunBossObj.Moving = false -- For character Movement
&#9;&#9;World.SunBossObj.Forwards = false 
&#9;&#9;World.SunBossObj.Backwards = false 
&#9;&#9;World.SunBossObj.Jumping = false
&#9;&#9;World.SunBossObj.HitEnd = false 
&#9;&#9;World.SunBossObj.ForceField = false 
&#9;&#9;World.SunBossObj.Dead = false 
&#9;&#9;World.SunBossObj.Firing = false&#9;&#9;&#9;&#9;
&#9;&#9;World.SunBossObj.Health = 550&#9;
&#9;&#9;World.SunBossObj.Damage = 45
&#9;&#9;World.SunBossObj.Type = &quot;Boss&quot;&#9;&#9;
&#9;&#9;table.insert(physicsObjects, World.SunBossObj)
&#9;&#9;coroutine.resume(coroutine.create(function() &#9;&#9;&#9;
&#9;&#9;&#9;while World.SunBossObj and World.SunBossObj[1] do 
&#9;&#9;&#9;&#9;local numSteps = 5
&#9;&#9;&#9;&#9;if World.SunBossObj[1].Position.Y.Scale &gt; 0.55 then&#9;
&#9;&#9;&#9;&#9;&#9;while numSteps &gt; 0 and World.SunBossObj do 
&#9;&#9;&#9;&#9;&#9;&#9;World.SunBossObj[1].Position = UDim2.new(0.75, 0, World.SunBossObj[1].Position.Y.Scale - 0.03, 0)
&#9;&#9;&#9;&#9;&#9;&#9;numSteps = numSteps - 1
&#9;&#9;&#9;&#9;&#9;&#9;wait(0.5)
&#9;&#9;&#9;&#9;&#9;end 
&#9;&#9;&#9;&#9;else 
&#9;&#9;&#9;&#9;&#9;while numSteps &gt; 0 and World.SunBossObj do 
&#9;&#9;&#9;&#9;&#9;&#9;World.SunBossObj[1].Position = UDim2.new(0.75, 0, World.SunBossObj[1].Position.Y.Scale + 0.03, 0)
&#9;&#9;&#9;&#9;&#9;&#9;numSteps = numSteps - 1
&#9;&#9;&#9;&#9;&#9;&#9;wait(0.5)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end 
&#9;&#9;&#9;&#9;wait()
&#9;&#9;&#9;end 
&#9;&#9;end)) 
&#9;&#9;wait(1.5) 
&#9;&#9;gameCharObj.Anchored = false
&#9;&#9;coroutine.resume(coroutine.create(function() 
&#9;&#9;&#9;while World.SunBossObj and World.SunBossObj.Health &gt; 0 do &#9;&#9;
&#9;&#9;&#9;&#9;if World.SunBossObj.Health &lt; 425 and World.SunBossObj.Firing == false then 
&#9;&#9;&#9;&#9;&#9;print(&quot;Firing my laser&quot;)
&#9;&#9;&#9;&#9;&#9;World.SunBossObj.Firing = true 
&#9;&#9;&#9;&#9;&#9;-- Make him angry &#9;
&#9;&#9;&#9;&#9;&#9;World.SunBossObj[1].Image = &quot;http://www.roblox.com/asset/?id=66361175&quot;&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;local projectile = Instance.new(&quot;ImageLabel&quot;)
&#9;&#9;&#9;&#9;&#9;projectile.Size = UDim2.new(0.03, 0, 0.03, 0)
&#9;&#9;&#9;&#9;&#9;projectile.Image = &quot;http://www.roblox.com/asset/?id=&quot; .. 66361308
&#9;&#9;&#9;&#9;&#9;projectile.Name = &quot;Attack&quot;
&#9;&#9;&#9;&#9;&#9;projectile.Parent = gameFrame &#9;&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;projectile.BackgroundTransparency = 1.0
&#9;&#9;&#9;&#9;&#9;projectile.ZIndex = 5.0&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;projectile.Position = World.SunBossObj[1].Position + UDim2.new(World.SunBossObj.Velocity.X, 0, World.SunBossObj.Velocity.Y, 0)&#9;
&#9;&#9;&#9;&#9;&#9;local direction = Vector2.new(gameCharObj[1].Position.X.Scale - projectile.Position.X.Scale, (gameCharObj[1].Position.Y.Scale - projectile.Position.Y.Scale)).unit &#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;projectile.BackgroundTransparency = 1.0 
&#9;&#9;&#9;&#9;&#9;table.insert(enemyProjectiles, projectile)&#9;
&#9;&#9;&#9;&#9;&#9;coroutine.resume(coroutine.create(function() 
&#9;&#9;&#9;&#9;&#9;&#9;shootCharacter(direction, projectile, World.SunBossObj, World.SunBossObj.Damage) 
&#9;&#9;&#9;&#9;&#9;end))
&#9;&#9;&#9;&#9;&#9;coroutine.resume(coroutine.create(function()
&#9;&#9;&#9;&#9;&#9;&#9;wait(0.3)
&#9;&#9;&#9;&#9;&#9;&#9;if World.SunBossObj then World.SunBossObj.Firing = false end 
&#9;&#9;&#9;&#9;&#9;end)) 
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;wait()&#9;&#9;&#9;&#9;
&#9;&#9;&#9;end 
&#9;&#9;&#9;World:EndScreen(&quot;Win&quot;)
&#9;&#9;end))
&#9;end&#9;
end

function fireBeam(direction, projectile, damage)
&#9;if World.SunBossObj then 
&#9;&#9;if direction == &quot;Horizontal&quot; then 
&#9;&#9;&#9;projectile.Position = World.SunBossObj[1].Position
&#9;&#9;&#9;while projectile and projectile.Size.X.Scale &lt; 0.75 do 
&#9;&#9;&#9;&#9;print(&quot;Resizing laser&quot;)
&#9;&#9;&#9;&#9;projectile.Size = UDim2.new(projectile.Size.X.Scale * 2, 0, 0.04, 0) 
&#9;&#9;&#9;&#9;projectile.Position = UDm2.new(projectile.Position.X.Scale - projectile.Size.X.Scale, 0, projectile.Position.Y.Scale, 0)
&#9;&#9;&#9;&#9;if projectile and gameCharObj then 
&#9;&#9;&#9;&#9;&#9;print(1)
&#9;&#9;&#9;&#9;&#9;local collision = checkForCollision(projectile, gameCharObj[1], Vector2.new(0, 0)) 
&#9;&#9;&#9;&#9;&#9;if collision then 
&#9;&#9;&#9;&#9;&#9;&#9;print(2)
&#9;&#9;&#9;&#9;&#9;&#9;if projectile and gameCharObj and gameCharObj.ForceField == false then &#9;&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;gameCharObj.Health = gameCharObj.Health - damage 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;projectile:Remove()
&#9;&#9;&#9;&#9;&#9;&#9;&#9;projectile = nil 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if gameCharObj.Health &lt; 0.0 then 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;gameCharObj.Dead = true 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;wait() 
&#9;&#9;&#9;end 
&#9;&#9;else 
&#9;&#9;&#9;projectile.Position = UDim2.new(gameCharObj[1].Position.X.Scale, 0, 0, 0)
&#9;&#9;&#9;while projectile and projectile.Size.X.Scale &lt; 0.80 do 
&#9;&#9;&#9;&#9;projectile.Size = UDim2.new(0.04, 0, projectile.Size.X.Scale * 2, 0) 
&#9;&#9;&#9;&#9;projectile.Position = UDm2.new(projectile.Position.X.Scale, 0, projectile.Position.Y.Scale - projectile.Size.Y.Scale, 0)
&#9;&#9;&#9;&#9;if projectile and gameCharObj then 
&#9;&#9;&#9;&#9;&#9;local collision = checkForCollision(projectile, gameCharObj[1], Vector2.new(0, 0)) 
&#9;&#9;&#9;&#9;&#9;if collision then 
&#9;&#9;&#9;&#9;&#9;&#9;if projectile and gameCharObj and gameCharObj.ForceField == false then &#9;&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;gameCharObj.Health = gameCharObj.Health - damage 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;projectile:Remove()
&#9;&#9;&#9;&#9;&#9;&#9;&#9;projectile = nil 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if gameCharObj.Health &lt; 0.0 then 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;gameCharObj.Dead = true 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;wait() 
&#9;&#9;&#9;end 
&#9;&#9;end 
&#9;&#9;if projectile then 
&#9;&#9;&#9;projectile:Remove()
&#9;&#9;&#9;projectile = nil 
&#9;&#9;end 
&#9;end 
end 

function World:EndScreen(message)
&#9;print(&quot;GAME OGRE&quot;)
&#9;if gameCharObj then  
&#9;&#9;gameCharObj.Anchored = true
&#9;&#9;gameCharObj[1].Visible = false 
&#9;end 
&#9;local img = Instance.new(&quot;ImageLabel&quot;)
&#9;img.BackgroundTransparency = 1.0
&#9;img.Size = UDim2.new(0.4, 0, 0.25, 0)
&#9;img.Position = UDim2.new(0.3, 0, 0.375, 0)
&#9;img.Parent = gameFrame 
&#9;img.ZIndex = 10.0
&#9;if message == &quot;loser&quot; then &#9;&#9;
&#9;&#9;img.Image = &quot;http://www.roblox.com/asset/?id=66365830&quot;
&#9;else 
&#9;&#9;img.Image = &quot;http://www.roblox.com/asset/?id=66365883&quot;
&#9;end 
&#9;wait(4.0) -- Need to add the YOU LOSE 
&#9;if gameScreen then gameScreen:Remove() end 
end

function World:SpawnEnemy()
&#9;tick()
&#9;if gameCharObj and World.DistanceTravelled &gt; 1.0 and not World.BossActive and World.SpawnAllowed then&#9;&#9;
&#9;&#9;if math.random() &lt; 0.05 and enemies.NumEnemies &lt; 5 and World.LevelName == &quot;Desert&quot; then
&#9;&#9;&#9;World.SpawnAllowed = false 
&#9;&#9;&#9;print(&quot;Spawning Melee Enemy&quot;)
&#9;&#9;&#9;-- Spawn Melee Enemy 
&#9;&#9;&#9;local meleeEnemyObj = {}
&#9;&#9;&#9;local meleeEnemy = Instance.new(&quot;ImageLabel&quot;)
&#9;&#9;&#9;meleeEnemy.Parent = gameFrame 
&#9;&#9;&#9;meleeEnemy.Name = &quot;MeleeEnemy&quot;
&#9;&#9;&#9;meleeEnemy.ZIndex = 5.0
&#9;&#9;&#9;meleeEnemy.BackgroundTransparency = 1.0
&#9;&#9;&#9;meleeEnemy.Position = UDim2.new(0.9, 0, 0.75, 0)
&#9;&#9;&#9;meleeEnemy.Image = &quot;http://www.roblox.com/asset/?id=66197277&quot;
&#9;&#9;&#9;meleeEnemy.Size = UDim2.new(0.070, 0, 0.0931, 0)
&#9;&#9;&#9;table.insert(meleeEnemyObj, meleeEnemy)
&#9;&#9;
&#9;&#9;&#9;meleeEnemyObj.Velocity = Vector2.new(0, 0)
&#9;&#9;&#9;meleeEnemyObj.Type = &quot;Melee&quot; 
&#9;&#9;&#9;meleeEnemyObj.Mass = meleeEnemy.Size.X.Scale * meleeEnemy.Size.Y.Scale * 50.0
&#9;&#9;&#9;meleeEnemyObj.CR = 0.2
&#9;&#9;&#9;meleeEnemyObj.Jumping = false 
&#9;&#9;&#9;meleeEnemyObj.Anchored = false 
&#9;&#9;&#9;meleeEnemyObj.Moving = false 
&#9;&#9;&#9;meleeEnemyObj.Forwards = false 
&#9;&#9;&#9;meleeEnemyObj.Backwards = false 
&#9;&#9;&#9;meleeEnemyObj.CollidingObjects = {}
&#9;&#9;&#9;meleeEnemyObj.ResolutionVectors = {}
&#9;&#9;&#9;meleeEnemyObj.CollectiveResolutionVector = {}
&#9;&#9;&#9;meleeEnemyObj.Sprites = meleeEnemySprites 
&#9;&#9;&#9;meleeEnemyObj.Health = 40
&#9;&#9;&#9;meleeEnemyObj.Damage = 15
&#9;&#9;&#9;meleeEnemyObj.ClassName = &quot;Bot&quot;
&#9;&#9;&#9;table.insert(physicsObjects, meleeEnemyObj)
&#9;&#9;&#9;meleeEnemyObj.PositionInArray = #physicsObjects 
&#9;&#9;&#9;enemies[meleeEnemyObj] = meleeEnemyObj
&#9;&#9;&#9;enemies.NumEnemies = enemies.NumEnemies + 1
&#9;&#9;&#9;coroutine.resume(coroutine.create(function() animateSprites(meleeEnemyObj) end)) 
&#9;&#9;end 
&#9;&#9;
&#9;&#9;if math.random() &lt; 1.0 and enemies.NumEnemies &lt; 3 then 
&#9;&#9;&#9;-- Spawn ranged enemy 
&#9;&#9;&#9;World.SpawnAllowed = false 
&#9;&#9;&#9;local rangedEnemyObj = {}
&#9;&#9;&#9;local rangedEnemy = Instance.new(&quot;ImageLabel&quot;)
&#9;&#9;&#9;rangedEnemy.Parent = gameFrame 
&#9;&#9;&#9;rangedEnemy.Name = &quot;rangedEnemy&quot;
&#9;&#9;&#9;rangedEnemy.ZIndex = 5.0
&#9;&#9;&#9;rangedEnemy.BackgroundTransparency = 1.0
&#9;&#9;&#9;rangedEnemy.BorderSizePixel = 0.0
&#9;&#9;&#9;rangedEnemy.Position = UDim2.new(0.9, 0, 0.75, 0)
&#9;&#9;&#9;rangedEnemy.Image = &quot;http://www.roblox.com/asset/?id=66189603&quot; 
&#9;&#9;&#9;rangedEnemy.Size = UDim2.new(0.070, 0, 0.0931, 0)
&#9;&#9;&#9;table.insert(rangedEnemyObj, rangedEnemy)

&#9;&#9;&#9;enemies.NumEnemies = enemies.NumEnemies + 1
&#9;&#9;
&#9;&#9;&#9;rangedEnemyObj.Velocity = Vector2.new(0, 0)
&#9;&#9;&#9;rangedEnemyObj.Type = &quot;Ranged&quot; 
&#9;&#9;&#9;rangedEnemyObj.Mass = rangedEnemy.Size.X.Scale * rangedEnemy.Size.Y.Scale * 50.0
&#9;&#9;&#9;rangedEnemyObj.CR = 0.2
&#9;&#9;&#9;rangedEnemyObj.Jumping = false 
&#9;&#9;&#9;rangedEnemyObj.Anchored = false 
&#9;&#9;&#9;rangedEnemyObj.Moving = false 
&#9;&#9;&#9;rangedEnemyObj.Forwards = false 
&#9;&#9;&#9;rangedEnemyObj.Backwards = false &#9;
&#9;&#9;&#9;rangedEnemyObj.CanFire = true
&#9;&#9;&#9;rangedEnemyObj.CollidingObjects = {}
&#9;&#9;&#9;rangedEnemyObj.ResolutionVectors = {}
&#9;&#9;&#9;rangedEnemyObj.CollectiveResolutionVector = {}
&#9;&#9;&#9;rangedEnemyObj.Sprites = rangedEnemySprites 
&#9;&#9;&#9;rangedEnemyObj.Health = 50
&#9;&#9;&#9;rangedEnemyObj.Damage = 17
&#9;&#9;&#9;rangedEnemyObj.ClassName = &quot;Bot&quot;
&#9;&#9;&#9;table.insert(physicsObjects, rangedEnemyObj)
&#9;&#9;&#9;rangedEnemyObj.PositionInArray = #physicsObjects
&#9;&#9;&#9;enemies[rangedEnemyObj] = rangedEnemyObj
&#9;&#9;&#9;coroutine.resume(coroutine.create(function() animateSprites(rangedEnemyObj) end))&#9;&#9;&#9;
&#9;&#9;&#9;coroutine.resume(coroutine.create(function() wait(enemies.NumEnemies * 3.0) World.SpawnAllowed = true end))
&#9;&#9;end
&#9;end
end

function createGameCharacter()&#9;
&#9;print(&quot;Character created&quot;)
&#9;-- Spawn Character 
&#9;if not gameChar then
&#9;&#9;gameCharObj = {}
&#9;&#9;gameChar = &#9;Instance.new(&quot;ImageLabel&quot;)
&#9;&#9;gameChar.Parent = gameFrame
&#9;&#9;gameChar.Size = UDim2.new(0.027, 0, 0.056, 0)
&#9;&#9;gameChar.Name = &quot;Hero&quot;
&#9;&#9;gameChar.ZIndex = 5.0
&#9;&#9;gameChar.BackgroundTransparency = 1.0
&#9;&#9;gameChar.Position = UDim2.new(0.0, 0, 0.7, 0)
&#9;&#9;gameChar.Image = &quot;http://www.roblox.com/asset/?id=65912145&quot;&#9;&#9;
&#9;&#9;table.insert(gameCharObj, gameChar)
&#9;&#9;gameCharObj.Velocity = Vector2.new(0, 0)
&#9;&#9;gameCharObj.Mass = gameChar.Size.X.Scale * gameChar.Size.Y.Scale * 50.0
&#9;&#9;gameCharObj.CR = 0.3&#9;
&#9;&#9;gameCharObj.CollidingObjects = {}
&#9;&#9;gameCharObj.ResolutionVectors = {}
&#9;&#9;gameCharObj.CollectiveResolutionVector = Vector2.new(0, 0)
&#9;&#9;gameCharObj.FreeFall = false 
&#9;&#9;gameCharObj.FreeFallCounter = 0.0
&#9;&#9;gameCharObj.Anchored = false
&#9;&#9;gameCharObj.Moving = false -- For character Movement
&#9;&#9;gameCharObj.Forwards = false 
&#9;&#9;gameCharObj.Backwards = false 
&#9;&#9;gameCharObj.Jumping = false
&#9;&#9;gameCharObj.HitEnd = false 
&#9;&#9;gameCharObj.ForceField = false 
&#9;&#9;gameCharObj.Dead = false 
&#9;&#9;gameCharObj.Firing = false
&#9;&#9;gameCharObj.PrevVelocity = Vector2.new(0, 0)
&#9;&#9;gameCharObj.SpawnPos = Vector2.new(0.0, 0.7)&#9;
&#9;&#9;gameCharObj.Health = 102

&#9;&#9;gameCharObj.Healthbar = Instance.new(&quot;ImageLabel&quot;)
&#9;&#9;gameCharObj.Healthbar.Parent = gameFrame 
&#9;&#9;gameCharObj.Healthbar.Size = UDim2.new(0.15, 0, 0.025, 0)
&#9;&#9;gameCharObj.Healthbar.Image = &quot;http://www.roblox.com/asset/?id=&quot; .. gameCharHealthbarAssets[6] 
&#9;&#9;gameCharObj.Healthbar.ZIndex = 5.0 
&#9;&#9;gameCharObj.Healthbar.Position = UDim2.new(0.03, 0, 0.010, 0)
&#9;&#9;gameCharObj.Healthbar.BackgroundTransparency = 1.0&#9;
&#9;&#9;gameCharObj.Healthbar.Name = &quot;Healthbar&quot;
&#9;
&#9;&#9;gameCharObj.LivesText = Instance.new(&quot;TextLabel&quot;)
&#9;&#9;gameCharObj.LivesText.Parent = gameFrame 
&#9;&#9;gameCharObj.LivesText.Size = UDim2.new(0.15, 0, 0.025, 0)
&#9;&#9;gameCharObj.LivesText.ZIndex = 5.0 
&#9;&#9;gameCharObj.LivesText.TextColor3 = Color3.new(204/255, 0, 204/255)
&#9;&#9;gameCharObj.LivesText.Position = UDim2.new(-0.03, 0, 0.039, 0)
&#9;&#9;gameCharObj.LivesText.BackgroundTransparency = 1.0&#9;
&#9;&#9;gameCharObj.LivesText.Name = &quot;Lives&quot;
&#9;&#9;gameCharObj.LivesText.Text = &quot;x&quot; .. World.LivesRemaining

&#9;&#9;gameCharObj.Icon = Instance.new(&quot;ImageLabel&quot;)
&#9;&#9;gameCharObj.Icon.Parent = gameFrame 
&#9;&#9;gameCharObj.Icon.Size = UDim2.new(0.027, 0, 0.056, 0)
&#9;&#9;gameCharObj.Icon.Position = UDim2.new(0, 0, 0.010, 0)
&#9;&#9;gameCharObj.Icon.ZIndex = 5.0 
&#9;&#9;gameCharObj.Icon.BackgroundTransparency = 1.0&#9;&#9;
&#9;&#9;gameCharObj.Icon.Image= &quot;http://www.roblox.com/asset/?id=65912145&quot;&#9;&#9;
&#9;&#9;gameCharObj.Icon.Name = &quot;Character Icon&quot; 
&#9;&#9;
&#9;&#9;table.insert(physicsObjects, gameCharObj)
&#9;&#9;gameCharObj.PositionInArray = #physicsObjects
&#9;&#9;coroutine.resume(coroutine.create(characterAnimation))
&#9;end
end

function World:InitiateWaterAssets()
&#9;print(&quot;Initiating Water Level&quot;)
&#9;World.DistanceTravelled = 0
&#9;if gameCharObj then 
&#9;&#9;gameCharObj.Anchored = true 
&#9;&#9;gameCharObj[1].Visible = false 
&#9;end 

&#9;wait(1.0)

&#9;World.LevelName = &quot;Water&quot; 

&#9;sunImage.Image = &quot;http://www.roblox.com/asset/?id=66225675&quot; -- Water level Sun 
&#9;sunImage.Size = UDim2.new(0.167, 0, 0.213, 0)
&#9;skyImage.Image = &quot;http://www.roblox.com/asset/?id=66225731&quot; -- Water level Sky 

&#9;for i = 1, #physicsObjects do 
&#9;&#9;if physicsObjects[i] == gameFloorObj or physicsObjects[i] == gameFloorObj2  then 
&#9;&#9;&#9;table.remove(physicsObjects, i)
&#9;&#9;end
&#9;end

&#9;gameFloorObj[1].Visible = false
&#9;gameFloorObj2[1].Visible = false 

&#9;gameBackground.Visible = false 
&#9;gameBackground2.Visible = false 

&#9;waterLevelRocksClose = Instance.new(&quot;ImageLabel&quot;) 
&#9;waterLevelRocksClose.Image = &quot;http://www.roblox.com/asset/?id=66225756&quot;
&#9;waterLevelRocksClose.Size = UDim2.new(1, 0, 0.1, 0)
&#9;waterLevelRocksClose.Position = UDim2.new(0, 0, 0.9, 0)
&#9;waterLevelRocksClose.ZIndex = 5.0
&#9;waterLevelRocksClose.BackgroundTransparency = 1.0
&#9;waterLevelRocksClose.Name = &quot;Rocks Close&quot;
&#9;waterLevelRocksClose.Parent = gameFrame

&#9;waterLevelRocksClose2 = Instance.new(&quot;ImageLabel&quot;) 
&#9;waterLevelRocksClose2.Image = &quot;http://www.roblox.com/asset/?id=66225756&quot;
&#9;waterLevelRocksClose2.Size = UDim2.new(1, 0, 0.1, 0)
&#9;waterLevelRocksClose2.Position = UDim2.new(1, 0, 0.9, 0)
&#9;waterLevelRocksClose2.ZIndex = 5.0
&#9;waterLevelRocksClose2.BackgroundTransparency = 1.0
&#9;waterLevelRocksClose2.Name = &quot;Rocks Close&quot;
&#9;waterLevelRocksClose2.Parent = gameFrame

&#9;waterLevelRocksMid = Instance.new(&quot;ImageLabel&quot;) 
&#9;waterLevelRocksMid.Image = &quot;http://www.roblox.com/asset/?id=66225756&quot;
&#9;waterLevelRocksMid.Size = UDim2.new(1, 0, 0.1, 0)
&#9;waterLevelRocksMid.Position = UDim2.new(0, 0, 0.9, 0)
&#9;waterLevelRocksMid.ZIndex = 4.0
&#9;waterLevelRocksMid.BackgroundTransparency = 1.0
&#9;waterLevelRocksMid.Name = &quot;Rocks Close&quot;
&#9;waterLevelRocksMid.Parent = gameFrame

&#9;waterLevelRocksMid2 = Instance.new(&quot;ImageLabel&quot;) 
&#9;waterLevelRocksMid2.Image = &quot;http://www.roblox.com/asset/?id=66225756&quot;
&#9;waterLevelRocksMid2.Size = UDim2.new(1, 0, 0.1, 0)
&#9;waterLevelRocksMid2.Position = UDim2.new(1, 0, 0.9, 0)
&#9;waterLevelRocksMid2.ZIndex = 4.0
&#9;waterLevelRocksMid2.BackgroundTransparency = 1.0
&#9;waterLevelRocksMid2.Name = &quot;Rocks Close&quot;
&#9;waterLevelRocksMid2.Parent = gameFrame

&#9;waterLevelRocksFar = Instance.new(&quot;ImageLabel&quot;) 
&#9;waterLevelRocksFar.Image = &quot;http://www.roblox.com/asset/?id=66225756&quot;
&#9;waterLevelRocksFar.Size = UDim2.new(1, 0, 0.1, 0)
&#9;waterLevelRocksFar.Position = UDim2.new(0, 0, 0.9, 0)
&#9;waterLevelRocksFar.ZIndex = 3.0
&#9;waterLevelRocksFar.BackgroundTransparency = 1.0
&#9;waterLevelRocksFar.Name = &quot;Rocks Close&quot;
&#9;waterLevelRocksFar.Parent = gameFrame

&#9;waterLevelRocksFar2 = Instance.new(&quot;ImageLabel&quot;) 
&#9;waterLevelRocksFar2.Image = &quot;http://www.roblox.com/asset/?id=66225756&quot;
&#9;waterLevelRocksFar2.Size = UDim2.new(1, 0, 0.1, 0)
&#9;waterLevelRocksFar2.Position = UDim2.new(1, 0, 0.9, 0)
&#9;waterLevelRocksFar2.ZIndex = 5.0
&#9;waterLevelRocksFar2.BackgroundTransparency = 1.0
&#9;waterLevelRocksFar2.Name = &quot;Rocks Close&quot;
&#9;waterLevelRocksFar2.Parent = gameFrame

&#9;for i = 0, 3 do 
&#9;&#9;local platformObj = {}
&#9;&#9;platform = Instance.new(&quot;ImageLabel&quot;) 
&#9;&#9;platform.Name = &quot;SpawnPlatform&quot; 
&#9;&#9;platform.Image = &quot;http://www.roblox.com/asset/?id=58344744&quot; 
&#9;&#9;platform.Size = UDim2.new(0.15, 0, 0.025, 0)      
&#9;&#9;platform.Position = UDim2.new(i * 0.28, 0, 0.80, 0) 
&#9;&#9;platform.Parent = gameFrame &#9;
&#9;&#9;table.insert(platformObj, platform)
&#9;&#9;platformObj.Anchored = true &#9;
&#9;&#9;platformObj.Mass = 1.0
&#9;&#9;platformObj.Velocity = Vector2.new(0, 0)
&#9;&#9;table.insert(physicsObjects, platformObj) 
&#9;&#9;table.insert(World.Platforms, platformObj)
&#9;end

&#9;if gameCharObj and gameCharObj[1] then 
&#9;&#9;local minXPlatform = 2.0&#9;&#9;
&#9;&#9;for i = 1, #World.Platforms do 
&#9;&#9;&#9;if World.Platforms[i][1].Position.X.Scale &lt;  minXPlatform then 
&#9;&#9;&#9;&#9;minXPlatform = World.Platforms[i][1].Position.X.Scale  
&#9;&#9;&#9;end 
&#9;&#9;end
&#9;&#9;gameCharObj[1].Position = UDim2.new(minXPlatform, 0, 0.70, 0) 
&#9;&#9;gameCharObj.Anchored = false 
&#9;&#9;gameCharObj[1].Visible = true 
&#9;end
end

function World:InitiateDesertAssets()
&#9;if gameCharObj then 
&#9;&#9;gameCharObj.Anchored = true 
&#9;&#9;gameCharObj[1].Visible = false 
&#9;end 
&#9;for i = 1, #World.Platforms do 
&#9;&#9;for j = 1, #physicsObjects do 
&#9;&#9;&#9;if physicsObjects[j] == World.Platforms[i] then
&#9;&#9;&#9;&#9;table.remove(physicsObjects, j)
&#9;&#9;&#9;end 
&#9;&#9;end 
&#9;&#9;if World.Platforms[i] and World.Platforms[i][1] then World.Platforms[i][1]:Remove() end
&#9;&#9;table.remove(World.Platforms, i)
&#9;end 
&#9;print(&quot;Initiating Desert Level&quot;)
&#9;World.LevelName = &quot;Desert&quot;
&#9;if waterLevelRocksClose then waterLevelRocksClose:Remove() end 
&#9;if waterLevelRocksClose2 then waterLevelRocksClose2:Remove() end 
&#9;if waterLevelRocksMid then waterLevelRocksMid:Remove() end 
&#9;if waterLevelRocksMid2 then waterLevelRocksMid2:Remove() end 
&#9;if waterLevelRocksFar then waterLevelRocksFar:Remove() end 
&#9;if waterLevelRocksFar2 then waterLevelRocksFar2:Remove() end 
&#9;wait(3.0)
&#9;sunImage.Image = &quot;http://www.roblox.com/asset/?id=66356580&quot; -- Sun 
&#9;sunImage.Size = UDim2.new(0.33, 0, 0.45, 0)
&#9;skyImage.Image = &quot;http://www.roblox.com/asset/?id=66226104&quot; -- Sky 

&#9;gameFloorObj[1].Image = &quot;http://www.roblox.com/asset/?id=66226069&quot; 
&#9;gameFloorObj[1].Visible = true
&#9;gameFloorObj[1].Position = UDim2.new(0, 0, 0.8, 0)
&#9;gameFloorObj[1].ZIndex = 5.0
&#9;gameFloorObj[1].Name = &quot;Floor&quot;
&#9;gameFloorObj.Anchored = true
&#9;table.insert(physicsObjects, gameFloorObj)
&#9;gameFloorObj2[1].Image = &quot;http://www.roblox.com/asset/?id=66226069&quot;
&#9;gameFloorObj2[1].Visible = true 
&#9;gameFloorObj2[1].ZIndex = 5.0
&#9;gameFloorObj2[1].Position = UDim2.new(1, 0, 0.8, 0)
&#9;gameFloorObj[1].Name = &quot;Floor2&quot;&#9;
&#9;gameFloorObj2.Anchored = true
&#9;table.insert(physicsObjects, gameFloorObj2)

&#9;gameBackground.Image = &quot;http://www.roblox.com/asset/?id=66226129&quot;
&#9;gameBackground.Size = UDim2.new(1, 0, 0.3, 0)
&#9;gameBackground.Position = UDim2.new(0, 0, 0.5, 0)
&#9;gameBackground.ZIndex = 2.0
&#9;gameBackground.Visible = true 
&#9;gameBackground2.Image = &quot;http://www.roblox.com/asset/?id=66226129&quot;
&#9;gameBackground.Visible = true 
&#9;gameBackground2.Size = UDim2.new(1, 0, 0.3, 0)
&#9;gameBackground2.Position = UDim2.new(1, 0, 0.5, 0)
&#9;gameBackground2.ZIndex = 2.0
&#9;
&#9;gameBackground3 = Instance.new(&quot;ImageLabel&quot;)
&#9;gameBackground3.Parent = gameFrame
&#9;gameBackground3.Position = UDim2.new(0, 0, 0.6, 0)
&#9;gameBackground3.Size = UDim2.new(1, 0, 0.3, 0)
&#9;gameBackground3.Name = &quot;Background&quot;
&#9;gameBackground3.Image = &quot;http://www.roblox.com/asset/?id=66226112&quot;
&#9;gameBackground3.BorderSizePixel = 0.0
&#9;gameBackground3.ZIndex = 3.0
&#9;gameBackground3.Visible = true
&#9;gameBackground3.BackgroundTransparency = 1.0
&#9;
&#9;gameBackground4 = Instance.new(&quot;ImageLabel&quot;)
&#9;gameBackground4.Parent = gameFrame
&#9;gameBackground4.Position = UDim2.new(1, 0, 0.6, 0)
&#9;gameBackground4.Size = UDim2.new(1, 0, 0.3, 0)
&#9;gameBackground4.Name = &quot;Background&quot;
&#9;gameBackground4.Image = &quot;http://www.roblox.com/asset/?id=66226112&quot;
&#9;gameBackground4.BorderSizePixel = 0.0
&#9;gameBackground4.ZIndex = 3.0
&#9;gameBackground4.BackgroundTransparency = 1.0
&#9;gameBackground4.Visible = true
&#9;
&#9;wait(1.0)
&#9;
&#9;gameCharObj[1].Position = UDim2.new(0.1, 0, 0.7, 0)
&#9;gameCharObj.Anchored = false
&#9;gameCharObj[1].Visible = true 

&#9;World.BossActive = false 
end

function World:CheckEvents()
&#9;if gameCharObj then 
&#9;&#9;if gameCharObj[1] and gameCharObj[1].Position.Y.Scale &gt; 1.0 then 
&#9;&#9;&#9;print(&quot;Resetting character&quot;)
&#9;&#9;&#9;gameCharObj.Health = 0
&#9;&#9;end 
&#9;&#9;gameCharObj.LivesText.Text = &quot;x&quot; .. World.LivesRemaining
&#9;&#9;if gameCharObj.Health/17 &gt; 0 then 
&#9;&#9;&#9;local ratio = math.floor(gameCharObj.Health/17 + 0.5) 
&#9;&#9;&#9;if ratio == 0 then ratio = 1 end 
&#9;&#9;&#9;gameCharObj.Healthbar.Image = &quot;http://www.roblox.com/asset/?id=&quot; .. gameCharHealthbarAssets[ratio] 
&#9;&#9;&#9;gameCharObj.Healthbar.Size = UDim2.new(0.025 * ratio, 0, 0.025, 0)&#9;&#9;&#9;
&#9;&#9;end
&#9;&#9;if gameCharObj.Health &lt;= 0 then 
&#9;&#9;&#9;if World.LivesRemaining &gt; 0 then &#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;-- do respawn stuff here &#9;
&#9;&#9;&#9;&#9;gameCharObj[1].Visible = false 
&#9;&#9;&#9;&#9;gameCharObj.Anchored = true
&#9;&#9;&#9;&#9;gameCharObj.ForceField = true
&#9;&#9;&#9;&#9;gameCharObj.Health = 102 &#9;&#9;
&#9;&#9;
&#9;&#9;&#9;&#9;if World.LevelName == &quot;Water&quot; then 
&#9;&#9;&#9;&#9;&#9;local minX = 2.0 
&#9;&#9;&#9;&#9;&#9;for i = 1, #World.Platforms do 
&#9;&#9;&#9;&#9;&#9;&#9;if World.Platforms[i] and World.Platforms[i][1] and World.Platforms[i][1].Position.X.Scale &gt; 0 and World.Platforms[i][1].Position.X.Scale &lt; minX then 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;minX = World.Platforms[i][1].Position.X.Scale
&#9;&#9;&#9;&#9;&#9;&#9;end 
&#9;&#9;&#9;&#9;&#9;end 
&#9;&#9;&#9;&#9;&#9;gameCharObj[1].Position = UDim2.new(minX + 0.05, 0, 0.65, 0)
&#9;&#9;&#9;&#9;else 
&#9;&#9;&#9;&#9;&#9;gameCharObj[1].Position = UDim2.new(0.15, 0, 0.65, 0)
&#9;&#9;&#9;&#9;end 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;coroutine.resume(coroutine.create(function() 
&#9;&#9;&#9;&#9;&#9;wait(2.0)
&#9;&#9;&#9;&#9;&#9;gameCharObj.Anchored = false
&#9;&#9;&#9;&#9;&#9;local duration = 2.25 
&#9;&#9;&#9;&#9;&#9;while duration &gt; 0 do 
&#9;&#9;&#9;&#9;&#9;&#9;gameCharObj[1].Visible = not gameCharObj[1].Visible 
&#9;&#9;&#9;&#9;&#9;&#9;wait(0.25)&#9;
&#9;&#9;&#9;&#9;&#9;&#9;duration = duration - wait(0.5)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;gameCharObj[1].Visible = true 
&#9;&#9;&#9;&#9;&#9;World.LivesRemaining = World.LivesRemaining - 1
&#9;&#9;&#9;&#9;&#9;gameCharObj.LivesText.Text = &quot;x&quot; .. World.LivesRemaining
&#9;&#9;&#9;&#9;&#9;gameCharObj.ForceField = false 
&#9;&#9;&#9;&#9;end))
&#9;&#9;&#9;else 
&#9;&#9;&#9;&#9;World:EndScreen(&quot;loser&quot;)
&#9;&#9;&#9;end
&#9;&#9;end 
&#9;end
end

function World:InitiateGameAssets()&#9;
&#9;gameBackground = Instance.new(&quot;ImageLabel&quot;)
&#9;gameBackground.Parent = gameFrame
&#9;gameBackground.Position = UDim2.new(0, 0, 0, 0)
&#9;gameBackground.Size = UDim2.new(1, 0, 1, 0)
&#9;gameBackground.Name = &quot;Background&quot;
&#9;gameBackground.Image = &quot;http://www.roblox.com/asset/?id=65908682&quot;
&#9;gameBackground.BorderSizePixel = 0.0
&#9;gameBackground.ZIndex = 2.0
&#9;gameBackground.BackgroundTransparency = 1.0

&#9;gameBackground2 = Instance.new(&quot;ImageLabel&quot;)
&#9;gameBackground2.Parent = gameFrame
&#9;gameBackground2.Position = UDim2.new(1, 0, 0, 0)
&#9;gameBackground2.Size = UDim2.new(1, 0, 1, 0)
&#9;gameBackground2.Name = &quot;Background2&quot;
&#9;gameBackground2.Image = &quot;http://www.roblox.com/asset/?id=65908682&quot;
&#9;gameBackground2.BorderSizePixel = 0.0
&#9;gameBackground2.ZIndex = 2.0
&#9;gameBackground2.BackgroundTransparency = 1.0

&#9;skyImage = Instance.new(&quot;ImageLabel&quot;)
&#9;skyImage.Parent = gameFrame
&#9;skyImage.Position = UDim2.new(0, 0, 0, 0)
&#9;skyImage.Size = UDim2.new(1, 0, 1, 0)
&#9;skyImage.Name = &quot;Sky&quot;
&#9;skyImage.Image = &quot;http://www.roblox.com/asset/?id=65909301&quot;
&#9;skyImage.BorderSizePixel = 0.0
&#9;skyImage.ZIndex = 1.0
&#9;skyImage.BackgroundTransparency = 1.0

&#9;sunImage = Instance.new(&quot;ImageLabel&quot;)
&#9;sunImage.Parent = gameFrame
&#9;sunImage.Position = UDim2.new(0.12, 0, 0.12, 0)
&#9;sunImage.Size = UDim2.new(0.12, 0, 0.12, 0)
&#9;sunImage.Name = &quot;Sun&quot;
&#9;sunImage.Image = &quot;http://www.roblox.com/asset/?id=65910153&quot;
&#9;sunImage.BorderSizePixel = 0.0
&#9;sunImage.ZIndex = 5.0
&#9;sunImage.BackgroundTransparency = 1.0

&#9;QuadTree.RootNode = QuadTree:CreateTree(gameBackground)
&#9;QuadTree:PrintTree(QuadTree.RootNode) 

&#9;-- Game Floor&#9;
&#9;gameFloor = Instance.new(&quot;ImageLabel&quot;)
&#9;gameFloor.Name = &quot;Floor&quot;
&#9;gameFloor.Parent = gameFrame
&#9;gameFloor.Position = UDim2.new(0, 0, 0.8, 0)
&#9;gameFloor.Size = UDim2.new(1, 0, 0.2, 0)
&#9;gameFloor.Image = &quot;http://www.roblox.com/asset/?id=65911902&quot;
&#9;gameFloor.BackgroundTransparency = 1.0
&#9;gameFloor.ZIndex = 3.0
&#9;table.insert(gameFloorObj, gameFloor)
&#9;gameFloorObj.Velocity = Vector2.new(0, 0)
&#9;gameFloorObj.Anchored = true 
&#9;gameFloorObj.FreeFall = false 
&#9;gameFloorObj.FreeFallCounter = 0.0
&#9;gameFloorObj.ResolutionVectors = {}
&#9;gameFloorObj.Mass = gameFloor.Size.X.Scale * gameFloor.Size.Y.Scale * 50.0
&#9;gameFloorObj.CR = 0.0
&#9;table.insert(physicsObjects, gameFloorObj)

&#9;
&#9;gameFloor2 = Instance.new(&quot;ImageLabel&quot;)
&#9;gameFloor2.Name = &quot;Floor&quot;
&#9;gameFloor2.Parent = gameFrame
&#9;gameFloor2.Position = UDim2.new(1, 0, 0.8, 0)
&#9;gameFloor2.Size = UDim2.new(1, 0, 0.2, 0)
&#9;gameFloor2.Image = &quot;http://www.roblox.com/asset/?id=65911902&quot;
&#9;gameFloor2.BackgroundTransparency = 1.0
&#9;gameFloor2.ZIndex = 3.0
&#9;table.insert(gameFloorObj2, gameFloor2)
&#9;gameFloorObj2.Velocity = Vector2.new(0, 0)
&#9;gameFloorObj2.Anchored = true 
&#9;gameFloorObj2.FreeFall = false 
&#9;gameFloorObj2.FreeFallCounter = 0.0
&#9;gameFloorObj2.ResolutionVectors = {}
&#9;gameFloorObj2.Mass = gameFloor.Size.X.Scale * gameFloor2.Size.Y.Scale * 50.0
&#9;gameFloorObj2.CR = 0.0
&#9;table.insert(physicsObjects, gameFloorObj2)&#9;
&#9;createGameCharacter()&#9;

&#9;-- Create the default projectile, can&apos;t think of a better place to put this 
&#9;gameProjectile = Instance.new(&quot;ImageLabel&quot;) 
&#9;gameProjectile.Image = &quot;http://www.roblox.com/asset/?id=66202637&quot; 
&#9;gameProjectile.Size = UDim2.new(0.020, 0, 0.019, 0) 
&#9;gameProjectile.BackgroundTransparency = 1.0 
&#9;gameProjectile.Name = &quot;CharProjectile&quot;
&#9;gameProjectile.ZIndex = 5.0
&#9;
&#9;World.DistanceTravelled = 0.0
end

function createGameInterface()
&#9;gameScreen = Instance.new(&quot;ScreenGui&quot;)
&#9;gameScreen.Parent = vPlayer.PlayerGui
&#9;gameScreen.Name = &quot;Game Screen&quot;

&#9;while gameScreen.AbsoluteSize.X == 0 do wait() end -- Patience is a virtue&#9;

&#9;local screenMidPoint = Vector2.new(gameScreen.AbsoluteSize.X/2.0, gameScreen.AbsoluteSize.Y/2.0) &#9;

&#9;gameFrame = Instance.new(&quot;Frame&quot;)
&#9;gameFrame.Parent = gameScreen
&#9;gameFrame.Size = UDim2.new(0, 800, 0, 600)
&#9;gameFrame.Position = UDim2.new(0, screenMidPoint.X - 400, 0, screenMidPoint.Y - 300)
&#9;gameFrame.Name = &quot;Game Frame&quot;
&#9;gameFrame.BackgroundTransparency = 1.0&#9;
&#9;gameFrame.ClipsDescendants = true 

&#9;gameIntroImage = Instance.new(&quot;ImageLabel&quot;)
&#9;gameIntroImage.Parent = gameFrame 
&#9;gameIntroImage.Position = UDim2.new(0, 0, 0, 0)
&#9;gameIntroImage.Size = UDim2.new(1, 0, 1, 0)
&#9;gameIntroImage.Name = &quot;IntroScreen&quot;
&#9;gameIntroImage.Image = &quot;http://www.roblox.com/asset/?id=65978066&quot;
&#9;gameIntroImage.ZIndex = 7.0 
&#9;gameIntroImage.BackgroundTransparency = 1.0 

&#9;gameStartButton = Instance.new(&quot;ImageButton&quot;)
&#9;gameStartButton.Parent = gameFrame 
&#9;gameStartButton.Position = UDim2.new(0.5, -75, 0.6, -25)
&#9;gameStartButton.Size = UDim2.new(0, 150, 0, 50)
&#9;gameStartButton.Name = &quot;Start&quot;
&#9;gameStartButton.Image = &quot;http://www.roblox.com/asset/?id=65978165&quot;
&#9;gameStartButton.ZIndex = 8.0
&#9;gameStartButton.BackgroundTransparency = 1.0

&#9;gameStartButton.MouseButton1Click:connect(function()
&#9;&#9;gameStartButton.Image = &quot;http://www.roblox.com/asset/?id=65978517&quot;
&#9;&#9;wait(1.2)
&#9;&#9;World:InitiateGameAssets()&#9;&#9;
&#9;&#9;if gameIntroImage then gameIntroImage:Remove() end 
&#9;&#9;if gameStartButton then gameStartButton:Remove() end
&#9;end)&#9;
&#9;
&#9;gameStartButton.MouseEnter:connect(function()
&#9;&#9;gameStartButton.Image = &quot;http://www.roblox.com/asset/?id=65978204&quot;
&#9;end)
&#9;
&#9;gameStartButton.MouseLeave:connect(function() 
&#9;&#9;gameStartButton.Image = &quot;http://www.roblox.com/asset/?id=65978165&quot;
&#9;end)
end

function World:SetCharacterVelocity()
&#9;if gameCharObj and gameCharObj.Moving then &#9;&#9;
&#9;&#9;if gameCharObj.Backwards then 
&#9;&#9;&#9;gameCharObj.Velocity = Vector2.new(-0.003, gameCharObj.Velocity.Y) -- gameCharObj.Velocity + Vector2.new(-0.002, 0)
&#9;&#9;elseif gameCharObj.Forwards then 
&#9;&#9;&#9;gameCharObj.Velocity = Vector2.new(0.003, gameCharObj.Velocity.Y) -- gameCharObj.Velocity + Vector2.new(0.002, 0)
&#9;&#9;end&#9;&#9;
&#9;end
&#9;if gameCharObj and gameCharObj.Jumping and not gameCharObj.FreeFall then 
&#9;&#9;gameCharObj.Velocity = Vector2.new(gameCharObj.Velocity.X, -0.012)
&#9;end
end

function charMovementStop(key)
&#9;if key and gameCharObj then
&#9;&#9;key = key:lower()
&#9;&#9;if key == &quot;a&quot; or key == &quot;d&quot; then 
&#9;&#9;&#9;gameCharObj.Moving = false 
&#9;&#9;end 
&#9;&#9;if key == &quot;a&quot; then 
&#9;&#9;&#9;gameCharObj.Backwards = false 
&#9;&#9;elseif key == &quot;d&quot; then 
&#9;&#9;&#9;gameCharObj.Forwards = false &#9;
&#9;&#9;end&#9;&#9;
&#9;end
end

function charMovementStart(key)
&#9;if key and gameCharObj then
&#9;&#9;key = key:lower()
&#9;&#9;if key == &quot;a&quot; or key == &quot;d&quot; then 
&#9;&#9;&#9;gameCharObj.Moving = true&#9;&#9;
&#9;&#9;end
&#9;&#9;if key == &quot;a&quot; then 
&#9;&#9;&#9;gameCharObj.Backwards = true&#9;&#9;&#9;
&#9;&#9;elseif key == &quot;d&quot; then
&#9;&#9;&#9;gameCharObj.Forwards = true&#9;&#9;&#9;
&#9;&#9;elseif key == &quot;w&quot; then 
&#9;&#9;&#9;if jumpCo == nil or coroutine.status(jumpCo) == &quot;dead&quot; then &#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;gameCharObj.Jumping = true
&#9;&#9;&#9;&#9;jumpCo = coroutine.create(function() if gameCharObj then wait(0.2) gameCharObj.Jumping = false gameCharObj.FreeFall = true end wait(1.0) end) 
&#9;&#9;&#9;&#9;coroutine.resume(jumpCo)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

function transformToWorldCoordinates(mouse) 
&#9;if gameFrame then 
&#9;&#9;local xPos = mouse.X - gameFrame.Position.X.Offset 
&#9;&#9;local yPos = mouse.Y - gameFrame.Position.Y.Offset 
&#9;&#9;return Vector2.new(xPos, yPos) 
&#9;end 
end 

function fire(projectileClone, direction)  &#9;
&#9;local collision = false
&#9;-- Lets set the velocity to be 2 units 
&#9;while projectileClone do            &#9;&#9;
&#9;&#9;projectileClone.Position = projectileClone.Position + UDim2.new((direction.X * 0.02), 0, (direction.Y * 0.02), 0)           
&#9;&#9;if projectileClone.Position.X.Scale &gt;= 1 or projectileClone.Position.X.Scale &lt;= 0 or projectileClone.Position.Y.Scale &gt;= 1 or projectileClone.Position.Y.Scale &lt;= 0 then &#9;&#9;&#9;
&#9;&#9;&#9;projectileClone:Remove() 
&#9;&#9;&#9;projectileClone = nil 
&#9;&#9;end &#9;&#9;&#9;&#9;&#9;&#9;
&#9;&#9;for i, enemy in pairs(enemies) do                 
&#9;&#9;&#9;if projectileClone and enemy and enemy ~= enemies.NumEnemies then collision = checkForCollision(enemy[1], projectileClone, Vector2.new(0, 0)) end 
&#9;&#9;&#9;if enemy ~= enemies.NumEnemies and collision and projectileClone then &#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;projectileClone:Remove() 
&#9;&#9;&#9;&#9;projectileClone = nil &#9;&#9;&#9;&#9;                     
&#9;&#9;&#9;&#9;if enemy and enemy.Health and enemy.Health &gt; 0 then                            
&#9;&#9;&#9;&#9;&#9;enemy.Health = enemy.Health - 17
&#9;&#9;&#9;&#9;elseif enemy then&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;for i = 1, #physicsObjects do 
&#9;&#9;&#9;&#9;&#9;&#9;if physicsObjects[i] == enemy then 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;table.remove(physicsObjects, i) 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;physicsObjects[i] = nil 
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;enemy[1]:Remove() 
&#9;&#9;&#9;&#9;&#9;enemies[enemy] = nil 
&#9;&#9;&#9;&#9;&#9;enemy = nil 
&#9;&#9;&#9;&#9;&#9;enemies.NumEnemies = enemies.NumEnemies - 1 &#9;&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;end  
&#9;&#9;&#9;end
&#9;&#9;end 
&#9;&#9;if World.CloneBossObj and World.CloneBossObj[1] and projectileClone then &#9;&#9;&#9;
&#9;&#9;&#9;collision = checkForCollision(World.CloneBossObj[1], projectileClone, Vector2.new(0, 0)) &#9;&#9;&#9;
&#9;&#9;&#9;if collision and projectileClone then
&#9;&#9;&#9;&#9;if World.CloneBossObj.Health and World.CloneBossObj.Health &gt; 0 then 
&#9;&#9;&#9;&#9;&#9;World.CloneBossObj.Health = World.CloneBossObj.Health - 17 
&#9;&#9;&#9;&#9;&#9;projectileClone:Remove() 
&#9;&#9;&#9;&#9;&#9;projectileClone = nil 
&#9;&#9;&#9;&#9;&#9;if World.CloneBossObj.Health &lt;= 0 then
&#9;&#9;&#9;&#9;&#9;&#9;print(&quot;Removing boss&quot;)
&#9;&#9;&#9;&#9;&#9;&#9;for i = 1, #physicsObjects do 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if physicsObjects[i] == World.CloneBossObj then table.remove(physicsObjects, i) end
&#9;&#9;&#9;&#9;&#9;&#9;end&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;&#9;World.CloneBossObj[1]:Remove()
&#9;&#9;&#9;&#9;&#9;&#9;World.CloneBossObj = nil 
&#9;&#9;&#9;&#9;&#9;end 
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;if World.MedusaBossObj and World.MedusaBossObj[1] and projectileClone then &#9;&#9;&#9;
&#9;&#9;&#9;collision = checkForCollision(World.MedusaBossObj[1], projectileClone, Vector2.new(0, 0)) &#9;&#9;&#9;
&#9;&#9;&#9;if collision and projectileClone then
&#9;&#9;&#9;&#9;if World.MedusaBossObj.Health and World.MedusaBossObj.Health &gt; 0 then 
&#9;&#9;&#9;&#9;&#9;World.MedusaBossObj.Health = World.MedusaBossObj.Health - 17 
&#9;&#9;&#9;&#9;&#9;projectileClone:Remove() 
&#9;&#9;&#9;&#9;&#9;projectileClone = nil 
&#9;&#9;&#9;&#9;&#9;if World.MedusaBossObj.Health &lt;= 0 then
&#9;&#9;&#9;&#9;&#9;&#9;print(&quot;Removing boss&quot;)
&#9;&#9;&#9;&#9;&#9;&#9;for i = 1, #physicsObjects do 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if physicsObjects[i] == World.MedusaBossObj or physicsObjects[i] == World.MedusaBossObj.Platform then table.remove(physicsObjects, i) end
&#9;&#9;&#9;&#9;&#9;&#9;end&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;&#9;World.MedusaBossObj.Platform[1]:Remove() 
&#9;&#9;&#9;&#9;&#9;&#9;World.MedusaBossObj[1]:Remove()
&#9;&#9;&#9;&#9;&#9;&#9;World.MedusaBossObj = nil 
&#9;&#9;&#9;&#9;&#9;end 
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;if World.SunBossObj and World.SunBossObj[1] and projectileClone then &#9;&#9;&#9;
&#9;&#9;&#9;collision = checkForCollision(World.SunBossObj[1], projectileClone, Vector2.new(0, 0)) &#9;&#9;&#9;
&#9;&#9;&#9;if collision and projectileClone then
&#9;&#9;&#9;&#9;if World.SunBossObj.Health and World.SunBossObj.Health &gt; 0 then 
&#9;&#9;&#9;&#9;&#9;World.SunBossObj.Health = World.SunBossObj.Health - 17 
&#9;&#9;&#9;&#9;&#9;projectileClone:Remove() 
&#9;&#9;&#9;&#9;&#9;projectileClone = nil 
&#9;&#9;&#9;&#9;&#9;if World.SunBossObj.Health &lt;= 0 then
&#9;&#9;&#9;&#9;&#9;&#9;print(&quot;Removing boss&quot;)
&#9;&#9;&#9;&#9;&#9;&#9;for i = 1, #physicsObjects do 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if physicsObjects[i] == World.SunBossObj then table.remove(physicsObjects, i) end
&#9;&#9;&#9;&#9;&#9;&#9;end&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;&#9;World.SunBossObj[1]:Remove()
&#9;&#9;&#9;&#9;&#9;&#9;World.SunBossObj = nil 
&#9;&#9;&#9;&#9;&#9;end 
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;wait()&#9;&#9;
&#9;end
end 

function gameCharFire(mouse) &#9;
&#9;if mouse and gameProjectile and gameCharObj and gameCharObj.Firing == false and gameCharObj.Anchored == false then &#9;&#9;
&#9;&#9;gameCharObj.Firing = true 
&#9;&#9;local projectileClone = gameProjectile:Clone() &#9;&#9;
&#9;&#9;local mouseInWorld = transformToWorldCoordinates(mouse) 
&#9;&#9;local gameCharPos = transformToWorldCoordinates(gameCharObj[1].AbsolutePosition) 
&#9;&#9;if mouseInWorld and mouseInWorld.X &gt; gameCharObj[1].Position.X.Scale then 
&#9;&#9;&#9;--gameCharObj[1].Image = &quot;http://www.roblox.com/asset/?id=58461425&quot; 
&#9;&#9;&#9;projectileClone.Position = gameCharObj[1].Position + UDim2.new(0.01, 0, 0.025, 0) 
&#9;&#9;else 
&#9;&#9;&#9;--gameCharObj[1].Image = &quot;http://www.roblox.com/asset/?id=58462272&quot; 
&#9;&#9;&#9;projectileClone.Position = gameCharObj[1].Position + UDim2.new(-0.01, 0, 0.025, 0) 
&#9;&#9;end 
&#9;&#9;projectileClone.Parent = gameFrame 
&#9;&#9;table.insert(gameProjectileClones, projectileClone) &#9;&#9;
&#9;&#9;local direction = (mouseInWorld - gameCharPos).unit 
&#9;&#9;if projectileSound then projectileSound:Play() end 
&#9;&#9;coroutine.resume(coroutine.create(function() fire(projectileClone, direction) end))                
&#9;&#9;wait(0.75) 
&#9;&#9;gameCharObj.Firing = false 
&#9;end 
end 

function onActivated()
&#9;if Tool.Enabled == false then 
&#9;&#9;return
&#9;end
&#9;
&#9;Tool.Enabled = false

&#9;vCharacter = Tool.Parent
&#9;myTorso = vCharacter:FindFirstChild(&quot;Torso&quot;)
&#9;myHumanoid = vCharacter:FindFirstChild(&quot;Humanoid&quot;)
&#9;vPlayer = game.Players:GetPlayerFromCharacter(vCharacter)

&#9;if myTorso == nil or myHumanoid == nil then 
&#9;&#9;return  
&#9;end

&#9;myTorso.Anchored = true 
&#9;myHumanoid.WalkSpeed = 0.0&#9;

&#9;if vPlayer then 
&#9;&#9;createGameInterface() 
&#9;end

&#9;while gameCharObj == nil do wait() end

&#9;World:Update()

&#9;wait(200.0)
&#9;myTorso.Anchored = true 
&#9;myHumanoid.WalkSpeed = 0.0
&#9;Tool.Enabled = true 
end

function onEquipped(mouse)
&#9;if mouse then 
&#9;&#9;mouse.KeyDown:connect(charMovementStart)
&#9;&#9;mouse.KeyUp:connect(charMovementStop)
&#9;&#9;mouse.Button1Down:connect(function() gameCharFire(mouse) end) 
&#9;&#9;mouse.Icon = &quot;http://www.roblox.com/asset/?id=66229629&quot;
&#9;end
end

function onUnequipped()
&#9;if myTorso then 
&#9;&#9;myTorso.Anchored = false
&#9;end
&#9;if myHumanoid then 
&#9;&#9;myHumanoid.WalkSpeed = 16.0
&#9;end
&#9;if gameScreen then gameScreen:Remove() end
end

Tool.Activated:connect(onActivated)
Tool.Equipped:connect(onEquipped)
Tool.Unequipped:connect(onUnequipped)

function World:Update()
&#9;while true do&#9;&#9;&#9;&#9;
&#9;&#9;World:SetCharacterVelocity()
&#9;&#9;World:SimulatePhysics()&#9;&#9;
&#9;&#9;World:SimulateMovement()&#9;
&#9;&#9;World:ScrollWorld()
&#9;&#9;World:SpawnEnemy()
&#9;&#9;World:AIUpdate()
&#9;&#9;World:CheckEvents()
&#9;&#9;wait() -- 30 FPS
&#9;end
end
</ProtectedString>
			</Properties>
		</Item>
		<Item class="Camera" referent="RBX8">
			<Properties>
				<Ref name="CameraSubject">null</Ref>
				<token name="CameraType">0</token>
				<CoordinateFrame name="CoordinateFrame">
					<X>-0.944345832</X>
					<Y>17.8383732</Y>
					<Z>-0.0843023658</Z>
					<R00>-0.999610126</R00>
					<R01>-0.0275788419</R01>
					<R02>0.00436806772</R02>
					<R10>-4.65661287e-010</R10>
					<R11>0.156434774</R11>
					<R12>0.987688303</R12>
					<R20>-0.0279226173</R20>
					<R21>0.987303257</R21>
					<R22>-0.156373769</R22>
				</CoordinateFrame>
				<CoordinateFrame name="Focus">
					<X>-0.949445009</X>
					<Y>16.6853714</Y>
					<Z>0.0982443392</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<string name="Name">ThumbnailCamera</string>
			</Properties>
		</Item>
	</Item>
</roblox>