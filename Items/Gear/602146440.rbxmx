<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Tool" referent="RBX025738E972CA46C59EA71F14F330644F">
		<Properties>
			<bool name="CanBeDropped">true</bool>
			<bool name="Enabled">true</bool>
			<CoordinateFrame name="Grip">
				<X>0</X>
				<Y>-1.5</Y>
				<Z>0.125</Z>
				<R00>1</R00>
				<R01>0</R01>
				<R02>0</R02>
				<R10>0</R10>
				<R11>1</R11>
				<R12>0</R12>
				<R20>0</R20>
				<R21>0</R21>
				<R22>1</R22>
			</CoordinateFrame>
			<bool name="ManualActivationOnly">false</bool>
			<string name="Name">PizzaSword</string>
			<bool name="RequiresHandle">true</bool>
			<BinaryString name="Tags"></BinaryString>
			<Content name="TextureId"><url>http://www.roblox.com/asset/?id=601013674</url></Content>
			<string name="ToolTip"></string>
		</Properties>
		<Item class="Part" referent="RBX516A9A2BCB184BE3A9EE1F0F8DC30944">
			<Properties>
				<bool name="Anchored">false</bool>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">0</token>
				<token name="BottomSurfaceInput">0</token>
				<CoordinateFrame name="CFrame">
					<X>-0.000426999992</X>
					<Y>5.25260496</Y>
					<Z>3.99774981</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>0.691534996</R11>
					<R12>0.722343028</R12>
					<R20>0</R20>
					<R21>-0.722343028</R21>
					<R22>0.691534996</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<int name="CollisionGroupId">0</int>
				<Color3uint8 name="Color3uint8">4284702562</Color3uint8>
				<PhysicalProperties name="CustomPhysicalProperties">
					<CustomPhysics>false</CustomPhysics>
				</PhysicalProperties>
				<float name="Elasticity">0.5</float>
				<float name="Friction">0.300000012</float>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">true</bool>
				<token name="Material">256</token>
				<string name="Name">Handle</string>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<BinaryString name="Tags"></BinaryString>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">0</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<token name="formFactorRaw">3</token>
				<token name="shape">1</token>
				<Vector3 name="size">
					<X>0.200000003</X>
					<Y>4</Y>
					<Z>0.5</Z>
				</Vector3>
			</Properties>
			<Item class="SpecialMesh" referent="RBXC276BCBFCC7A4174A58D4934CD5E3188">
				<Properties>
					<token name="LODX">2</token>
					<token name="LODY">2</token>
					<Content name="MeshId"><url>http://www.roblox.com/asset/?id=601013396</url></Content>
					<token name="MeshType">5</token>
					<string name="Name">Mesh</string>
					<Vector3 name="Offset">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<Vector3 name="Scale">
						<X>1.25</X>
						<Y>1.25</Y>
						<Z>1.25</Z>
					</Vector3>
					<BinaryString name="Tags"></BinaryString>
					<Content name="TextureId"><url>http://www.roblox.com/asset/?id=601013560</url></Content>
					<Vector3 name="VertexColor">
						<X>1</X>
						<Y>1</Y>
						<Z>1</Z>
					</Vector3>
				</Properties>
			</Item>
			<Item class="Sound" referent="RBXD3188E518D0740D58AF1C252E5F2A2C3">
				<Properties>
					<float name="EmitterSize">10</float>
					<bool name="Looped">false</bool>
					<string name="Name">Death1</string>
					<bool name="PlayOnRemove">false</bool>
					<float name="PlaybackSpeed">1</float>
					<bool name="Playing">false</bool>
					<token name="RollOffMode">0</token>
					<Ref name="SoundGroup">null</Ref>
					<Content name="SoundId"><url>http://www.roblox.com/asset/?id=169310273</url></Content>
					<BinaryString name="Tags"></BinaryString>
					<double name="TimePosition">0</double>
					<float name="Volume">1</float>
					<float name="xmlRead_MaxDistance_3">10000</float>
				</Properties>
			</Item>
			<Item class="Sound" referent="RBX0891900D096F43BC91A2FCA7146C837D">
				<Properties>
					<float name="EmitterSize">10</float>
					<bool name="Looped">false</bool>
					<string name="Name">Death2</string>
					<bool name="PlayOnRemove">false</bool>
					<float name="PlaybackSpeed">1</float>
					<bool name="Playing">false</bool>
					<token name="RollOffMode">0</token>
					<Ref name="SoundGroup">null</Ref>
					<Content name="SoundId"><url>http://www.roblox.com/asset/?id=169310284</url></Content>
					<BinaryString name="Tags"></BinaryString>
					<double name="TimePosition">0</double>
					<float name="Volume">1</float>
					<float name="xmlRead_MaxDistance_3">10000</float>
				</Properties>
			</Item>
			<Item class="Sound" referent="RBX527EDD645B13421B9F10041B88991132">
				<Properties>
					<float name="EmitterSize">10</float>
					<bool name="Looped">false</bool>
					<string name="Name">Death3</string>
					<bool name="PlayOnRemove">false</bool>
					<float name="PlaybackSpeed">1</float>
					<bool name="Playing">false</bool>
					<token name="RollOffMode">0</token>
					<Ref name="SoundGroup">null</Ref>
					<Content name="SoundId"><url>http://www.roblox.com/asset/?id=169310295</url></Content>
					<BinaryString name="Tags"></BinaryString>
					<double name="TimePosition">0</double>
					<float name="Volume">1</float>
					<float name="xmlRead_MaxDistance_3">10000</float>
				</Properties>
			</Item>
			<Item class="Sound" referent="RBX55CC577FC4E34548B26D10C0D881FC92">
				<Properties>
					<float name="EmitterSize">10</float>
					<bool name="Looped">false</bool>
					<string name="Name">Equip</string>
					<bool name="PlayOnRemove">false</bool>
					<float name="PlaybackSpeed">1</float>
					<bool name="Playing">false</bool>
					<token name="RollOffMode">0</token>
					<Ref name="SoundGroup">null</Ref>
					<Content name="SoundId"><url>http://www.roblox.com/asset/?id=169310310</url></Content>
					<BinaryString name="Tags"></BinaryString>
					<double name="TimePosition">0</double>
					<float name="Volume">0.300000012</float>
					<float name="xmlRead_MaxDistance_3">10000</float>
				</Properties>
			</Item>
			<Item class="Sound" referent="RBX5245034FDAB04ECD87A6A2F1ECDF1CCC">
				<Properties>
					<float name="EmitterSize">10</float>
					<bool name="Looped">false</bool>
					<string name="Name">Hit1</string>
					<bool name="PlayOnRemove">false</bool>
					<float name="PlaybackSpeed">1</float>
					<bool name="Playing">false</bool>
					<token name="RollOffMode">0</token>
					<Ref name="SoundGroup">null</Ref>
					<Content name="SoundId"><url>http://www.roblox.com/asset/?id=169310515</url></Content>
					<BinaryString name="Tags"></BinaryString>
					<double name="TimePosition">0</double>
					<float name="Volume">0.300000012</float>
					<float name="xmlRead_MaxDistance_3">10000</float>
				</Properties>
			</Item>
			<Item class="Sound" referent="RBX6C5FDCBC51A34EB9B8DA9081572484BE">
				<Properties>
					<float name="EmitterSize">10</float>
					<bool name="Looped">false</bool>
					<string name="Name">Hit2</string>
					<bool name="PlayOnRemove">false</bool>
					<float name="PlaybackSpeed">1</float>
					<bool name="Playing">false</bool>
					<token name="RollOffMode">0</token>
					<Ref name="SoundGroup">null</Ref>
					<Content name="SoundId"><url>http://www.roblox.com/asset/?id=169310520</url></Content>
					<BinaryString name="Tags"></BinaryString>
					<double name="TimePosition">0</double>
					<float name="Volume">0.300000012</float>
					<float name="xmlRead_MaxDistance_3">10000</float>
				</Properties>
			</Item>
			<Item class="Sound" referent="RBXB5DD87CC0B1C49309A0735BF71FC3C65">
				<Properties>
					<float name="EmitterSize">10</float>
					<bool name="Looped">false</bool>
					<string name="Name">Hit3</string>
					<bool name="PlayOnRemove">false</bool>
					<float name="PlaybackSpeed">1</float>
					<bool name="Playing">false</bool>
					<token name="RollOffMode">0</token>
					<Ref name="SoundGroup">null</Ref>
					<Content name="SoundId"><url>http://www.roblox.com/asset/?id=169310529</url></Content>
					<BinaryString name="Tags"></BinaryString>
					<double name="TimePosition">0</double>
					<float name="Volume">0.300000012</float>
					<float name="xmlRead_MaxDistance_3">10000</float>
				</Properties>
			</Item>
			<Item class="Sound" referent="RBX6BD838BC204749B9B0DC1F8B2ABAA5B4">
				<Properties>
					<float name="EmitterSize">10</float>
					<bool name="Looped">false</bool>
					<string name="Name">Hit4</string>
					<bool name="PlayOnRemove">false</bool>
					<float name="PlaybackSpeed">1</float>
					<bool name="Playing">false</bool>
					<token name="RollOffMode">0</token>
					<Ref name="SoundGroup">null</Ref>
					<Content name="SoundId"><url>http://www.roblox.com/asset/?id=169310534</url></Content>
					<BinaryString name="Tags"></BinaryString>
					<double name="TimePosition">0</double>
					<float name="Volume">0.300000012</float>
					<float name="xmlRead_MaxDistance_3">10000</float>
				</Properties>
			</Item>
			<Item class="Sound" referent="RBX882C3F6F0AF1480893132F14E0E3BBB8">
				<Properties>
					<float name="EmitterSize">10</float>
					<bool name="Looped">false</bool>
					<string name="Name">Swing1</string>
					<bool name="PlayOnRemove">false</bool>
					<float name="PlaybackSpeed">1</float>
					<bool name="Playing">false</bool>
					<token name="RollOffMode">0</token>
					<Ref name="SoundGroup">null</Ref>
					<Content name="SoundId"><url>http://www.roblox.com/asset/?id=169310429</url></Content>
					<BinaryString name="Tags"></BinaryString>
					<double name="TimePosition">0</double>
					<float name="Volume">0.5</float>
					<float name="xmlRead_MaxDistance_3">10000</float>
				</Properties>
			</Item>
			<Item class="Sound" referent="RBXA72D23E20AE74F9788275C17A3956106">
				<Properties>
					<float name="EmitterSize">10</float>
					<bool name="Looped">false</bool>
					<string name="Name">Swing2</string>
					<bool name="PlayOnRemove">false</bool>
					<float name="PlaybackSpeed">1</float>
					<bool name="Playing">false</bool>
					<token name="RollOffMode">0</token>
					<Ref name="SoundGroup">null</Ref>
					<Content name="SoundId"><url>http://www.roblox.com/asset/?id=169310436</url></Content>
					<BinaryString name="Tags"></BinaryString>
					<double name="TimePosition">0</double>
					<float name="Volume">0.5</float>
					<float name="xmlRead_MaxDistance_3">10000</float>
				</Properties>
			</Item>
			<Item class="Sound" referent="RBX002601E3D02C46DABF7724E6E7B9CF3F">
				<Properties>
					<float name="EmitterSize">10</float>
					<bool name="Looped">false</bool>
					<string name="Name">Swing3</string>
					<bool name="PlayOnRemove">false</bool>
					<float name="PlaybackSpeed">1</float>
					<bool name="Playing">false</bool>
					<token name="RollOffMode">0</token>
					<Ref name="SoundGroup">null</Ref>
					<Content name="SoundId"><url>http://www.roblox.com/asset/?id=169310447</url></Content>
					<BinaryString name="Tags"></BinaryString>
					<double name="TimePosition">0</double>
					<float name="Volume">0.5</float>
					<float name="xmlRead_MaxDistance_3">10000</float>
				</Properties>
			</Item>
			<Item class="Sound" referent="RBX08B57B9122394A31B89377988FE9316B">
				<Properties>
					<float name="EmitterSize">10</float>
					<bool name="Looped">false</bool>
					<string name="Name">Swing4</string>
					<bool name="PlayOnRemove">false</bool>
					<float name="PlaybackSpeed">1</float>
					<bool name="Playing">false</bool>
					<token name="RollOffMode">0</token>
					<Ref name="SoundGroup">null</Ref>
					<Content name="SoundId"><url>http://www.roblox.com/asset/?id=169310455</url></Content>
					<BinaryString name="Tags"></BinaryString>
					<double name="TimePosition">0</double>
					<float name="Volume">0.5</float>
					<float name="xmlRead_MaxDistance_3">10000</float>
				</Properties>
			</Item>
		</Item>
		<Item class="Camera" referent="RBXE0522EF2D3A7410E82195E8D41388B66">
			<Properties>
				<CoordinateFrame name="CFrame">
					<X>-4.59912729</X>
					<Y>5.1475997</Y>
					<Z>4.27632427</Z>
					<R00>0.0348981805</R00>
					<R01>-0.0426840745</R01>
					<R02>-0.998478889</R02>
					<R10>1.16415336e-10</R10>
					<R11>0.999087512</R11>
					<R12>-0.0427100882</R12>
					<R20>0.9993909</R20>
					<R21>0.00149050425</R21>
					<R22>0.0348663367</R22>
				</CoordinateFrame>
				<Ref name="CameraSubject">null</Ref>
				<token name="CameraType">0</token>
				<float name="FieldOfView">40</float>
				<CoordinateFrame name="Focus">
					<X>-0.305668592</X>
					<Y>5.33125305</Y>
					<Z>4.12639904</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="HeadLocked">true</bool>
				<float name="HeadScale">1</float>
				<string name="Name">ThumbnailCamera</string>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="Script" referent="RBX412BBA8EE7834C85A7D9301A52359000">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">GunAnimation</string>
				<string name="ScriptGuid">{62C4FDCD-ECDD-4148-B72C-7255051B895E}</string>
				<ProtectedString name="Source"><![CDATA[--Rescripted by Luckymaxer

Tool = script.Parent
Handle = Tool:WaitForChild("Handle")

Players = game:GetService("Players")
Debris = game:GetService("Debris")
RunService = game:GetService("RunService")

RbxUtility = LoadLibrary("RbxUtility")
Create = RbxUtility.Create

BaseUrl = "http://www.roblox.com/asset/?id="

CF = CFrame.new
An = CFrame.Angles
V3 = Vector3.new

local AnimEquip = 0
local AttackPerform = tick()
local Weapon

BasePart = Create("Part"){
	Material = Enum.Material.Plastic,
	FormFactor = Enum.FormFactor.Custom,
	TopSurface = Enum.SurfaceType.Smooth,
	BottomSurface = Enum.SurfaceType.Smooth,
	Size = V3(0.2, 0.2, 0.2),
	CanCollide = true,
	Locked = true,
}

Settings = {
	Damage = 10,
	EquipTime = 0.4,
	IdleSpeed = 5,
	AttackSpeed = 0.65,
}

StabDamage = 20

Sounds = {
	Equip = {
		Handle:WaitForChild("Equip"),
	},
	Swing = {
		Handle:WaitForChild("Swing1"),
		Handle:WaitForChild("Swing2"),
		Handle:WaitForChild("Swing3"),
		Handle:WaitForChild("Swing4"),
	},
	Hit = {
		Handle:WaitForChild("Hit1"),
		Handle:WaitForChild("Hit2"),
		Handle:WaitForChild("Hit3"),
	},
	Death = {
		Handle:WaitForChild("Death1"),
		Handle:WaitForChild("Death2"),
		Handle:WaitForChild("Death3"),
	},
}

Configuration = require(script:WaitForChild("Configuration"))
Functions = require(script:WaitForChild("Functions"))

Animations = Configuration.Animations

BaseWeapon = Handle:Clone()
BaseWeapon.Name = "FakeHandle"
BaseWeapon.Size = V3(0.2, 0.2, 0.2)
BaseWeapon.CanCollide = false

ServerControl = (Tool:FindFirstChild("ServerControl") or Create("RemoteFunction"){
	Name = "ServerControl",
	Parent = Tool,
})

ClientControl = (Tool:FindFirstChild("ClientControl") or Create("RemoteFunction"){
	Name = "ClientControl",
	Parent = Tool,
})

ToolEquipped = false

Handle.Transparency = 0
Tool.Enabled = true

for i, v in pairs(Tool:GetChildren()) do
	if v:IsA("BasePart") and v ~= Handle then
		v:Destroy()
	end
end

TargetPosition = V3(0, 0, 0)

function PlaySound(nm, dl)
	Spawn(function()
		local CurrentlyEquipped = true
		ToolUnequipped = Tool.Unequipped:connect(function()
			CurrentlyEquipped = false
		end)
		if dl then
			wait(dl)
		end
		if ToolUnequipped then
			ToolUnequipped:disconnect()
		end
		if not CurrentlyEquipped then
			return
		end
		local PossibleSounds = Sounds[nm]
		local Sound = PossibleSounds[math.random(1, #PossibleSounds)]
		Sound:Play()
	end)
end

function Slash(del)
	Spawn(function()
		local Hits = {}
		local Start = tick()
		local function PartTouched(Hit)
			if not Hit or not Hit.Parent then
				return
			end
			local character = Hit.Parent
			if Functions.CheckTableForInstance(Hits, character) then
				return
			end
			local player = Players:GetPlayerFromCharacter(character)
			if player and (player == Player or Functions.IsTeamMate(Player, player)) then
				return
			end
			local humanoid = character:FindFirstChild("Humanoid")
			if not humanoid or humanoid.Health == 0 then
				return
			end
			PlaySound("Hit", nil)
			local Damage = StabDamage
			table.insert(Hits, Hit)
			Functions.UntagHumanoid(humanoid)
			Functions.TagHumanoid(humanoid, Player)
			humanoid:TakeDamage(Damage)
			if humanoid.Health <= Damage then
				PlaySound("Death", nil)
			end
		end
		if WeaponHit then
			WeaponHit:disconnect()
		end
		WeaponHit = Weapon.Touched:connect(PartTouched)
		while (tick() - Start) <= Settings.AttackSpeed and ToolEquipped do
			wait()
		end
		if WeaponHit then
			WeaponHit:disconnect()
		end
	end)
end

function Animate(tp, st)
	AnimType = tp
	AnimState = st
end

function StartAnimation()
	OriginalJoints = {Neck = Torso:FindFirstChild("Neck"), RightShoulder = Torso:FindFirstChild("Right Shoulder")}
	for i, v in pairs(OriginalJoints) do
		if v then
			local Joint = {Joint = v, Properties = {Part0 = v.Part0, Part1 = v.Part1, C0 = v.C0, C1 = v.C1}}
			OriginalJoints[i] = Joint
		end
	end
	local Joints = {
		RightWeld = {Name = "RightWeld", Part0 = Torso, Part1 = RightArm, C0 = CF(1.5, 0, 0)},
		HeadWeld = {Name = "Head", Part0 = Torso, Part1 = Head, C0 = CF(0, 1.5, 0)},
	}
	for i, v in pairs(OriginalJoints) do
		if v then
			v.Joint.Part1 = nil
		end
	end
	Welds = {}
	for i, v in pairs(Joints) do
		local Joint = Create("Snap"){
			Name = v.Name,
			Part0 = v.Part0,
			Part1 = v.Part1,
			C0 = v.C0,
			C1 = (CF(0, 0, 0) * An(-(math.pi / 2), 0, 0)),
			Parent = Torso,
		}
		Welds[i] = Joint
	end
end
	
function EndAnimation()
	for i, v in pairs(Welds) do
		if v and v.Parent then
			v.Part0 = nil
			v.Part1 = nil
			v:Destroy()
		end
	end
	for i, v in pairs(OriginalJoints) do
		for ii, vv in pairs(v.Properties) do
			pcall(function()
				v.Joint[ii] = vv
			end)
		end
	end
	if AnimConnection then
		AnimConnection:disconnect()
	end
	for i, v in pairs(Tool:GetChildren()) do
		if v:IsA("BasePart") and v ~= Handle then
			v:Destroy()
		end
	end
	OriginalJoints = {}
	Welds = {}
	Weapon:Destroy()
end

function ManageAnimation()
	LastTick = tick()
	AnimEquip = 1
	LastAction = tick()
	IdleRand = math.random(4, 7)
	IdlePerform = 0
	IdleType = 1
	AttackPerform = 0
	AttackType = 1
	Animate("Equip", 0)
	PlaySound("Equip", 0.1)
	if AnimConnection then
		AnimConnection:disconnect()
	end
	AnimConnection = RunService.Stepped:connect(function()
		local Delta = (tick() - LastTick)
		LastTick = tick()
		if AnimEquip > 0 then
			AnimEquip = math.max(0, (AnimEquip - (Delta / Settings.EquipTime)))
			Animate("Equip", (1 - AnimEquip))
		elseif (tick() - AttackPerform) <= Settings.AttackSpeed then
			Animate(("Attack" .. AttackType), ((tick() - AttackPerform) / Settings.AttackSpeed))
			IdlePerform = 0
		elseif (tick() - IdlePerform) <= Settings.IdleSpeed then
			Animate(("Idle" .. IdleType), ((tick() - IdlePerform) / Settings.IdleSpeed))
		else
			Animate("Default", 0)
		end
		if (tick() - LastAction) >= IdleRand then
			IdleRand = math.random(12, 20)
			LastAction = tick()
			IdlePerform = tick()
			IdleType = math.random(1, 2)
		end
	end)
end

function RunAnimation()
	Weapon = BaseWeapon:Clone()
	Weapon.Parent = Tool
	local WepWeld = Create("Snap"){
		Part0 = RightArm,
		Part1 = Weapon,
		C0 = CF(0, 0, 0),
		Parent = Weapon,
	}
	
	local AHorse = Character:findFirstChild("HorseHead")
	local HorseDisPlace = {0, 0}
	local HorseCF = An(0.0001, 0.0001, 0)
		if AHorse then
			Spawn(function()
			while true do
				local rndwait = ((math.random(100, 1000) / 1000) * 4)
				wait(rndwait)
				local Oldd = {HorseDisPlace[1], HorseDisPlace[2]}
				local Disp2 = {math.random(-60, 60), math.random(0, 25)}
				local ld = 0
				while ld ~= 1 do
					local st = tick()
					wait()
					ld = math.min(1, ld + ((tick() - st) * 4))
					local Eff = Functions.EaseIn(ld)					
					local x = (Oldd[1] - ((Oldd[1] - Disp2[1]) * Eff))
					local y = (Oldd[2] - ((Oldd[2] - Disp2[2]) * Eff))
					HorseDisPlace = {x, y}
					HorseCF = An(math.rad(y), math.rad(x) , 0)
				end
			end
		end)
	end
	
	local LastVa = 0
	local LastVa2 = 0
	local ViewVelocity = {0, 0}
	
	Spawn(function()
		local LastTime = tick()
		while CheckIfAlive() and ToolEquipped do
			
			local Delta = (tick() - LastTime)
			LastTime = tick()
			
			local BreatheAmp = 2
			local BreatheFreq = 0.8
			local Breathe = (math.sin(math.rad(tick() * 90 * BreatheFreq)) * BreatheAmp)
			
			local pDistance = (Head.Position - TargetPosition).Magnitude
			pDistance = ((pDistance == 0 and 0.0001) or pDistance)
			local pHeight = (TargetPosition.Y - Head.Position.Y)
			local ViewAngle = ((pHeight ~= 0 and math.deg(math.asin(math.abs(pHeight) / pDistance)) * (math.abs(pHeight) / pHeight)) or 0)

			local Anmtp = AnimType
			Anmtp = (((Anmtp and not Animations[Anmtp]) and "Default") or (not Anmtp and "Default") or Anmtp)
			local Anmst = (AnimState or 0)
			
			local CurrAnim = Configuration.PlayAnimation(Anmtp, Anmst)			
			local ChestCF = (CF(0, 0.5, 0) * An(math.rad(math.max(-Configuration.RotAmplitudeChest, math.min(Configuration.RotAmplitudeChest, ViewAngle)) + 90 + Breathe), 0, 0))
			Welds.RightWeld.C1 = (ChestCF * CurrAnim[2] * CF(0, -0.5, 0)):inverse()
			WepWeld.C1 = (CurrAnim[3] * CF(0, 0.83, 0.6) * An(90, 0, 0) * An(-(math.pi / 2), 0, 0)):inverse()
			if Configuration.AnimHead then
				Welds.HeadWeld.C1 = (CF(0, 0, 0) * An(math.rad(math.max(-Configuration.RotAmplitudeHead, math.min(Configuration.RotAmplitudeHead, ViewAngle))), 0, 0) * HorseCF):inverse()
			else
				Welds.HeadWeld.C1 = (CF(0, 0, 0)):inverse()
			end
			Spawn(function()
				InvokeClient("CurrentAnimation", {Animations = CurrAnim})
			end)
			wait()
		end
	end)

end

function CheckIfAlive()
	return (((Character and Character.Parent and Humanoid and Humanoid.Parent and Humanoid.Health > 0 and Head and Head.Parent and Torso and Torso.Parent and RightArm and RightArm.Parent) and true) or false)
end

function Activated()
	if AnimEquip > 0 or (tick() - AttackPerform) <= Settings.AttackSpeed then
		return
	end
	AttackPerform = tick()
	LastAction = tick()
	AttackType = math.random(1, 3)
	IdlePerform = 0
	PlaySound("Swing", 0.15)
	repeat wait() until Weapon
	Slash(0.17)
end

function Equipped()
	Character = Tool.Parent
	Humanoid = Character:FindFirstChild("Humanoid")
	Head = Character:FindFirstChild("Head")
	Torso = Character:FindFirstChild("Torso")
	RightArm = Character:FindFirstChild("Right Arm")
	Player = Players:GetPlayerFromCharacter(Character)
	if not CheckIfAlive() then
		return
	end
	Spawn(function()
		Handle.Transparency = 1
		Humanoid.WalkSpeed = 19
		for i, v in pairs({RightArm}) do
			if v then
				Spawn(function()
					InvokeClient("SetLocalTransparencyModifier", {Object = v, Transparency = 0, AutoUpdate = false})
				end)
			end
		end
		StartAnimation()
		ManageAnimation()
		RunAnimation()
	end)
	ToolEquipped = true
end

function Unequipped()
	Handle.Transparency = 0
	if CheckIfAlive() then
		Humanoid.WalkSpeed = 16
	end
	EndAnimation()
	ToolEquipped = false
end

function OnServerInvoke(player, mode, value)
	if player ~= Player or not ToolEquipped or not mode or not value or not CheckIfAlive() then
		return
	end
	if mode == "SetTarget" then
		local TargetPos = value.TargetPosition
		if not TargetPos then
			return
		end
		TargetPosition = TargetPos
	end
end

function InvokeClient(Mode, Value)
	local ClientReturn = nil
	pcall(function()
		ClientReturn = ClientControl:InvokeClient(Player, Mode, Value)
	end)
	return ClientReturn
end

ServerControl.OnServerInvoke = OnServerInvoke

Tool.Activated:connect(Activated)
Tool.Equipped:connect(Equipped)
Tool.Unequipped:connect(Unequipped)]]></ProtectedString>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBX1B1FDF98D9AF473D8DC1DCDD010110E1">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Configuration</string>
					<string name="ScriptGuid">{54C5EBBF-A074-4776-86B2-6D55D4B217C1}</string>
					<ProtectedString name="Source"><![CDATA[--Rescripted by Luckymaxer

CF = CFrame.new
An = CFrame.Angles

Configuration = {
	
	AnimType = "Default",
	AnimState = 0,
	
	AnimHead = false,
	
	RotAmplitudeHead = 20,
	RotAmplitudeChest = 15,
	
	Animations = {
		Default = {
			{{}, 0, CFrame.new(0.4, -0.201, 0.2) * CFrame.Angles(-0.073, 0, 0.698), CFrame.new(-0.201, 0, 0) * CFrame.Angles(-0.175, 0.349, -0.262), CFrame.new(0, -0.95, -0.801) * CFrame.Angles(-1.571, 0, 0)}
		},
		Equip = {
			{{}, 0, CFrame.new(0, 0, 0) * CFrame.Angles(-1.571, 0, 0), CFrame.new(0, 0, 0) * CFrame.Angles(-1.571, 0, 0), CFrame.new(0, -1.3, -0.5) * CFrame.Angles(-2.618, 0, 0)},
			{{0.8, 2}, 0, CFrame.new(0.4, -0.201, 0.2) * CFrame.Angles(-0.024, 0, 0.698), CFrame.new(-0.201, 0, 0) * CFrame.Angles(0, 0.349, -0.262), CFrame.new(0, -0.95, -0.801) * CFrame.Angles(-1.571, 0, 0)},
			{{0.2, 2}, 0, CFrame.new(0.4, -0.201, 0.2) * CFrame.Angles(-0.073, 0, 0.698), CFrame.new(-0.201, 0, 0) * CFrame.Angles(-0.175, 0.349, -0.262), CFrame.new(0, -0.95, -0.801) * CFrame.Angles(-1.571, 0, 0)},
		},
		Idle1 = {
			{{}, 0, CFrame.new(0.4, -0.201, 0.2) * CFrame.Angles(-0.073, 0, 0.698), CFrame.new(-0.201, 0, 0) * CFrame.Angles(-0.175, 0.349, -0.262), CFrame.new(0, -0.95, -0.801) * CFrame.Angles(-1.571, 0, 0)},
			{{0.3, 2}, 0, CFrame.new(0.8, -0.301, 0.2) * CFrame.Angles(-0.05, 0, 0.872), CFrame.new(-0.201, 0, 0) * CFrame.Angles(0.523, 1.221, -0.699), CFrame.new(0, -0.95, -0.801) * CFrame.Angles(-1.571, 1.221, 0)},
			{{0.55, 2}, 0, CFrame.new(0.2, -0.5, 0.2) * CFrame.Angles(-0.04, 0, 0.698), CFrame.new(-0.201, 0, 0) * CFrame.Angles(0, 1.221, -0.175), CFrame.new(0, -0.95, -0.801) * CFrame.Angles(-1.746, 1.221, 0.174)},
			{{0.15, 2}, 0, CFrame.new(0.4, -0.201, 0.2) * CFrame.Angles(-0.073, 0, 0.698), CFrame.new(-0.201, 0, 0) * CFrame.Angles(-0.175, 0.349, -0.262), CFrame.new(0, -0.95, -0.801) * CFrame.Angles(-1.571, 0, 0)},
		},
		Idle2 = {
			{{}, 0, CFrame.new(0.4, -0.201, 0.2) * CFrame.Angles(-0.073, 0, 0.698), CFrame.new(-0.201, 0, 0) * CFrame.Angles(-0.175, 0.349, -0.262), CFrame.new(0, -0.95, -0.801) * CFrame.Angles(-1.571, 0, 0)},
			{{0.3, 2}, 0, CFrame.new(0.4, -0.201, 0.2) * CFrame.Angles(-0.024, 0, 0.872), CFrame.new(-0.201, 0, 0) * CFrame.Angles(-0.175, -0.175, -0.262), CFrame.new(0, -0.95, -0.801) * CFrame.Angles(-1.571, 0.523, 0)},
			{{0.3, 2}, 0, CFrame.new(0.4, -0.201, 0.2) * CFrame.Angles(0.049, 0, 0.523), CFrame.new(-0.201, 0, 0) * CFrame.Angles(0.174, 0.698, -0.524), CFrame.new(0, -0.95, -0.801) * CFrame.Angles(-1.571, -1.222, 0)},
			{{0.2, 2}, 0, CFrame.new(0.4, -0.201, 0.2) * CFrame.Angles(0.01, 0, 0.349), CFrame.new(-0.201, 0, 0) * CFrame.Angles(0.139, 0.663, -0.489), CFrame.new(0, -0.95, -0.801) * CFrame.Angles(-1.571, -1.222, 0)},
			{{0.2, 2}, 0, CFrame.new(0.4, -0.201, 0.2) * CFrame.Angles(-0.073, 0, 0.698), CFrame.new(-0.201, 0, 0) * CFrame.Angles(-0.175, 0.349, -0.262), CFrame.new(0, -0.95, -0.801) * CFrame.Angles(-1.571, 0, 0)}
		},
		Attack1 = {
			{{}, 0, CFrame.new(0.4, -0.201, 0.2) * CFrame.Angles(-0.073, 0, 0.698), CFrame.new(-0.201, 0, 0) * CFrame.Angles(-0.175, 0.349, -0.262), CFrame.new(0, -0.95, -0.801) * CFrame.Angles(-1.571, 0, 0)},
			{{0.25, 2}, 0, CFrame.new(0.4, -0.201, 0.2) * CFrame.Angles(-1.048, 0, 0.349), CFrame.new(-0.201, 0, 0) * CFrame.Angles(0.872, 0.349, 0.087), CFrame.new(0, -0.95, -0.801) * CFrame.Angles(-1.571, 0, 0)},
			{{0.15, 2}, 0, CFrame.new(0.4, -0.101, 0.1) * CFrame.Angles(-1.571, 0, -0.35), CFrame.new(-0.301, -0.301, 0.1) * CFrame.Angles(-1.048, -0.175, -0.524), CFrame.new(0, -1.201, -0.801) * CFrame.Angles(-2.095, 0, 0)},
			{{0.6, 2}, 0, CFrame.new(0.4, -0.201, 0.2) * CFrame.Angles(-0.073, 0, 0.698), CFrame.new(-0.201, 0, 0) * CFrame.Angles(-0.175, 0.349, -0.262), CFrame.new(0, -0.95, -0.801) * CFrame.Angles(-1.571, 0, 0)}
		},
		Attack2 = {
			{{}, 0, CFrame.new(0.4, -0.201, 0.2) * CFrame.Angles(-0.073, 0, 0.698), CFrame.new(-0.201, 0, 0) * CFrame.Angles(-0.175, 0.349, -0.262), CFrame.new(0, -0.95, -0.801) * CFrame.Angles(-1.571, 0, 0)},
			{{0.25, 2}, 0, CFrame.new(0.4, -0.201, 0.2) * CFrame.Angles(-0.099, 0, 0.872), CFrame.new(-0.401, 0.3, 0.1) * CFrame.Angles(1.919, 2.443, -1.222), CFrame.new(0, -0.95, -0.801) * CFrame.Angles(-1.571, 0, 0)},
			{{0.15, 2}, 0, CFrame.new(0.4, -0.201, 0.2) * CFrame.Angles(-1.048, 0, -0.524), CFrame.new(-0.5, -0.201, -0.101) * CFrame.Angles(0.523, 1.396, -0.873), CFrame.new(0, -0.95, -0.801) * CFrame.Angles(-1.571, 0, 0)},
			{{0.6, 2}, 0, CFrame.new(0.4, -0.201, 0.2) * CFrame.Angles(-0.073, 0, 0.698), CFrame.new(-0.201, 0, 0) * CFrame.Angles(-0.175, 0.349, -0.262), CFrame.new(0, -0.95, -0.801) * CFrame.Angles(-1.571, 0, 0)}
		},
		Attack3 = {
			{{}, 0, CFrame.new(0.4, -0.201, 0.2) * CFrame.Angles(-0.073, 0, 0.698), CFrame.new(-0.201, 0, 0) * CFrame.Angles(-0.175, 0.349, -0.262), CFrame.new(0, -0.95, -0.801) * CFrame.Angles(-1.571, 0, 0)},
			{{0.25, 2}, 0, CFrame.new(0.4, -0.201, 0.2) * CFrame.Angles(-1.397, 0, 0.174), CFrame.new(-0.401, -0.201, 0) * CFrame.Angles(1.396, 0.698, -1.571), CFrame.new(0, -1.3, -0.401) * CFrame.Angles(-2.444, 0, 0)},
			{{0.15, 2}, 0, CFrame.new(0.4, -0.201, 0.2) * CFrame.Angles(-1.397, 0, 0.174), CFrame.new(-0.401, 0.1, 0) * CFrame.Angles(0.349, 2.094, -0.524), CFrame.new(0, -1.3, 0.1) * CFrame.Angles(-3.84, 0, 0)},
			{{0.6, 2}, 0, CFrame.new(0.4, -0.201, 0.2) * CFrame.Angles(-0.073, 0, 0.698), CFrame.new(-0.201, 0, 0) * CFrame.Angles(-0.175, 0.349, -0.262), CFrame.new(0, -0.95, -0.801) * CFrame.Angles(-1.571, 0, 0)} --Psst. Create a dummy, try setting position and angles of limbs and the weapon, save CFrame data to code. Easy? Yes. When making a single knife tool, it was all you needed.
		}
	}
}

function Configuration.EaseIn(x)
	return math.sin(math.rad(x * 90))
end

function Configuration.CFrameTrans(GetCFrame1, GetCFrame2, GetNumber)
	local Diff2 = (GetCFrame2.p - GetCFrame1.p)
	local GetCFrame1s = (GetCFrame1 - GetCFrame1.p)
	local GetCFrame2 = (GetCFrame2 - GetCFrame2.p)
	local Diff = (GetCFrame1s:inverse() * GetCFrame2)
	local x1, y1, z1 = Diff:toEulerAnglesXYZ()
	return (GetCFrame1 + (Diff2 * GetNumber)) * An(x1 * GetNumber, y1 * GetNumber, z1 * GetNumber)
end
	
function Configuration.TransEff(x, type)
	local Types = {
		[1] = x,
		[2] = (x * x * (3 - 2 * x)),
		[3] = math.sin(math.rad(x * 90)),
		[4] = (1 - math.sin(math.rad((1 - x) * 90))),
	}
	return (Types[type] or nil)
end
	
function Configuration.NumTrans(n1, n2, x)
	return (n1 + ((n2 - n1) * x))
end

function Configuration.PlayAnimation(animname, tm) --return {Left, Right, Wep, Trans}
	local tm = math.min(1, math.max(0, tm))
	local Animd = Configuration.Animations[animname]
	if #Animd == 1 then
		return {Animd[1][3], Animd[1][4], Animd[1][5], Animd[1][2]}
	else
		local TransFrom = 1
		local TransTo = 1
		local TmLeft = tm
		for i = 2, #Animd do
			TmLeft = (TmLeft - Animd[i][1][1])
			if TmLeft <= 0 then
				TransFrom = (i - 1)
				TransTo = i
				break
			end
		end
		local TransAmm = Configuration.TransEff((Animd[TransTo][1][1] + TmLeft) / Animd[TransTo][1][1], Animd[TransTo][1][2])
		return {
			Configuration.CFrameTrans(Animd[TransFrom][3], Animd[TransTo][3], TransAmm),
			Configuration.CFrameTrans(Animd[TransFrom][4], Animd[TransTo][4], TransAmm),
			Configuration.CFrameTrans(Animd[TransFrom][5], Animd[TransTo][5], TransAmm),
			Configuration.NumTrans(Animd[TransFrom][2], Animd[TransTo][2], TransAmm)
		}
	end
end

return Configuration]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX7757547F7CF6411BA3B05D18D91441F9">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Functions</string>
					<string name="ScriptGuid">{152C164F-586D-4FEC-A605-1E48C3E713A7}</string>
					<ProtectedString name="Source"><![CDATA[--Rescripted by Luckymaxer

Players = game:GetService("Players")
Debris = game:GetService("Debris")

RbxUtility = LoadLibrary("RbxUtility")
Create = RbxUtility.Create

Functions = {}

function Functions.Clamp(Number, Min, Max)
	return math.max(math.min(Max, Number), Min)
end

function Functions.GetPercentage(Start, End, Number)
	return (((Number - Start) / (End - Start)) * 100)
end

function Functions.Round(Number, RoundDecimal)
	local WholeNumber, Decimal = math.modf(Number)
	return ((Decimal >= RoundDecimal and math.ceil(Number)) or (Decimal < RoundDecimal and math.floor(Number)))
end

function Functions.IsTeamMate(Player1, Player2)
	return (Player1 and Player2 and not Player1.Neutral and not Player2.Neutral and Player1.TeamColor == Player2.TeamColor)
end

function Functions.TagHumanoid(humanoid, player)
	local Creator_Tag = Create("ObjectValue"){
		Name = "creator",
		Value = player,
	}
	Debris:AddItem(Creator_Tag, 2)
	Creator_Tag.Parent = humanoid
end

function Functions.UntagHumanoid(humanoid)
	for i, v in pairs(humanoid:GetChildren()) do
		if v:IsA("ObjectValue") and v.Name == "creator" then
			v:Destroy()
		end
	end
end

function Functions.CheckTableForString(Table, String)
	for i, v in pairs(Table) do
		if string.find(string.lower(String), string.lower(v)) then
			return true
		end
	end
	return false
end

function Functions.CheckTableForInstance(Table, Instance)
	for i, v in pairs(Table) do
		if v == Instance then
			return true
		end
	end
	return false
end

function Functions.CheckIntangible(Hit)
	local ProjectileNames = {"Water", "Arrow", "Projectile", "Effect", "Rail", "Laser", "Bullet"}
	if Hit and Hit.Parent then
		if ((not Hit.CanCollide or Functions.CheckTableForString(ProjectileNames, Hit.Name)) and not Hit.Parent:FindFirstChild("Humanoid")) then
			return true
		end
	end
	return false
end

function Functions.CastRay(StartPos, Vec, Length, Ignore, DelayIfHit)
	local Ignore = ((type(Ignore) == "table" and Ignore) or {Ignore})
	local RayHit, RayPos, RayNormal = game:GetService("Workspace"):FindPartOnRayWithIgnoreList(Ray.new(StartPos, Vec * Length), Ignore)
	if RayHit and Functions.CheckIntangible(RayHit) then
		if DelayIfHit then
			wait()
		end
		RayHit, RayPos, RayNormal = Functions.CastRay((RayPos + (Vec * 0.01)), Vec, (Length - ((StartPos - RayPos).magnitude)), Ignore, DelayIfHit)
	end
	return RayHit, RayPos, RayNormal
end

return Functions]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
		</Item>
		<Item class="LocalScript" referent="RBX0F926C413136471B84ED22BF25B0443C">
			<Properties>
				<bool name="Disabled">true</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">LocalScript</string>
				<string name="ScriptGuid">{7B209235-702E-4802-936B-DEBF683DAC05}</string>
				<ProtectedString name="Source"><![CDATA[--Made by Luckymaxer

Tool = script.Parent
Handle = Tool:WaitForChild("Handle")

Players = game:GetService("Players")
Debris = game:GetService("Debris")
RunService = game:GetService("RunService")
ContentProvider = game:GetService("ContentProvider")

RbxUtility = LoadLibrary("RbxUtility")
Create = RbxUtility.Create

CF = CFrame.new
An = CFrame.Angles
V3 = Vector3.new

BaseUrl = "http://www.roblox.com/asset/?id="

Animations = {}
LocalObjects = {}

ServerControl = Tool:WaitForChild("ServerControl")
ClientControl = Tool:WaitForChild("ClientControl")

Rate = (1 / 60)

ToolEquipped = false
local CamWelds = {}

function SetLocalTransparencyModifier(Table)
	for i, v in pairs(LocalObjects) do
		if v == Table and (v.Object == Table.Object and v.Transparency ~= Table.Transparency) then
			v.Transparency = Table.Transparency
			return
		end
	end
	table.insert(LocalObjects, Table)
	if ObjectLocalTransparencyModifier then
		ObjectLocalTransparencyModifier:disconnect()
	end
	ObjectLocalTransparencyModifier = RunService.RenderStepped:connect(function()
		for i, v in pairs(LocalObjects) do
			if v.Object and v.Object.Parent then
				if ((not v.AutoUpdate and (v.Object.LocalTransparencyModifier == 1 or  v.Object.LocalTransparencyModifier == 0)) or v.AutoUpdate) then
					v.Object.LocalTransparencyModifier = v.Transparency
				end
			else
				table.remove(LocalObjects, i)
			end
		end
	end)
end

function ManageFirstPersonArms()
	local CurrentlyEquipped = true
	if ToolUnequipped then
		ToolUnequipped:disconnect()
	end
	ToolUnequipped = Tool.Unequipped:connect(function()
		CurrentlyEquipped = false
	end)
	Spawn(function()
		local Camera = game:GetService("Workspace").CurrentCamera
		local LeftArm = Character:FindFirstChild("Left Arm")
		local RightArm = Character:FindFirstChild("Right Arm")
		for i, v in pairs({LeftArm, RightArm}) do
			if v then
				local Arm = v:Clone()
				Arm.Name = "Part"
				Arm.Transparency = 0
				Arm.FormFactor = Enum.FormFactor.Custom
				Arm.Size = V3(0.2, 0.2, 0.2)
				Arm:ClearAllChildren()
				for ii, vv in pairs(Character:GetChildren()) do
					if vv:IsA("CharacterMesh") and string.lower(string.gsub(vv.BodyPart.Name, " ", "")) == string.lower(string.gsub(v.Name, " ", "")) then
						local Mesh = Create("SpecialMesh"){
							Name = "Mesh",
							MeshType = Enum.MeshType.FileMesh,
							MeshId = (BaseUrl .. vv.MeshId),
							TextureId = "",
							Scale = V3(1, 1, 1),
							VertexColor = V3(1, 1, 1),
							Offset = V3(0, 0, 0),
							Parent = Arm
						}
					end
				end
				if v == LeftArm then
					Arm.Name = "CamLeftArm"
					CamLeftArm = Arm
				elseif v == RightArm then
					Arm.Name = "CamRightArm"
					CamRightArm = Arm
				end
			end
		end
		CamWeapon = Handle:Clone()
		CamWeapon.Name = "CamFakeHandle"
		CamWeapon.Transparency = 0
		local CamJoints = {
			{Name = "CamLeftWeld", Part0 = Torso, Part1 = CamLeftArm},
			{Name = "CamRightWeld", Part0 = Torso, Part1 = CamRightArm},
			{Name = "CamWeapon", Part0 = CamRightArm, Part1 = CamWeapon},
		}
		for i, v in pairs(CamJoints) do
			local Joint = Create("Snap"){
				Name = "Weld",
				Part0 = v.Part0,
				Part1 = v.Part1,
				C0 = CF(0, 0, 0),
				C1 = CF(0, 0, 0),
				Parent = v.Part1,
			}
			CamWelds[i] = Joint
		end
		for i, v in pairs({CamLeftArm, CamRightArm, CamWeapon}) do
			v.LocalTransparencyModifier = 1
			v.Parent = Camera
		end
		local MoveAnimSpeed = 3
		local AimRetract = 15
		local AimAmp = 0.5
		local AimMaxChange = 4
		local AimMaxDeg = 20
		local CamOffset = (CF(0.2, -0.37, 0.91) * An(math.rad(0), math.rad(0), math.rad(0)))
		local LastP = V3()
		local MoveAmm = 0
		if ArmAlign then
			ArmAlign:disconnect()
		end
		ArmAlign = RunService.RenderStepped:connect(function()
			if not CheckIfAlive() or not ToolEquipped or not CurrentlyEquipped then
				if ArmAlign then
					ArmAlign:disconnect()
				end
				return
			end
			local Camera = game:GetService("Workspace").CurrentCamera
			local NotAllThere = false
			for i, v in pairs({CamLeftArm, CamRightArm, CamWeapon}) do
				if v and v.Parent and v:FindFirstChild("Weld") then
				else
					NotAllThere = true
				end
			end
			if not NotAllThere then
				local Delta = 0.1
				local CurP = Torso.Position
				if (CurP - LastP).Magnitude >= 0.1 then
					MoveAmm = math.min(1, MoveAmm + Delta * MoveAnimSpeed)
				else
					MoveAmm = math.max(0, MoveAmm - Delta * MoveAnimSpeed)
				end
				LastP = CurP
				
				local LastVa = 0
				local LastVa2 = 0
				local ViewVelocity = {0, 0}
				
				local TargetPosition = ((PlayerMouse and PlayerMouse.Hit.p) or nil)
				
				if TargetPosition then
					local pDistance = (Head.Position - TargetPosition).Magnitude
					pDistance = ((pDistance == 0 and 0.0001) or pDistance)
					local pHeight = (TargetPosition.Y - Head.Position.Y)
					local ViewAngle = ((pHeight ~= 0 and math.deg(math.asin(math.abs(pHeight) / pDistance)) * (math.abs(pHeight) / pHeight)) or 0)
					
					local BreatheAmp = 2
					local BreatheFreq = 0.8
					local Breathe = (math.sin(math.rad(tick() * 90 * BreatheFreq)) * BreatheAmp)
					
					local ShakeFreq = 5
					local ShakeAmp = {0.05, 0.05}
					local ArmShake = CF((math.sin(math.rad(tick() * 90 * ShakeFreq)) * MoveAmm * ShakeAmp[1]), 0, math.abs(math.sin(math.rad(tick() * 90 * ShakeFreq)) * MoveAmm * ShakeAmp[2]))
					
					local CamCF = Camera.CoordinateFrame
					local LookingAt = (CamCF * CF(0, 0, -100))
					local ViewAngle2 = math.deg(math.atan2(CamCF.p.x - LookingAt.p.x, CamCF.p.z - LookingAt.p.z)) + 180
					
					local VDelta1 = math.abs(ViewAngle - LastVa)
					local VDelta2
					local Dir1 = ((VDelta1 ~= 0 and ((ViewAngle - LastVa) / VDelta1)) or 0)
					local Dir2
					
					local vacheck = {math.abs(ViewAngle2 - LastVa2), (360 - math.abs(ViewAngle2 - LastVa2))}
					Dir2 = ((ViewAngle2 == LastVa2 and 0) or (vacheck[1] < vacheck[2] and ((ViewAngle2 - LastVa2) / vacheck[1])) or ((LastVa2 > ViewAngle2 and 1) or -1))
					VDelta2 = ((ViewAngle2 == LastVa2 and 0) or (vacheck[1] < vacheck[2] and vacheck[1]) or vacheck[2])
					LastVa = ViewAngle
					LastVa2 = ViewAngle2
					
					ViewVelocity[1] = (ViewVelocity[1] / (1 + (Delta * AimRetract)))
					ViewVelocity[2] = (ViewVelocity[2] / (1 + (Delta * AimRetract)))
					
					local Calc1 = (VDelta1 * Dir1 * AimAmp)
					if Calc1 ~= 0 then
						ViewVelocity[1] = (ViewVelocity[1] + (math.min(AimMaxChange, math.abs(Calc1)) * (Calc1 / math.abs(Calc1))))
					end
					local Calc2 = (VDelta2 * Dir2 * AimAmp)
					if Calc2 ~= 0 then
						ViewVelocity[2] = (ViewVelocity[2] + (math.min(AimMaxChange, math.abs(Calc2)) * (Calc2 / math.abs(Calc2))))
					end
					
					for i, v in pairs(ViewVelocity) do
						if v ~= 0 then
							ViewVelocity[i] = math.min(AimMaxDeg, math.abs(v)) * (math.abs(v) / v)
						end
					end
					
					CamCF = (Camera.CoordinateFrame * An(math.rad(90 + (Breathe / 2) - ViewVelocity[1]), 0, math.rad(ViewVelocity[2])) * ArmShake * CamOffset)
					
					if CurrentAnimations then
						local Objects = {CamLeftArm, CamRightArm, CamWeapon}
						local RealObjects = {Character:FindFirstChild("Left Arm"), Character:FindFirstChild("Right Arm"), Tool:FindFirstChild("FakeHandle")}
						local Offsets = {
							{Object = CamLeftArm, Offset = (Torso.CFrame:inverse() * CamCF * CF(-1.5, 0, 0) * CurrentAnimations[1] * CF(0, -0.5, 0)):inverse()},
							{Object = CamRightArm, Offset = (Torso.CFrame:inverse() * CamCF * CF(1.5, 0, 0) * CurrentAnimations[2] * CF(0, -0.5, 0)):inverse()},
							{Object = CamWeapon, Offset =  (CurrentAnimations[3] * An(90, 0, 0)):inverse()},
						}
						if (Head.Position - Camera.CoordinateFrame.p).Magnitude < 1.5 then
							for i, v in pairs(RealObjects) do
								if v then
									SetLocalTransparencyModifier({Object = v, Transparency = 1, AutoUpdate = true})
								end
							end
							for i, v in pairs(Objects) do
								if v and v.Parent then
									v.LocalTransparencyModifier = v.Transparency
								end
							end
							for i, v in pairs(Offsets) do
								if v.Object and v.Object.Parent then
									local Weld = v.Object:FindFirstChild("Weld")
									if Weld and Weld.Part0 and Weld.Part1 then
										Weld.C1 = v.Offset
									end
								end
							end
						else
							for i, v in pairs(RealObjects) do
								if v then
									SetLocalTransparencyModifier({Object = v, Transparency = v.Transparency, AutoUpdate = true})
								end
							end
							for i, v in pairs(Objects) do
								if v and v.Parent then
									v.LocalTransparencyModifier = 1
								end
							end
						end
					end
					if PlayerMouse then
						Spawn(function()
							InvokeServer("SetTarget", {TargetPosition = TargetPosition})
						end)
					end
				end
			end
		end)
		if ToolUnequipped then
			ToolUnequipped:disconnect()
		end
	end)
end

function CheckIfAlive()
	return (((Character and Character.Parent and Humanoid and Humanoid.Parent and Humanoid.Health > 0 and Head and Head.Parent and Torso and Torso.Parent and Player and Player.Parent) and true) or false)
end

function Equipped(Mouse)
	Character = Tool.Parent
	Player = Players:GetPlayerFromCharacter(Character)
	Humanoid = Character:FindFirstChild("Humanoid")
	Head = Character:FindFirstChild("Head")
	Torso = Character:FindFirstChild("Torso")
	ToolEquipped = true
	if not CheckIfAlive() then
		return
	end
	Spawn(function()
		PlayerMouse = Player:GetMouse()
		Spawn(function()
			for i, v in pairs(Tool:GetChildren()) do
				if v:IsA("Animation") then
					ContentProvider:Preload(v.AnimationId)
				end
			end
			ManageFirstPersonArms()
		end)
	end)
end

function Unequipped()
	for i, v in pairs(Animations) do
		if v and v.AnimationTrack then
			v.AnimationTrack:Stop()
		end
	end
	for i, v in pairs(CamWelds) do
		if v and v.Parent then
			v.Part0 = nil
			v.Part1 = nil
			Debris:AddItem(v, 0)
		end
	end
	for i, v in pairs({CamLeftArm, CamRightArm, CamWeapon}) do
		if v and v.Parent then
			Debris:AddItem(v, 0)
		end
	end
	if ObjectLocalTransparencyModifier then
		ObjectLocalTransparencyModifier:disconnect()
	end
	LocalObjects = {}
	Animations = {}
	ToolEquipped = false
end

function InvokeServer(mode, value)
	local ServerReturn = nil
	pcall(function()
		ServerReturn = ServerControl:InvokeServer(mode, value)
	end)
	return ServerReturn
end

function OnClientInvoke(mode, value)
	if not ToolEquipped or not CheckIfAlive() then
		return
	end
	if mode == "MousePosition" then
		return ((PlayerMouse and {Position = PlayerMouse.Hit.p, Target = PlayerMouse.Target}) or nil)
	elseif mode == "CurrentAnimation" then
		CurrentAnimations = value.Animations
	end
end

ClientControl.OnClientInvoke = OnClientInvoke
Tool.Equipped:connect(Equipped)
Tool.Unequipped:connect(Unequipped)
Tool.Unequipped:connect(Unequipped)]]></ProtectedString>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="LocalScript" referent="RBX60258A276874477CAF955E8894100309">
			<Properties>
				<bool name="Disabled">true</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">LocalScript</string>
				<string name="ScriptGuid">{1130BEAE-1A3B-43C8-9294-4FADB9D96323}</string>
				<ProtectedString name="Source"><![CDATA[--Made by Luckymaxer

Tool = script.Parent
Handle = Tool:WaitForChild("Handle")

Players = game:GetService("Players")
Debris = game:GetService("Debris")
RunService = game:GetService("RunService")
ContentProvider = game:GetService("ContentProvider")

RbxUtility = LoadLibrary("RbxUtility")
Create = RbxUtility.Create

CF = CFrame.new
An = CFrame.Angles
V3 = Vector3.new

BaseUrl = "http://www.roblox.com/asset/?id="

Animations = {}
LocalObjects = {}

ServerControl = Tool:WaitForChild("ServerControl")
ClientControl = Tool:WaitForChild("ClientControl")

Rate = (1 / 60)

ToolEquipped = false

function SetLocalTransparencyModifier(Table)
	for i, v in pairs(LocalObjects) do
		if v == Table and (v.Object == Table.Object and v.Transparency ~= Table.Transparency) then
			v.Transparency = Table.Transparency
			return
		end
	end
	table.insert(LocalObjects, Table)
	if ObjectLocalTransparencyModifier then
		ObjectLocalTransparencyModifier:disconnect()
	end
	ObjectLocalTransparencyModifier = RunService.RenderStepped:connect(function()
		for i, v in pairs(LocalObjects) do
			if v.Object and v.Object.Parent then
				if ((not v.AutoUpdate and (v.Object.LocalTransparencyModifier == 1 or  v.Object.LocalTransparencyModifier == 0)) or v.AutoUpdate) then
					v.Object.LocalTransparencyModifier = v.Transparency
				end
			else
				table.remove(LocalObjects, i)
			end
		end
	end)
end

function ManageFirstPersonArms()
	local CurrentlyEquipped = true
	if ToolUnequipped then
		ToolUnequipped:disconnect()
	end
	ToolUnequipped = Tool.Unequipped:connect(function()
		CurrentlyEquipped = false
	end)
	Spawn(function()
		local Camera = game:GetService("Workspace").CurrentCamera
		local LeftArm = Character:FindFirstChild("Left Arm")
		local RightArm = Character:FindFirstChild("Right Arm")
		for i, v in pairs({LeftArm, RightArm}) do
			if v then
				local Arm = v:Clone()
				Arm.Name = "Part"
				Arm.Transparency = 0
				Arm.FormFactor = Enum.FormFactor.Custom
				Arm.Size = V3(0.2, 0.2, 0.2)
				Arm:ClearAllChildren()
				for ii, vv in pairs(Character:GetChildren()) do
					if vv:IsA("CharacterMesh") and string.lower(string.gsub(vv.BodyPart.Name, " ", "")) == string.lower(string.gsub(v.Name, " ", "")) then
						local Mesh = Create("SpecialMesh"){
							Name = "Mesh",
							MeshType = Enum.MeshType.FileMesh,
							MeshId = (BaseUrl .. vv.MeshId),
							TextureId = "",
							Scale = V3(1, 1, 1),
							VertexColor = V3(1, 1, 1),
							Offset = V3(0, 0, 0),
							Parent = Arm
						}
					end
				end
				if v == LeftArm then
					Arm.Name = "CamLeftArm"
					CamLeftArm = Arm
				elseif v == RightArm then
					Arm.Name = "CamRightArm"
					CamRightArm = Arm
				end
			end
		end
		CamWeapon = Handle:Clone()
		CamWeapon.Name = "CamFakeHandle"
		CamWeapon.Transparency = 0
		local CamJoints = {
			{Name = "CamLeftWeld", Part0 = Torso, Part1 = CamLeftArm},
			{Name = "CamRightWeld", Part0 = Torso, Part1 = CamRightArm},
			{Name = "CamWeapon", Part0 = CamRightArm, Part1 = CamWeapon},
		}
		CamWelds = {}
		for i, v in pairs(CamJoints) do
			local Joint = Create("Snap"){
				Name = "Weld",
				Part0 = v.Part0,
				Part1 = v.Part1,
				C0 = CF(0, 0, 0),
				C1 = CF(0, 0, 0),
				Parent = v.Part1,
			}
			CamWelds[i] = Joint
		end
		for i, v in pairs({CamLeftArm, CamRightArm, CamWeapon}) do
			v.LocalTransparencyModifier = 1
			v.Parent = Camera
		end
		local MoveAnimSpeed = 3
		local AimRetract = 15
		local AimAmp = 0.5
		local AimMaxChange = 4
		local AimMaxDeg = 20
		local CamOffset = (CF(0.2, -0.37, 0.91) * An(math.rad(0), math.rad(0), math.rad(0)))
		local LastP = V3()
		local MoveAmm = 0
		if ArmAlign then
			ArmAlign:disconnect()
		end
		ArmAlign = RunService.RenderStepped:connect(function()
			if not CheckIfAlive() or not ToolEquipped or not CurrentlyEquipped then
				if ArmAlign then
					ArmAlign:disconnect()
				end
				return
			end
			local Camera = game:GetService("Workspace").CurrentCamera
			local NotAllThere = false
			for i, v in pairs({CamLeftArm, CamRightArm, CamWeapon}) do
				if v and v.Parent and v:FindFirstChild("Weld") then
				else
					NotAllThere = true
				end
			end
			if not NotAllThere then
				local Delta = 0.1
				local CurP = Torso.Position
				if (CurP - LastP).Magnitude >= 0.1 then
					MoveAmm = math.min(1, MoveAmm + Delta * MoveAnimSpeed)
				else
					MoveAmm = math.max(0, MoveAmm - Delta * MoveAnimSpeed)
				end
				LastP = CurP
				
				local LastVa = 0
				local LastVa2 = 0
				local ViewVelocity = {0, 0}
				
				local TargetPosition = ((PlayerMouse and PlayerMouse.Hit.p) or nil)
				
				if TargetPosition then
					local pDistance = (Head.Position - TargetPosition).Magnitude
					pDistance = ((pDistance == 0 and 0.0001) or pDistance)
					local pHeight = (TargetPosition.Y - Head.Position.Y)
					local ViewAngle = ((pHeight ~= 0 and math.deg(math.asin(math.abs(pHeight) / pDistance)) * (math.abs(pHeight) / pHeight)) or 0)
					
					local BreatheAmp = 2
					local BreatheFreq = 0.8
					local Breathe = (math.sin(math.rad(tick() * 90 * BreatheFreq)) * BreatheAmp)
					
					local ShakeFreq = 5
					local ShakeAmp = {0.05, 0.05}
					local ArmShake = CF((math.sin(math.rad(tick() * 90 * ShakeFreq)) * MoveAmm * ShakeAmp[1]), 0, math.abs(math.sin(math.rad(tick() * 90 * ShakeFreq)) * MoveAmm * ShakeAmp[2]))
					
					local CamCF = Camera.CoordinateFrame
					local LookingAt = (CamCF * CF(0, 0, -100))
					local ViewAngle2 = math.deg(math.atan2(CamCF.p.x - LookingAt.p.x, CamCF.p.z - LookingAt.p.z)) + 180
					
					local VDelta1 = math.abs(ViewAngle - LastVa)
					local VDelta2
					local Dir1 = ((VDelta1 ~= 0 and ((ViewAngle - LastVa) / VDelta1)) or 0)
					local Dir2
					
					local vacheck = {math.abs(ViewAngle2 - LastVa2), (360 - math.abs(ViewAngle2 - LastVa2))}
					Dir2 = ((ViewAngle2 == LastVa2 and 0) or (vacheck[1] < vacheck[2] and ((ViewAngle2 - LastVa2) / vacheck[1])) or ((LastVa2 > ViewAngle2 and 1) or -1))
					VDelta2 = ((ViewAngle2 == LastVa2 and 0) or (vacheck[1] < vacheck[2] and vacheck[1]) or vacheck[2])
					LastVa = ViewAngle
					LastVa2 = ViewAngle2
					
					ViewVelocity[1] = (ViewVelocity[1] / (1 + (Delta * AimRetract)))
					ViewVelocity[2] = (ViewVelocity[2] / (1 + (Delta * AimRetract)))
					
					local Calc1 = (VDelta1 * Dir1 * AimAmp)
					if Calc1 ~= 0 then
						ViewVelocity[1] = (ViewVelocity[1] + (math.min(AimMaxChange, math.abs(Calc1)) * (Calc1 / math.abs(Calc1))))
					end
					local Calc2 = (VDelta2 * Dir2 * AimAmp)
					if Calc2 ~= 0 then
						ViewVelocity[2] = (ViewVelocity[2] + (math.min(AimMaxChange, math.abs(Calc2)) * (Calc2 / math.abs(Calc2))))
					end
					
					for i, v in pairs(ViewVelocity) do
						if v ~= 0 then
							ViewVelocity[i] = math.min(AimMaxDeg, math.abs(v)) * (math.abs(v) / v)
						end
					end
					
					CamCF = (Camera.CoordinateFrame * An(math.rad(90 + (Breathe / 2) - ViewVelocity[1]), 0, math.rad(ViewVelocity[2])) * ArmShake * CamOffset)
					
					if CurrentAnimations then
						local Objects = {CamLeftArm, CamRightArm, CamWeapon}
						local RealObjects = {Character:FindFirstChild("Left Arm"), Character:FindFirstChild("Right Arm"), Tool:FindFirstChild("FakeHandle")}
						local Offsets = {
							{Object = CamLeftArm, Offset = (Torso.CFrame:inverse() * CamCF * CF(-1.5, 0, 0) * CurrentAnimations[1] * CF(0, -0.5, 0)):inverse()},
							{Object = CamRightArm, Offset = (Torso.CFrame:inverse() * CamCF * CF(1.5, 0, 0) * CurrentAnimations[2] * CF(0, -0.5, 0)):inverse()},
							{Object = CamWeapon, Offset =  (CurrentAnimations[3] * An(90, 0, 0)):inverse()},
						}
						if (Head.Position - Camera.CoordinateFrame.p).Magnitude < 1.5 then
							for i, v in pairs(RealObjects) do
								if v then
									SetLocalTransparencyModifier({Object = v, Transparency = 1, AutoUpdate = true})
								end
							end
							for i, v in pairs(Objects) do
								if v and v.Parent then
									v.LocalTransparencyModifier = v.Transparency
								end
							end
							for i, v in pairs(Offsets) do
								if v.Object and v.Object.Parent then
									local Weld = v.Object:FindFirstChild("Weld")
									if Weld and Weld.Part0 and Weld.Part1 then
										Weld.C1 = v.Offset
									end
								end
							end
						else
							for i, v in pairs(RealObjects) do
								if v then
									SetLocalTransparencyModifier({Object = v, Transparency = v.Transparency, AutoUpdate = true})
								end
							end
							for i, v in pairs(Objects) do
								if v and v.Parent then
									v.LocalTransparencyModifier = 1
								end
							end
						end
					end
					if PlayerMouse then
						Spawn(function()
							InvokeServer("SetTarget", {TargetPosition = TargetPosition})
						end)
					end
				end
			end
		end)
		if ToolUnequipped then
			ToolUnequipped:disconnect()
		end
	end)
end

function CheckIfAlive()
	return (((Character and Character.Parent and Humanoid and Humanoid.Parent and Humanoid.Health > 0 and Head and Head.Parent and Torso and Torso.Parent and Player and Player.Parent) and true) or false)
end

function Equipped(Mouse)
	Character = Tool.Parent
	Player = Players:GetPlayerFromCharacter(Character)
	Humanoid = Character:FindFirstChild("Humanoid")
	Head = Character:FindFirstChild("Head")
	Torso = Character:FindFirstChild("Torso")
	ToolEquipped = true
	if not CheckIfAlive() then
		return
	end
	Spawn(function()
		PlayerMouse = Player:GetMouse()
		Spawn(function()
			for i, v in pairs(Tool:GetChildren()) do
				if v:IsA("Animation") then
					ContentProvider:Preload(v.AnimationId)
				end
			end
			ManageFirstPersonArms()
		end)
	end)
end

function Unequipped()
	for i, v in pairs(Animations) do
		if v and v.AnimationTrack then
			v.AnimationTrack:Stop()
		end
	end
	for i, v in pairs(CamWelds) do
		if v and v.Parent then
			v.Part0 = nil
			v.Part1 = nil
			Debris:AddItem(v, 0)
		end
	end
	for i, v in pairs({CamLeftArm, CamRightArm, CamWeapon}) do
		if v and v.Parent then
			Debris:AddItem(v, 0)
		end
	end
	if ObjectLocalTransparencyModifier then
		ObjectLocalTransparencyModifier:disconnect()
	end
	LocalObjects = {}
	Animations = {}
	ToolEquipped = false
end

function InvokeServer(mode, value)
	local ServerReturn = nil
	pcall(function()
		ServerReturn = ServerControl:InvokeServer(mode, value)
	end)
	return ServerReturn
end

function OnClientInvoke(mode, value)
	if not ToolEquipped or not CheckIfAlive() then
		return
	end
	if mode == "MousePosition" then
		return ((PlayerMouse and {Position = PlayerMouse.Hit.p, Target = PlayerMouse.Target}) or nil)
	elseif mode == "CurrentAnimation" then
		CurrentAnimations = value.Animations
	end
end

ClientControl.OnClientInvoke = OnClientInvoke
Tool.Equipped:connect(Equipped)
Tool.Unequipped:connect(Unequipped)
Tool.Unequipped:connect(Unequipped)]]></ProtectedString>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="LocalScript" referent="RBX3A96D653ABA349BEB745F0B6B1442124">
			<Properties>
				<bool name="Disabled">true</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">MouseIcon</string>
				<string name="ScriptGuid">{E8C3CF67-FC58-45B8-BF7E-7F9DAF0D2E8B}</string>
				<ProtectedString name="Source"><![CDATA[--Made by Luckymaxer

Mouse_Icon = "rbxasset://textures/GunCursor.png"
Reloading_Icon = "rbxasset://textures/GunWaitCursor.png"

Tool = script.Parent

Mouse = nil

function UpdateIcon()
	if Mouse then
		Mouse.Icon = Tool.Enabled and Mouse_Icon or Reloading_Icon
	end
end

function OnEquipped(ToolMouse)
	Mouse = ToolMouse
	UpdateIcon()
end

function OnChanged(Property)
	if Property == "Enabled" then
		UpdateIcon()
	end
end

Tool.Equipped:connect(OnEquipped)
Tool.Changed:connect(OnChanged)
]]></ProtectedString>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
	</Item>
</roblox>