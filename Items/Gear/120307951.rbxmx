<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Tool" referent="RBX0">
		<Properties>
			<bool name="CanBeDropped">true</bool>
			<bool name="Enabled">true</bool>
			<CoordinateFrame name="Grip">
				<X>0</X>
				<Y>0</Y>
				<Z>0.25</Z>
				<R00>1</R00>
				<R01>0</R01>
				<R02>0</R02>
				<R10>0</R10>
				<R11>1</R11>
				<R12>0</R12>
				<R20>0</R20>
				<R21>0</R21>
				<R22>1</R22>
			</CoordinateFrame>
			<string name="Name">Minion</string>
			<Content name="TextureId"><url>http://www.roblox.com/asset/?id=119464558</url></Content>
			<string name="ToolTip"></string>
		</Properties>
		<Item class="Part" referent="RBX1">
			<Properties>
				<bool name="Anchored">false</bool>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">0</token>
				<token name="BottomSurfaceInput">0</token>
				<int name="BrickColor">194</int>
				<CoordinateFrame name="CFrame">
					<X>38.4600639</X>
					<Y>36.3272057</Y>
					<Z>-2.44552326</Z>
					<R00>-0.916090667</R00>
					<R01>0.0272369981</R01>
					<R02>-0.400042236</R02>
					<R10>0.0697025657</R10>
					<R11>0.993317127</R11>
					<R12>-0.091987066</R12>
					<R20>0.394863278</R20>
					<R21>-0.11215201</R21>
					<R22>-0.911868274</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<float name="Elasticity">0.5</float>
				<float name="Friction">0.300000012</float>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">true</bool>
				<token name="Material">256</token>
				<string name="Name">Handle</string>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">0</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<token name="formFactorRaw">3</token>
				<token name="shape">1</token>
				<Vector3 name="size">
					<X>0.920000494</X>
					<Y>2.5800004</Y>
					<Z>0.730001032</Z>
				</Vector3>
			</Properties>
			<Item class="SpecialMesh" referent="RBX2">
				<Properties>
					<token name="LODX">2</token>
					<token name="LODY">2</token>
					<Content name="MeshId"><url>http://www.roblox.com/asset/?id=119447056</url></Content>
					<token name="MeshType">5</token>
					<string name="Name">Mesh</string>
					<Vector3 name="Offset">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<Vector3 name="Scale">
						<X>1.21500003</X>
						<Y>1.21500003</Y>
						<Z>1.21500003</Z>
					</Vector3>
					<Content name="TextureId"><url>http://www.roblox.com/asset/?id=119444340</url></Content>
					<Vector3 name="VertexColor">
						<X>1</X>
						<Y>1</Y>
						<Z>1</Z>
					</Vector3>
				</Properties>
			</Item>
		</Item>
		<Item class="LocalScript" referent="RBX3">
			<Properties>
				<bool name="Disabled">true</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Local Gui</string>
				<ProtectedString name="Source">local Tool = script.Parent

local sg = nil
local frame = nil

local stillEquipped = false

local function onEquippedLocal(mouse)
&#9;stillEquipped = true

&#9;local vPlayer = game.Players.LocalPlayer
&#9;local playerGui = vPlayer:FindFirstChild(&quot;PlayerGui&quot;)
&#9;if playerGui and playerGui:FindFirstChild(&quot;PetGui&quot;) == nil then
&#9;&#9;sg = Instance.new(&quot;ScreenGui&quot;)
&#9;&#9;sg.Name = &quot;PetGui&quot;
&#9;&#9;sg.Parent = playerGui

&#9;&#9;frame = Instance.new(&quot;Frame&quot;)
&#9;&#9;frame.Parent = sg
&#9;&#9;frame.Style = Enum.FrameStyle.RobloxRound
&#9;&#9;frame.Size = UDim2.new(0, 120, 0, 30)
&#9;&#9;frame.Position = UDim2.new(0.5, -60, 1, -130)

&#9;&#9;local genericTextLabel = Instance.new(&quot;TextLabel&quot;)
&#9;&#9;genericTextLabel.BackgroundTransparency = 1.0
&#9;&#9;genericTextLabel.Size = UDim2.new(1, 0, 1, 0)
&#9;&#9;genericTextLabel.Visible = true
&#9;&#9;genericTextLabel.ZIndex = 10
&#9;&#9;genericTextLabel.FontSize = Enum.FontSize.Size10
&#9;&#9;genericTextLabel.Font = Enum.Font.Legacy
&#9;&#9;genericTextLabel.TextColor3 = Color3.new(1, 0, 1)
&#9;&#9;genericTextLabel.TextXAlignment = Enum.TextXAlignment.Center
&#9;&#9;genericTextLabel.TextYAlignment = Enum.TextYAlignment.Top
&#9;&#9;genericTextLabel.Parent = frame
&#9;&#9;genericTextLabel.Text = &quot;Click to call Crash!&quot;
&#9;end

&#9;if not mouse then return end

&#9;while stillEquipped do
&#9;&#9;mouse.Icon = &quot;rbxasset://textures\\GunCursor.png&quot;
&#9;&#9;while Tool.Enabled and stillEquipped do
&#9;&#9;&#9;wait(0.01)
&#9;&#9;end
&#9;&#9;mouse.Icon = &quot;rbxasset://textures\\GunWaitCursor.png&quot;
&#9;&#9;while not Tool.Enabled and stillEquipped do
&#9;&#9;&#9;wait(0.01)
&#9;&#9;end
&#9;end
end

local function onActivatedLocal()
&#9;if frame and frame:FindFirstChild(&quot;TextLabel&quot;) then
&#9;&#9;frame.Size = UDim2.new(0, 300, 0, 30)
&#9;&#9;frame.Position = UDim2.new(0.5, -150, 1, -130)
&#9;&#9;frame.TextLabel.Text = &quot;Click players to see Crash do something crazy!&quot;
&#9;end
end

local function onUnequippedLocal()
&#9;if sg then sg:Remove() end
&#9;stillEquipped = false
end

Tool.Equipped:connect(onEquippedLocal)
Tool.Activated:connect(onActivatedLocal)
Tool.Unequipped:connect(onUnequippedLocal)
</ProtectedString>
			</Properties>
		</Item>
		<Item class="Script" referent="RBX4">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">PetToolScript</string>
				<ProtectedString name="Source">-----------------
--| Constants |--
-----------------

local COOLDOWN = 0.5 --TODO: 4 -- Seconds until Tool can be used again
local TIME_TO_LIVE = 300 -- Seconds until the pet is destroyed
local RESPAWN_TIME = 4 -- Seconds until pet can be re-summoned (only after death)

--------------------
--| WaitForChild |--
--------------------

-- Waits for parent.child to exist, then returns it
local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end

-----------------
--| Variables |--
-----------------

local InsertService = Game:GetService(&apos;InsertService&apos;)
local DebrisService = Game:GetService(&apos;Debris&apos;)
local PlayersService = Game:GetService(&apos;Players&apos;)

local Tool = script.Parent
local ToolHandle = Tool.Handle

local AiScript = WaitForChild(script, &apos;CrashAi&apos;)
local OwnerTag = WaitForChild(AiScript, &apos;Owner&apos;)

local BaseAniScript = WaitForChild(script,&apos;Animate&apos;)
local HealthRegenScript = WaitForChild(script,&apos;HealthRegenerationScript&apos;)
local SoundScript = WaitForChild(script,&apos;Sound&apos;)

local SummonSound --TODO: = WaitForChild(ToolHandle, &apos;Laugh1&apos;)

local AnimationScript = WaitForChild(Tool, &apos;PetAnimation&apos;)
local PetObject = WaitForChild(AnimationScript, &apos;Pet&apos;)

local MyModel = nil
local MyTorso = nil
local MyHumanoid = nil

local Pet = nil
local AnimationScriptClone = nil

local Sounds = {}
for _,i in pairs(script:GetChildren()) do
&#9;if i:IsA(&apos;Sound&apos;) then
&#9;&#9;table.insert(Sounds,i)
&#9;end
end

-----------------
--| Functions |--
-----------------

local function OnEquipped()
&#9;MyModel = Tool.Parent
&#9;MyTorso = MyModel:FindFirstChild(&apos;Torso&apos;)
&#9;MyHumanoid = MyModel:FindFirstChild(&apos;Humanoid&apos;)
&#9;OwnerTag.Value = MyModel
end


local function GenerateCrash()

&#9;local Crash = Instance.new(&quot;Model&quot;)
&#9;Crash.Name = &quot;Minion&quot;

&#9;&#9;local LeftArm = Instance.new(&quot;Part&quot;)
&#9;&#9;LeftArm.Anchored = false
&#9;&#9;LeftArm.CanCollide = false
&#9;&#9;LeftArm.TopSurface = Enum.SurfaceType.Smooth
&#9;&#9;LeftArm.Parent = Crash
&#9;&#9;LeftArm.Name = &quot;Left Arm&quot;
&#9;&#9;LeftArm.FormFactor = &apos;Custom&apos;
&#9;&#9;LeftArm.Size = Vector3.new(0.48599997162819, 1.0, 0.48599997162819)
&#9;&#9;LeftArm.CFrame = CFrame.new(39.526447296143, 1.8573211431503, -31.007932662964, 0.99446070194244, -0.0093411989510059, 0.1046929359436, -3.8847058903002e-009, 0.99604308605194, 0.088871710002422, -0.10510884225369, -0.088379420340061, 0.99052572250366)
&#9;&#9;LeftArm.BottomSurface = Enum.SurfaceType.Smooth
&#9;&#9;LeftArm.Locked = false
&#9;&#9;LeftArm.Position = Vector3.new(39.526447296143, 1.8573211431503, -31.007932662964)

&#9;&#9;&#9;local Mesh = Instance.new(&quot;SpecialMesh&quot;)
&#9;&#9;&#9;Mesh.Scale = Vector3.new(1.1, 1.1, 1.1)
&#9;&#9;&#9;Mesh.MeshId = &quot;http://www.roblox.com/asset/?id=119448714&quot;
&#9;&#9;&#9;Mesh.TextureId = &quot;http://www.roblox.com/asset/?id=119444340&quot;
&#9;&#9;&#9;Mesh.Parent = LeftArm
&#9;&#9;
&#9;&#9;local Head = Instance.new(&quot;Part&quot;)
&#9;&#9;Head.Anchored = false
&#9;&#9;Head.TopSurface = Enum.SurfaceType.Smooth
&#9;&#9;Head.Parent = Crash
&#9;&#9;Head.Name = &quot;Head&quot;
&#9;&#9;Head.Transparency = 1
&#9;&#9;Head.FormFactor = &apos;Custom&apos;
&#9;&#9;Head.Size = Vector3.new(0,0,0)--Vector3.new(0.97200006246567, 0.97200006246567, 0.97200006246567)
&#9;&#9;Head.CFrame = CFrame.new(40.201114654541, 3.1295635700226, -31.242385864258, 0.99446070194244, 2.3461873788949e-018, 0.10510884225369, -2.5434017125882e-018, 1, 1.7422487515995e-018, -0.10510884225369, -1.999932056022e-018, 0.99446070194244)
&#9;&#9;Head.BottomSurface = Enum.SurfaceType.Smooth
&#9;&#9;Head.Locked = false
&#9;&#9;Head.Position = Vector3.new(40.201114654541, 3.1295635700226, -31.242385864258)
&#9;&#9;&#9;
&#9;&#9;&#9;local CrashGui = Instance.new(&quot;BillboardGui&quot;)
&#9;&#9;&#9;CrashGui.Active = false
&#9;&#9;&#9;CrashGui.Name = &quot;CrashGui&quot;
&#9;&#9;&#9;CrashGui.Parent = Head
&#9;&#9;&#9;CrashGui.StudsOffset = Vector3.new(0, 3.5, 0)
&#9;&#9;&#9;CrashGui.AlwaysOnTop = true
&#9;&#9;&#9;CrashGui.Size = UDim2.new(1, 0, 1, 0)

&#9;&#9;&#9;&#9;local CB = Instance.new(&quot;ImageLabel&quot;)
&#9;&#9;&#9;&#9;CB.Active = false
&#9;&#9;&#9;&#9;CB.Parent = CrashGui
&#9;&#9;&#9;&#9;CB.Image = &quot;http://www.roblox.com/Asset?ID=119803178&quot;
&#9;&#9;&#9;&#9;CB.ZIndex = 9
&#9;&#9;&#9;&#9;CB.Size = UDim2.new(4, 0, 4, 0)
&#9;&#9;&#9;&#9;CB.Draggable = false
&#9;&#9;&#9;&#9;CB.ClipsDescendants = false
&#9;&#9;&#9;&#9;CB.Transparency = 1
&#9;&#9;&#9;&#9;CB.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;CB.Position = UDim2.new(-1.5, 0, 0, 0)
&#9;&#9;&#9;&#9;CB.Name = &quot;C&amp;B&quot;

&#9;&#9;&#9;&#9;
&#9;&#9;&#9;game.Debris:AddItem(CrashGui,5)

&#9;&#9;local RightArm = Instance.new(&quot;Part&quot;)
&#9;&#9;RightArm.Anchored = false
&#9;&#9;RightArm.CanCollide = false
&#9;&#9;RightArm.TopSurface = Enum.SurfaceType.Smooth
&#9;&#9;RightArm.Parent = Crash
&#9;&#9;RightArm.Name = &quot;Right Arm&quot;
&#9;&#9;RightArm.FormFactor = &apos;Custom&apos;
&#9;&#9;RightArm.Size = Vector3.new(0.48600003123283, 1.0, 0.48600003123283)
&#9;&#9;RightArm.CFrame = CFrame.new(40.906513214111, 1.8496809005737, -31.232267379761, 0.99446070194244, 0.0093412064015865, 0.1046929359436, -3.8847058903002e-009, 0.99604308605194, -0.088871710002422, -0.10510884225369, 0.088379420340061, 0.99052572250366)
&#9;&#9;RightArm.BottomSurface = Enum.SurfaceType.Smooth
&#9;&#9;RightArm.Locked = false
&#9;&#9;RightArm.Position = Vector3.new(40.906513214111, 1.8496809005737, -31.232267379761)

&#9;&#9;&#9;local Mesh2 = Instance.new(&quot;SpecialMesh&quot;)
&#9;&#9;&#9;Mesh2.Scale = Vector3.new(1.1, 1.1, 1.1)
&#9;&#9;&#9;Mesh2.MeshId = &quot;http://www.roblox.com/asset/?id=119448556&quot;
&#9;&#9;&#9;Mesh2.TextureId = &quot;http://www.roblox.com/asset/?id=119444340&quot;
&#9;&#9;&#9;Mesh2.Parent = RightArm
&#9;&#9;&#9;Mesh2.MeshType = Enum.MeshType.FileMesh

&#9;&#9;&#9;local Swoosh = Instance.new(&quot;Sound&quot;)
&#9;&#9;&#9;Swoosh.Parent = RightArm
&#9;&#9;&#9;Swoosh.Name = &quot;Swoosh&quot;
&#9;&#9;&#9;Swoosh.Volume = 0.69999998807907
&#9;&#9;&#9;Swoosh.SoundId = &quot;rbxasset://sounds/swoosh.wav&quot;
&#9;&#9;&#9;Swoosh.Looped = false
&#9;&#9;&#9;Swoosh.PlayOnRemove = false

&#9;&#9;local RightLeg = Instance.new(&quot;Part&quot;)
&#9;&#9;RightLeg.Anchored = false
&#9;&#9;RightLeg.CanCollide = false
&#9;&#9;RightLeg.TopSurface = Enum.SurfaceType.Smooth
&#9;&#9;RightLeg.Parent = Crash
&#9;&#9;RightLeg.Name = &quot;Right Leg&quot;
&#9;&#9;RightLeg.FormFactor = &apos;Custom&apos;
&#9;&#9;RightLeg.Size = Vector3.new(0.6075000166893, 1.05, 0.85050004720688)
&#9;&#9;RightLeg.CFrame = CFrame.new(40.442035675049, 0.81883311271667, -31.159261703491, 0.99446070194244, -0.0093412064015865, 0.1046929359436, 3.8847058903002e-009, 0.99604308605194, 0.088871710002422, -0.10510884225369, -0.088379420340061, 0.99052572250366)
&#9;&#9;RightLeg.BottomSurface = Enum.SurfaceType.Smooth
&#9;&#9;RightLeg.Locked = false
&#9;&#9;RightLeg.Position = Vector3.new(40.442035675049, 0.81883311271667, -31.159261703491)

&#9;&#9;&#9;local Mesh3 = Instance.new(&quot;SpecialMesh&quot;)
&#9;&#9;&#9;Mesh3.Scale = Vector3.new(1.1, 1.1, 1.1)
&#9;&#9;&#9;Mesh3.MeshId = &quot;http://www.roblox.com/asset/?id=119448742&quot;
&#9;&#9;&#9;Mesh3.TextureId = &quot;http://www.roblox.com/asset/?id=119444340&quot;
&#9;&#9;&#9;Mesh3.Parent = RightLeg
&#9;&#9;&#9;Mesh3.MeshType = Enum.MeshType.FileMesh

&#9;&#9;local LeftLeg = Instance.new(&quot;Part&quot;)
&#9;&#9;LeftLeg.Anchored = false
&#9;&#9;LeftLeg.CanCollide = false
&#9;&#9;LeftLeg.TopSurface = Enum.SurfaceType.Smooth
&#9;&#9;LeftLeg.Parent = Crash
&#9;&#9;LeftLeg.Name = &quot;Left Leg&quot;
&#9;&#9;LeftLeg.FormFactor = &apos;Custom&apos;
&#9;&#9;LeftLeg.Size = Vector3.new(0.6075000166893, 1.05, 0.85049992799759)
&#9;&#9;LeftLeg.CFrame = CFrame.new(39.95832824707, 0.81884551048279, -31.227575302124, 0.99446070194244, 0.0093411989510059, 0.1046929359436, 3.8847058903002e-009, 0.99604308605194, -0.088871710002422, -0.10510884225369, 0.088379420340061, 0.99052572250366)
&#9;&#9;LeftLeg.BottomSurface = Enum.SurfaceType.Smooth
&#9;&#9;LeftLeg.Locked = false
&#9;&#9;LeftLeg.Position = Vector3.new(39.95832824707, 0.81884551048279, -31.227575302124)

&#9;&#9;&#9;local Mesh4 = Instance.new(&quot;SpecialMesh&quot;)
&#9;&#9;&#9;Mesh4.Scale = Vector3.new(1.1, 1.1, 1.1)
&#9;&#9;&#9;Mesh4.MeshId = &quot;http://www.roblox.com/asset/?id=119448654&quot;
&#9;&#9;&#9;Mesh4.TextureId = &quot;http://www.roblox.com/asset/?id=119444340&quot;
&#9;&#9;&#9;Mesh4.Parent = LeftLeg
&#9;&#9;&#9;Mesh4.MeshType = Enum.MeshType.FileMesh

&#9;&#9;local Sound6 = Instance.new(&quot;Script&quot;)
&#9;&#9;Sound6.Parent = Crash
&#9;&#9;Sound6.Name = &quot;Sound&quot;
&#9;&#9;Sound6.Disabled = false


&#9;&#9;local Torso = Instance.new(&quot;Part&quot;)
&#9;&#9;Torso.Anchored = false
&#9;&#9;Torso.TopSurface = Enum.SurfaceType.Smooth
&#9;&#9;Torso.Parent = Crash
&#9;&#9;Torso.Name = &quot;Torso&quot;
&#9;&#9;Torso.FormFactor = &apos;Custom&apos;
&#9;&#9;Torso.Size = Vector3.new(1.0934998989105, 1.0, 0.72900003194809)
&#9;&#9;Torso.CFrame = CFrame.new(40.208778381348, 2.0555002689362, -31.169893264771, 0.99446070194244, 2.3461873788949e-018, 0.10510884225369, -2.5434017125882e-018, 1, 1.7422487515995e-018, -0.10510884225369, -1.999932056022e-018, 0.99446070194244)
&#9;&#9;Torso.BottomSurface = Enum.SurfaceType.Smooth
&#9;&#9;Torso.Locked = false
&#9;&#9;Torso.Position = Vector3.new(40.208778381348, 2.0555002689362, -31.169893264771)

&#9;&#9;&#9;local Mesh1 = Instance.new(&quot;SpecialMesh&quot;)
&#9;&#9;&#9;Mesh1.Scale = Vector3.new(1.1, 1.1, 1.1)
&#9;&#9;&#9;Mesh1.MeshId = &quot;http://www.roblox.com/asset/?id=119448208&quot;
&#9;&#9;&#9;Mesh1.TextureId = &quot;http://www.roblox.com/asset/?id=119444340&quot;
&#9;&#9;&#9;Mesh1.Parent = Torso
&#9;&#9;&#9;Mesh1.MeshType = Enum.MeshType.FileMesh

&#9;&#9;&#9;local RightHip = Instance.new(&quot;Motor6D&quot;)
&#9;&#9;&#9;RightHip.part1 = RightLeg
&#9;&#9;&#9;RightHip.MaxVelocity = 0.10000000149012
&#9;&#9;&#9;RightHip.DesiredAngle = -0.088989116251469
&#9;&#9;&#9;RightHip.CurrentAngle = -0.088989116251469
&#9;&#9;&#9;RightHip.Parent = Torso
&#9;&#9;&#9;RightHip.Name = &quot;Right Hip&quot;
&#9;&#9;&#9;RightHip.Part1 = RightLeg
&#9;&#9;&#9;RightHip.C1 = CFrame.new(0, .5, 0, -4.3711388286738e-008, 0, 1, 0, 1, 0, -1, 0, -4.3711388286738e-008)
&#9;&#9;&#9;RightHip.C0 = CFrame.new(0.23084968328476, -0.8, -0.024299010634422, -4.3711388286738e-008, 0, 1, 0, 1, 0, -1, 0, -4.3711388286738e-008)
&#9;&#9;&#9;RightHip.Part0 = Torso

&#9;&#9;&#9;local LeftHip = Instance.new(&quot;Motor6D&quot;)
&#9;&#9;&#9;LeftHip.part1 = LeftLeg
&#9;&#9;&#9;LeftHip.MaxVelocity = 0.10000000149012
&#9;&#9;&#9;LeftHip.DesiredAngle = -0.088989116251469
&#9;&#9;&#9;LeftHip.CurrentAngle = -0.088989116251469
&#9;&#9;&#9;LeftHip.Parent = Torso
&#9;&#9;&#9;LeftHip.Name = &quot;Left Hip&quot;
&#9;&#9;&#9;LeftHip.Part1 = LeftLeg
&#9;&#9;&#9;LeftHip.C1 = CFrame.new(0, 0.5, 0, -4.3711388286738e-008, 0, -1, 0, 1, 0, 1, 0, -4.3711388286738e-008)
&#9;&#9;&#9;LeftHip.C0 = CFrame.new(-0.24299995601177, -0.8, -0.024299010634422, -4.3711388286738e-008, 0, -1, 0, 1, 0, 1, 0, -4.3711388286738e-008)
&#9;&#9;&#9;LeftHip.Part0 = Torso

&#9;&#9;&#9;local Neck = Instance.new(&quot;Motor6D&quot;)
&#9;&#9;&#9;Neck.part1 = Head
&#9;&#9;&#9;Neck.MaxVelocity = 0.10000000149012
&#9;&#9;&#9;Neck.Parent = Torso
&#9;&#9;&#9;Neck.Name = &quot;Neck&quot;
&#9;&#9;&#9;Neck.Part1 = Head
&#9;&#9;&#9;Neck.C1 = CFrame.new(0, 0, 0, 1, 0, 0, 0, -4.3711388286738e-008, -1, 0, 1, -4.3711388286738e-008)
&#9;&#9;&#9;Neck.C0 = CFrame.new(0, 1.0740633010864, -0.072897039353848, 1, 0, 0, 0, -4.3711388286738e-008, -1, 0, 1, -4.3711388286738e-008)
&#9;&#9;&#9;Neck.Part0 = Torso

&#9;&#9;&#9;local RightShoulder = Instance.new(&quot;Motor6D&quot;)
&#9;&#9;&#9;RightShoulder.part1 = RightArm
&#9;&#9;&#9;RightShoulder.MaxVelocity = 0.5
&#9;&#9;&#9;RightShoulder.DesiredAngle = 0.088989116251469
&#9;&#9;&#9;RightShoulder.CurrentAngle = 0.088989116251469
&#9;&#9;&#9;RightShoulder.Parent = Torso
&#9;&#9;&#9;RightShoulder.Name = &quot;Right Shoulder&quot;
&#9;&#9;&#9;RightShoulder.Part1 = RightArm
&#9;&#9;&#9;RightShoulder.C1 = CFrame.new(0, -.02, -0.025000000372529, -4.3711388286738e-008, 0, 1, 0, 1, 0, -1, 0, -4.3711388286738e-008)
&#9;&#9;&#9;RightShoulder.C0 = CFrame.new(0.55, -0.7, .023601150140166, -4.3711388286738e-008, 0, 1, 0, 1, 0, -1, 0, -4.3711388286738e-008)
&#9;&#9;&#9;RightShoulder.Part0 = Torso

&#9;&#9;&#9;local LeftShoulder = Instance.new(&quot;Motor6D&quot;)
&#9;&#9;&#9;LeftShoulder.part1 = LeftArm
&#9;&#9;&#9;LeftShoulder.MaxVelocity = 0.5
&#9;&#9;&#9;LeftShoulder.DesiredAngle = 0.088989116251469
&#9;&#9;&#9;LeftShoulder.CurrentAngle = 0.088989116251469
&#9;&#9;&#9;LeftShoulder.Parent = Torso
&#9;&#9;&#9;LeftShoulder.Name = &quot;Left Shoulder&quot;
&#9;&#9;&#9;LeftShoulder.Part1 = LeftArm
&#9;&#9;&#9;LeftShoulder.C1 = CFrame.new(0, -.02, -0.025000000372529, -4.3711388286738e-008, 0, -1, 0, 1, 0, 1, 0, -4.3711388286738e-008)
&#9;&#9;&#9;LeftShoulder.C0 = CFrame.new(-0.55, -0.7, 0.027249908074737, -4.3711388286738e-008, 0, -1, 0, 1, 0, 1, 0, -4.3711388286738e-008)
&#9;&#9;&#9;LeftShoulder.Part0 = Torso
&#9;&#9;&#9;
&#9;for _,i in pairs(Sounds) do
&#9;&#9;local tsound = i:Clone()
&#9;&#9;tsound.Parent = Torso
&#9;end

&#9;return Crash

end

local function Summon()
&#9;if not MyTorso or not MyHumanoid then return end

&#9;

&#9;Pet = GenerateCrash()

&#9;if Pet then
&#9;&#9;DebrisService:AddItem(Pet, TIME_TO_LIVE) -- Make sure it will get deleted

&#9;&#9;local humanoid = Instance.new(&apos;Humanoid&apos;)
&#9;&#9;humanoid.MaxHealth = 1000
&#9;&#9;humanoid.Health = 1000
&#9;&#9;humanoid.WalkSpeed = 16
&#9;&#9;humanoid.Parent = Pet
&#9;&#9;
&#9;&#9;local nanimate = BaseAniScript:Clone()
&#9;&#9;nanimate.Parent = Pet
&#9;&#9;nanimate.Disabled = false&#9;
&#9;&#9;
&#9;&#9;Pet.Parent = Workspace
&#9;&#9;ToolHandle.Transparency = 1.0

&#9;&#9;local torso = WaitForChild(Pet, &apos;Torso&apos;)
&#9;&#9;torso.Anchored = false

&#9;&#9;-- Play the summoning sound
&#9;&#9;if SummonSound then SummonSound:Play() end

&#9;&#9;-- Send pet object to AnimationScript
&#9;&#9;PetObject.Value = Pet

&#9;&#9;-- Clone AnimationScript to MyModel
&#9;&#9;local animationScriptClone = AnimationScript:Clone()
&#9;&#9;AnimationScriptClone = animationScriptClone
&#9;&#9;DebrisService:AddItem(animationScriptClone, TIME_TO_LIVE)
&#9;&#9;animationScriptClone.Parent = MyModel
&#9;&#9;animationScriptClone.Disabled = false

&#9;&#9;-- Clone AiScript to Pet
&#9;&#9;local aiScriptClone = AiScript:Clone()
&#9;&#9;aiScriptClone.Parent = Pet
&#9;&#9;aiScriptClone.Disabled = false

&#9;&#9;-- On Pet death, clean up and show the handle
&#9;&#9;humanoid.Died:connect(function()
&#9;&#9;&#9;if AnimationScriptClone then AnimationScriptClone:Destroy() end
&#9;&#9;&#9;DebrisService:AddItem(Pet, RESPAWN_TIME)
&#9;&#9;&#9;wait(RESPAWN_TIME)
&#9;&#9;&#9;ToolHandle.Transparency = 0.0
&#9;&#9;end)

&#9;&#9;-- After TIME_TO_LIVE, show the handle
&#9;&#9;coroutine.resume(coroutine.create(function()
&#9;&#9;&#9;wait(TIME_TO_LIVE + 0.1)
&#9;&#9;&#9;if not Pet:FindFirstChild(&apos;Humanoid&apos;) then
&#9;&#9;&#9;&#9;ToolHandle.Transparency = 0.0
&#9;&#9;&#9;end
&#9;&#9;end))

&#9;&#9;-- Health has problems being set directly
&#9;&#9;Delay(5, function() if humanoid then humanoid:TakeDamage(-900) end end)
&#9;&#9;--[[Spawn(function()
&#9;&#9;&#9;while Pet and humanoid do
&#9;&#9;&#9;&#9;humanoid.MaxHealth = 1000
&#9;&#9;&#9;&#9;humanoid.Health = 1000
&#9;&#9;&#9;&#9;wait(1)
&#9;&#9;&#9;end
&#9;&#9;end)]]

&#9;&#9;Pet:MoveTo(MyTorso.Position + Vector3.new(math.random(-3, 3), 0, math.random(-3, 3)))
&#9;end
end

local function OnActivated()
&#9;if not Tool.Enabled or not MyTorso or not MyHumanoid then return end

&#9;Tool.Enabled = false

&#9;if not Pet or not Pet.Parent then
&#9;&#9;Summon()
&#9;end

&#9;-- Raycast to click location for ClickTarget setting
&#9;local target = MyHumanoid.TargetPoint
&#9;local direction = (target - MyTorso.Position).unit
&#9;local hit = Game.Workspace:FindPartOnRay(Ray.new(MyTorso.Position, direction * 150), MyModel)
&#9;if hit and Pet and Pet:FindFirstChild(&apos;ClickTarget&apos;) then
&#9;&#9;local clickedHumanoid = hit.Parent:FindFirstChild(&apos;Humanoid&apos;)
&#9;&#9;if clickedHumanoid and clickedHumanoid.Health &gt; 0 then
&#9;&#9;&#9;if Pet.ClickTarget.Value == clickedHumanoid then
&#9;&#9;&#9;&#9;Pet.ClickTarget.Value = nil -- Ensures a changed event
&#9;&#9;&#9;end
&#9;&#9;&#9;Pet.ClickTarget.Value = clickedHumanoid
&#9;&#9;&#9;wait(COOLDOWN) -- Only wait if they clicked a valid target
&#9;&#9;else
&#9;&#9;&#9;Pet.ClickTarget.Value = nil
&#9;&#9;end
&#9;end

&#9;Tool.Enabled = true
end

local function OnUnequipped()
&#9;if Pet then Pet:Destroy() end
&#9;if SummonSound then SummonSound:Stop() end
&#9;if AnimationScriptClone then AnimationScriptClone:Destroy() end
&#9;ToolHandle.Transparency = 0.0
end

--------------------
--| Script Logic |--
--------------------

Tool.Equipped:connect(OnEquipped)
Tool.Unequipped:connect(OnUnequipped)
Tool.Activated:connect(OnActivated)
</ProtectedString>
			</Properties>
			<Item class="Script" referent="RBX5">
				<Properties>
					<bool name="Disabled">true</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">CrashAi</string>
					<ProtectedString name="Source">-----------------
--| Constants |--
-----------------

local RBX_GRAVITY = -9.81 * 20
local ONE_STEP = .5--1 / 30
local OFFSET = Vector3.new(5, 0, 5) -- Distance from player or target
local MAX_DISTANCE = 240 -- The pet will stay within this distance of player
local JARS_TO_THROW = 3 -- Number of jars to throw
local DYNAMITE_TO_THROW = 1 -- Number of dynamite to throw
local MIN_GAP = 1.5 -- Seconds that must pass before the next mode can begin
local LAUNCH_SPEED = 150

--------------------
--| WaitForChild |--
--------------------

-- Waits for parent.child to exist, then returns it
local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do print(&apos;waiting for &apos;..childName) parent.ChildAdded:wait() end
&#9;return parent[childName]
end

-----------------
--| Variables |--
-----------------

local DebrisService = Game:GetService(&apos;Debris&apos;)

local Pet = script.Parent
local PetHumanoid = WaitForChild(Pet, &apos;Humanoid&apos;)

local Torso = Pet:WaitForChild(&apos;Torso&apos;)
local Sounds ={}

local LastSoundTime = 0

local MyModel = WaitForChild(script, &apos;Owner&apos;).Value
local MyHumanoid = WaitForChild(MyModel, &apos;Humanoid&apos;)


local RightArm = WaitForChild(Pet, &apos;Right Arm&apos;)
local SwooshSound = WaitForChild(RightArm, &apos;Swoosh&apos;)

local AnimationScript = WaitForChild(MyModel, &apos;PetAnimation&apos;)
local AnimationToPlayObject = WaitForChild(AnimationScript, &apos;AnimationToPlay&apos;)

local PetMode = 0
local StopTime = time()


-----------------
--| Functions |--
-----------------

function GenerateBanana()
&#9;local Part = Instance.new(&quot;Part&quot;)
&#9;Part.Name = &apos;Banana&apos;
&#9;--Part.CanCollide = false
&#9;Part.Anchored = false
&#9;Part.Color = Color3.new(0.88627457618713, 0.60784316062927, 0.25098040699959)
&#9;Part.Material = Enum.Material.Wood
&#9;Part.Size = Vector3.new(1, 1.2000000476837, 1)
&#9;Part.Locked = false
&#9;Part.BrickColor = BrickColor.new(&quot;Br. yellowish orange&quot;)

&#9;&#9;local Mesh = Instance.new(&quot;SpecialMesh&quot;)
&#9;&#9;Mesh.MeshId = &quot;http://www.roblox.com/asset/?id=119574562&quot;
&#9;&#9;Mesh.TextureId = &quot;http://www.roblox.com/asset/?id=64374853&quot;
&#9;&#9;Mesh.Parent = Part
&#9;&#9;Mesh.MeshType = Enum.MeshType.FileMesh

&#9;Part.Touched:connect(function(npart)
&#9;&#9;local hum = npart.Parent:FindFirstChild(&apos;Humanoid&apos;)
&#9;&#9;if hum and hum~=PetHumanoid then
&#9;&#9;&#9;if hum==MyHumanoid then
&#9;&#9;&#9;&#9;hum:TakeDamage(-10)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;hum:TakeDamage(-20)
&#9;&#9;&#9;end
&#9;&#9;&#9;Part.Parent=nil
&#9;&#9;end
&#9;end)
&#9;return Part

end

local function Start(modeOverride)
&#9;PetMode = modeOverride or math.random(3)


&#9;if NextTargetHumanoid then
&#9;&#9;TargetHumanoid = NextTargetHumanoid
&#9;end
end

local function Stop()
&#9;PetMode = 0
&#9;StopTime = time()
end


-- Returns the closest living Humanoid to position who isn&apos;t in excludeList
local function FindClosestHumanoid(position, excludeList) -- (Vector3, table)
&#9;if not position then print(&quot;Need a Vector3 position&quot;) return nil end

&#9;-- Change list values to keys so we can use indexing
&#9;local excludeSet = {}
&#9;if excludeList and type(excludeList) == &quot;table&quot; then
&#9;&#9;for _, l in ipairs(excludeList) do
&#9;&#9;&#9;excludeSet[l] = true
&#9;&#9;end
&#9;end

&#9;-- Search through Workspace children
&#9;local closestHumanoid = nil
&#9;for _, child in pairs(Game.Workspace:GetChildren()) do
&#9;&#9;if (child and child:FindFirstChild(&quot;Humanoid&quot;) and child.Humanoid.Health &gt; 0 and not excludeSet[child.Humanoid])
&#9;&#9;and (not closestHumanoid or (child.Humanoid.Torso.Position - position).magnitude &lt; (closestHumanoid.Torso.Position - position).magnitude) then
&#9;&#9;&#9;closestHumanoid = child.Humanoid
&#9;&#9;end
&#9;end
&#9;return closestHumanoid --NOTE: Can be nil
end

-- Coroutine to decide when to automatically start
coroutine.resume(coroutine.create(function()
&#9;wait(4)
&#9;while Pet do
&#9;&#9;if PetMode == 0 and math.random() &lt; 0.33 then
&#9;&#9;&#9;NextTargetHumanoid = FindClosestHumanoid(MyHumanoid.Torso.Position, {MyHumanoid, PetHumanoid})
&#9;&#9;&#9;if NextTargetHumanoid and NextTargetHumanoid.Torso then
&#9;&#9;&#9;&#9;local myDistanceToTarget = (NextTargetHumanoid.Torso.Position - MyHumanoid.Torso.Position).magnitude
&#9;&#9;&#9;&#9;if myDistanceToTarget &lt;= MAX_DISTANCE then
&#9;&#9;&#9;&#9;&#9;Start(1)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;wait(6)
&#9;end
end))

-- Rotates the pet horizontally to face the target
local function FaceTarget()
&#9;if PetHumanoid and PetHumanoid.Torso then
&#9;&#9;local position = PetHumanoid.Torso.Position
&#9;&#9;local lookPoint = TargetHumanoid.Torso.Position
&#9;&#9;PetHumanoid.Torso.CFrame = CFrame.new(position, Vector3.new(lookPoint.x, position.y, lookPoint.z)) -- Face target but stay horizontal
&#9;end
end

-- Returns total mass of instance and all children
local function GetMassRecursive(instance)
&#9;local mass = 0
&#9;if instance:IsA(&apos;BasePart&apos;) then
&#9;&#9;mass = mass + instance:GetMass()
&#9;end
&#9;for _, child in pairs(instance:getChildren()) do
&#9;&#9;if child then
&#9;&#9;&#9;mass = mass + GetMassRecursive(child)
&#9;&#9;end
&#9;end
&#9;return mass
end

local function Throw(part)
&#9;--local distanceToTarget = (TargetHumanoid.Torso.Position - PetHumanoid.Torso.Position).magnitude

&#9;--local angle = math.asin((RBX_GRAVITY * distanceToTarget) / (LAUNCH_SPEED * LAUNCH_SPEED)) / 2
&#9;--print(math.deg(angle), &quot;degrees&quot;)

&#9;part.CFrame = CFrame.new(RightArm.Position+Torso.CFrame.lookVector*2, TargetHumanoid.Torso.Position)
&#9;--part.Velocity = PetHumanoid.Torso.CFrame.lookVector * LAUNCH_SPEED

&#9;local mass =  GetMassRecursive(part)
&#9;local bodyForce = Instance.new(&apos;BodyForce&apos;, part) 
&#9;bodyForce.force = Vector3.new(0, mass/2 * 196.2, 0) -- Antigravity


&#9;local launchForce = (TargetHumanoid.Torso.Position - part.Position).unit * LAUNCH_SPEED&#9;&#9;
&#9;
&#9;--bodyForce.force = (bodyForce.force * 6) + (PetHumanoid.Torso.CFrame.lookVector * 100)
&#9;
&#9;bodyForce.force = bodyForce.force + (launchForce * 5)
&#9;--Delay(0.3, function() bodyForce.force = bodyForce.force - launchForce end)
&#9;
&#9;Delay(0.1, function() bodyForce:Destroy() end)

&#9;local partScript = part:FindFirstChild(&apos;Script&apos;)
&#9;if partScript then
&#9;&#9;partScript.Disabled = false
&#9;end

&#9;SwooshSound:Play()

&#9;DebrisService:AddItem(part, 10)
&#9;part.Parent = Workspace
end

------------------------
--| Main Pet AI Loop |--
------------------------

Delay(1,function()
&#9;for _,i in pairs(Torso:GetChildren()) do
&#9;&#9;if i:IsA(&apos;Sound&apos;) then
&#9;&#9;&#9;table.insert(Sounds,i)
&#9;&#9;end
&#9;end
end)

PetHumanoid.Changed:connect(function(prop)
&#9;if prop ==&apos;Jump&apos; and tick()-LastSoundTime &gt;2 and #Sounds&gt;1 then
&#9;&#9;LastSoundTime=tick()
&#9;&#9;Sounds[math.random(#Sounds)]:Play()
&#9;end
end)

PetHumanoid.Running:connect(function(speed)
&#9;if speed&gt;0 and tick()-LastSoundTime &gt;5 and #Sounds&gt;1 then
&#9;&#9;LastSoundTime=tick()
&#9;&#9;Sounds[math.random(#Sounds)]:Play()
&#9;elseif tick()-LastSoundTime &gt;5 and #Sounds&gt;1 then
&#9;&#9;LastSoundTime=tick()
&#9;&#9;Sounds[math.random(#Sounds)]:Play()
&#9;end
end)

MyHumanoid.Changed:connect(function(prop)
&#9;if prop ==&apos;Jump&apos; then
&#9;&#9;if MyHumanoid.Jump then
&#9;&#9;&#9;wait(.2)
&#9;&#9;&#9;PetHumanoid.Jump=true
&#9;&#9;end
&#9;end
&#9;&#9;
end)

while MyHumanoid and MyHumanoid.Torso and MyModel.Parent and PetHumanoid and PetHumanoid.Torso do


&#9;-- Jumping over obstacles
&#9;local hit = Game.Workspace:FindPartOnRay(Ray.new(PetHumanoid.Torso.Position, PetHumanoid.Torso.CFrame.lookVector * 3.0), MyModel)
&#9;if hit then
&#9;&#9;PetHumanoid.Jump = true
&#9;end

&#9;if TargetHumanoid and TargetHumanoid.Torso and math.random(1,15) == 4 then
&#9;&#9;Throw(GenerateBanana())
&#9;else
&#9;&#9;print(&quot;TargetHumanoid is nil&quot;)
&#9;&#9;PetMode = 0
&#9;end
&#9;print(&apos;in ai loop&apos;)
&#9;
&#9;PetHumanoid:MoveTo(MyHumanoid.Torso.Position + OFFSET, MyHumanoid.Torso)
&#9;

&#9;wait(ONE_STEP)
end

DebrisService:AddItem(script.Parent, 5)
</ProtectedString>
				</Properties>
				<Item class="ObjectValue" referent="RBX6">
					<Properties>
						<string name="Name">Owner</string>
						<Ref name="Value">null</Ref>
					</Properties>
				</Item>
			</Item>
			<Item class="Script" referent="RBX7">
				<Properties>
					<bool name="Disabled">true</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Sound</string>
					<ProtectedString name="Source">-- util

function waitForChild(parent, childName)
&#9;local child = parent:findFirstChild(childName)
&#9;if child then return child end
&#9;while true do
&#9;&#9;child = parent.ChildAdded:wait()
&#9;&#9;if child.Name==childName then return child end
&#9;end
end

function newSound(id)
&#9;local sound = Instance.new(&quot;Sound&quot;)
&#9;sound.SoundId = id
&#9;sound.archivable = false
&#9;sound.Parent = script.Parent.Head
&#9;return sound
end

-- declarations

local sDied = newSound(&quot;rbxasset://sounds/uuhhh.wav&quot;)
local sFallingDown = newSound(&quot;rbxasset://sounds/splat.wav&quot;)
local sFreeFalling = newSound(&quot;rbxasset://sounds/swoosh.wav&quot;)
local sGettingUp = newSound(&quot;rbxasset://sounds/hit.wav&quot;)
local sJumping = newSound(&quot;rbxasset://sounds/button.wav&quot;)
local sRunning = newSound(&quot;rbxasset://sounds/bfsl-minifigfoots1.mp3&quot;)
sRunning.Looped = true

local Figure = script.Parent
local Head = waitForChild(Figure, &quot;Head&quot;)
local Humanoid = waitForChild(Figure, &quot;Humanoid&quot;)

-- functions

function onDied()
&#9;sDied:Play()
end

function onState(state, sound)
&#9;if state then
&#9;&#9;sound:Play()
&#9;else
&#9;&#9;sound:Pause()
&#9;end
end

function onRunning(speed)
&#9;if speed&gt;0 then
&#9;&#9;sRunning:Play()
&#9;else
&#9;&#9;sRunning:Pause()
&#9;end
end

-- connect up

--Humanoid.Died:connect(onDied)
Humanoid.Running:connect(onRunning)
Humanoid.Jumping:connect(function(state) onState(state, sJumping) end)
Humanoid.GettingUp:connect(function(state) onState(state, sGettingUp) end)
Humanoid.FreeFalling:connect(function(state) onState(state, sFreeFalling) end)
Humanoid.FallingDown:connect(function(state) onState(state, sFallingDown) end)
</ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX8">
				<Properties>
					<bool name="Disabled">true</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">HealthRegenerationScript</string>
					<ProtectedString name="Source">function waitForChild(parent, childName)
&#9;local child = parent:findFirstChild(childName)
&#9;if child then return child end
&#9;while true do
&#9;&#9;child = parent.ChildAdded:wait()
&#9;&#9;if child.Name==childName then return child end
&#9;end
end


-- Renegeration Script for the bot
-- Renegerates about 1% of max hp per second until it reaches max health
bot = script.Parent
Humanoid = waitForChild(bot, &quot;Humanoid&quot;)

local regen = false

function regenerate() 
&#9;if regen then return end
&#9;-- Lock this function until the regeneration to max health is complete by using a boolean toggle
&#9;regen = true
&#9;while Humanoid.Health &lt; Humanoid.MaxHealth do
&#9;&#9;local delta = wait(1)
&#9;&#9;local health = Humanoid.Health
&#9;&#9;if health &gt; 0 and health &lt; Humanoid.MaxHealth then 
&#9;&#9;&#9;-- This delta is for regenerating 1% of max hp per second instead of 1 hp per second
&#9;&#9;&#9;delta = 0.01 * delta * Humanoid.MaxHealth
&#9;&#9;&#9;health = health + delta
&#9;&#9;&#9;Humanoid.Health = math.min(health, Humanoid.MaxHealth)&#9;&#9;&#9;
&#9;&#9;end
&#9;end&#9;
&#9;-- release the lock, since the health is at max now, and if the character loses health again
&#9;-- it needs to start regenerating 
&#9;regen = false
end&#9;

if Humanoid then 
&#9;-- Better than a while true do loop since it only fires when the health actually changes
&#9;Humanoid.HealthChanged:connect(regenerate)&#9;
end
</ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX9">
				<Properties>
					<bool name="Disabled">true</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Animate</string>
					<ProtectedString name="Source">function waitForChild(parent, childName)
&#9;local child = parent:findFirstChild(childName)
&#9;if child then return child end
&#9;while true do
&#9;&#9;child = parent.ChildAdded:wait()
&#9;&#9;if child.Name==childName then return child end
&#9;end
end

-- ANIMATION

-- declarations

local Figure = script.Parent
local Torso = waitForChild(Figure, &quot;Torso&quot;)
local RightShoulder = waitForChild(Torso, &quot;Right Shoulder&quot;)
local LeftShoulder = waitForChild(Torso, &quot;Left Shoulder&quot;)
local RightHip = waitForChild(Torso, &quot;Right Hip&quot;)
local LeftHip = waitForChild(Torso, &quot;Left Hip&quot;)
local Neck = waitForChild(Torso, &quot;Neck&quot;)
local Humanoid = waitForChild(Figure, &quot;Humanoid&quot;)
local pose = &quot;Standing&quot;

local toolAnim = &quot;None&quot;
local toolAnimTime = 0

-- functions

function onRunning(speed)
&#9;if speed&gt;0 then
&#9;&#9;pose = &quot;Running&quot;
&#9;else
&#9;&#9;pose = &quot;Standing&quot;
&#9;end
end

function onDied()
&#9;pose = &quot;Dead&quot;
end

function onJumping()
&#9;pose = &quot;Jumping&quot;
end

function onClimbing()
&#9;pose = &quot;Climbing&quot;
end

function onGettingUp()
&#9;pose = &quot;GettingUp&quot;
end

function onFreeFall()
&#9;pose = &quot;FreeFall&quot;
end

function onFallingDown()
&#9;pose = &quot;FallingDown&quot;
end

function onSeated()
&#9;pose = &quot;Seated&quot;
end

function onPlatformStanding()
&#9;pose = &quot;PlatformStanding&quot;
end

function moveJump()
&#9;RightShoulder.MaxVelocity = 0.5
&#9;LeftShoulder.MaxVelocity = 0.5
&#9;RightShoulder.DesiredAngle = 3.14
&#9;LeftShoulder.DesiredAngle = -3.14 
&#9;RightHip.DesiredAngle = 0
&#9;LeftHip.DesiredAngle = 0
end


-- same as jump for now

function moveFreeFall()
&#9;RightShoulder.MaxVelocity = 0.5
&#9;LeftShoulder.MaxVelocity = 0.5
&#9;RightShoulder.DesiredAngle = 3.14
&#9;LeftShoulder.DesiredAngle = -3.14 
&#9;RightHip.DesiredAngle = 0
&#9;LeftHip.DesiredAngle = 0&#9;
end

function moveSit()
&#9;RightShoulder.MaxVelocity = 0.15
&#9;LeftShoulder.MaxVelocity = 0.15
&#9;RightShoulder.DesiredAngle = 3.14/2
&#9;LeftShoulder.DesiredAngle = -3.14/2
&#9;RightHip.DesiredAngle = 3.14/2
&#9;LeftHip.DesiredAngle = -3.14/2
end

function getTool()&#9;
&#9;for _, kid in ipairs(Figure:GetChildren()) do
&#9;&#9;if kid.className == &quot;Tool&quot; then return kid end
&#9;end
&#9;return nil
end

function getToolAnim(tool)
&#9;for _, c in ipairs(tool:GetChildren()) do
&#9;&#9;if c.Name == &quot;toolanim&quot; and c.className == &quot;StringValue&quot; then
&#9;&#9;&#9;return c
&#9;&#9;end
&#9;end
&#9;return nil
end

function animateTool()
&#9;
&#9;if (toolAnim == &quot;None&quot;) then
&#9;&#9;RightShoulderdDesiredAngle = 1.57
&#9;&#9;return
&#9;end

&#9;if (toolAnim == &quot;Slash&quot;) then
&#9;&#9;RightShoulder.MaxVelocity = 0.5
&#9;&#9;RightShoulder.DesiredAngle = 0
&#9;&#9;return
&#9;end

&#9;if (toolAnim == &quot;Lunge&quot;) then
&#9;&#9;RightShoulder.MaxVelocity = 0.5
&#9;&#9;LeftShoulder.MaxVelocity = 0.5
&#9;&#9;RightHip.MaxVelocity = 0.5
&#9;&#9;LeftHip.MaxVelocity = 0.5
&#9;&#9;RightShoulder.DesiredAngle = 1.57
&#9;&#9;LeftShoulder.DesiredAngle = 0 
&#9;&#9;RightHip.DesiredAngle = 1.57
&#9;&#9;LeftHip.DesiredAngle = 1.0&#9;&#9;
&#9;&#9;return
&#9;end
end

function move(time)
&#9;local amplitude
&#9;local frequency
  
&#9;if (pose == &quot;Jumping&quot;) then
&#9;&#9;moveJump()
&#9;&#9;return
&#9;end

&#9;if (pose == &quot;FreeFall&quot;) then
&#9;&#9;moveFreeFall()
&#9;&#9;return
&#9;end
 
&#9;if (pose == &quot;Seated&quot;) then
&#9;&#9;moveSit()
&#9;&#9;return
&#9;end

&#9;local climbFudge = 0
&#9;
&#9;if (pose == &quot;Running&quot;) then
&#9;&#9;RightShoulder.MaxVelocity = 0.15
&#9;&#9;LeftShoulder.MaxVelocity = 0.15
&#9;&#9;amplitude = 1
&#9;&#9;frequency = 9
&#9;elseif (pose == &quot;Climbing&quot;) then
&#9;&#9;RightShoulder.MaxVelocity = 0.5 
&#9;&#9;LeftShoulder.MaxVelocity = 0.5
&#9;&#9;amplitude = 1
&#9;&#9;frequency = 9
&#9;&#9;climbFudge = 3.14
&#9;else
&#9;&#9;amplitude = 0.1
&#9;&#9;frequency = 1
&#9;end

&#9;desiredAngle = amplitude * math.sin(time*frequency)
&#9;
&#9;RightShoulder.DesiredAngle = desiredAngle + climbFudge
&#9;LeftShoulder.DesiredAngle = desiredAngle - climbFudge 
&#9;RightHip.DesiredAngle = -desiredAngle
&#9;LeftHip.DesiredAngle = -desiredAngle 

&#9;local tool = getTool()

&#9;if tool then
&#9;
&#9;&#9;animStringValueObject = getToolAnim(tool)

&#9;&#9;if animStringValueObject then
&#9;&#9;&#9;toolAnim = animStringValueObject.Value
&#9;&#9;&#9;-- message recieved, delete StringValue
&#9;&#9;&#9;animStringValueObject.Parent = nil
&#9;&#9;&#9;toolAnimTime = time + .3
&#9;&#9;end

&#9;&#9;if time &gt; toolAnimTime then
&#9;&#9;&#9;toolAnimTime = 0
&#9;&#9;&#9;toolAnim = &quot;None&quot;
&#9;&#9;end

&#9;&#9;animateTool()

&#9;&#9;
&#9;else
&#9;&#9;toolAnim = &quot;None&quot;
&#9;&#9;toolAnimTime = 0
&#9;end
end


-- connect events

Humanoid.Died:connect(onDied)
Humanoid.Running:connect(onRunning)
Humanoid.Jumping:connect(onJumping)
Humanoid.Climbing:connect(onClimbing)
Humanoid.GettingUp:connect(onGettingUp)
Humanoid.FreeFalling:connect(onFreeFall)
Humanoid.FallingDown:connect(onFallingDown)
Humanoid.Seated:connect(onSeated)
Humanoid.PlatformStanding:connect(onPlatformStanding)

-- main program

local runService = game:service(&quot;RunService&quot;);

while Figure.Parent~=nil do
&#9;local _, time = wait(0.1)
&#9;move(time)
end
</ProtectedString>
				</Properties>
			</Item>
			<Item class="Sound" referent="RBX10">
				<Properties>
					<bool name="Looped">false</bool>
					<string name="Name">bello</string>
					<float name="Pitch">1</float>
					<bool name="PlayOnRemove">false</bool>
					<Content name="SoundId"><url>http://www.roblox.com/asset/?id=119765610</url></Content>
					<float name="Volume">0.5</float>
				</Properties>
			</Item>
			<Item class="Sound" referent="RBX11">
				<Properties>
					<bool name="Looped">false</bool>
					<string name="Name">ahh</string>
					<float name="Pitch">1</float>
					<bool name="PlayOnRemove">false</bool>
					<Content name="SoundId"><url>http://www.roblox.com/asset/?id=119765728</url></Content>
					<float name="Volume">0.5</float>
				</Properties>
			</Item>
			<Item class="Sound" referent="RBX12">
				<Properties>
					<bool name="Looped">false</bool>
					<string name="Name">bagnet</string>
					<float name="Pitch">1</float>
					<bool name="PlayOnRemove">false</bool>
					<Content name="SoundId"><url>http://www.roblox.com/asset/?id=119765771</url></Content>
					<float name="Volume">0.5</float>
				</Properties>
			</Item>
			<Item class="Sound" referent="RBX13">
				<Properties>
					<bool name="Looped">false</bool>
					<string name="Name">kubedah</string>
					<float name="Pitch">1</float>
					<bool name="PlayOnRemove">false</bool>
					<Content name="SoundId"><url>http://www.roblox.com/asset/?id=119765946</url></Content>
					<float name="Volume">0.5</float>
				</Properties>
			</Item>
			<Item class="Sound" referent="RBX14">
				<Properties>
					<bool name="Looped">false</bool>
					<string name="Name">scream</string>
					<float name="Pitch">1</float>
					<bool name="PlayOnRemove">false</bool>
					<Content name="SoundId"><url>http://www.roblox.com/asset/?id=119766064</url></Content>
					<float name="Volume">0.5</float>
				</Properties>
			</Item>
			<Item class="Sound" referent="RBX15">
				<Properties>
					<bool name="Looped">false</bool>
					<string name="Name">mako</string>
					<float name="Pitch">1</float>
					<bool name="PlayOnRemove">false</bool>
					<Content name="SoundId"><url>http://www.roblox.com/asset/?id=119766152</url></Content>
					<float name="Volume">0.5</float>
				</Properties>
			</Item>
		</Item>
		<Item class="LocalScript" referent="RBX16">
			<Properties>
				<bool name="Disabled">true</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">PetAnimation</string>
				<ProtectedString name="Source">-- Waits for parent.child to exist, then returns it
local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end

local PlayersService = Game:GetService(&apos;Players&apos;)
local DebrisService = Game:GetService(&apos;Debris&apos;)

local MyModel = script.Parent

local Pet = WaitForChild(script, &apos;Pet&apos;).Value
local PetHumanoid = WaitForChild(Pet, &apos;Humanoid&apos;)

local AnimationToPlayObject = WaitForChild(script, &apos;AnimationToPlay&apos;)

local ReplicationScript = WaitForChild(script, &apos;ReplicateNpcAnimation&apos;)
local AnimToReplicateObject = WaitForChild(ReplicationScript, &apos;AnimationToReplicate&apos;)
local PlayOrStopObject = WaitForChild(ReplicationScript, &apos;PlayOrStop&apos;)

WaitForChild(ReplicationScript, &apos;PetHumanoid&apos;).Value = PetHumanoid

WaitForChild(script, &apos;NewNoogieLoop&apos;) -- Hardcoded or we&apos;ll never see it

local AnimationTupleTable = {}
local LastAnimationTrack = nil

-- Take any child animations and add them and their tracks to AnimationTupleTable
for _, child in pairs(script:GetChildren()) do
&#9;if child and child:IsA(&apos;Animation&apos;) then
&#9;&#9;AnimationTupleTable[child.Name] = {child, PetHumanoid:LoadAnimation(child)}
&#9;&#9;print(&quot;Animation pre-loaded:&quot;, child.Name) --DEBUG
&#9;end
end

-- When AnimationToPlay is changed, try to play the animation or stop the last
AnimationToPlayObject.Changed:connect(function(newValue)
&#9;if newValue ~= &apos;&apos; then
&#9;&#9;local animationTuple = AnimationTupleTable[newValue]
&#9;&#9;if animationTuple then
&#9;&#9;&#9;animationTuple[2]:Play()
&#9;&#9;&#9;AnimToReplicateObject.Value = animationTuple[1]
&#9;&#9;&#9;PlayOrStopObject.Value = true
&#9;&#9;&#9;LastAnimationTrack = animationTuple[2]

&#9;&#9;&#9;-- Replicate the child script to all other players so they can see the NPC animating
&#9;&#9;&#9;for _, player in pairs(PlayersService:GetPlayers()) do
&#9;&#9;&#9;&#9;if player.Character and player.Character ~= MyModel then
&#9;&#9;&#9;&#9;&#9;local replicationScriptClone = ReplicationScript:Clone()
&#9;&#9;&#9;&#9;&#9;DebrisService:AddItem(replicationScriptClone, 10) -- Just in case
&#9;&#9;&#9;&#9;&#9;replicationScriptClone.Parent = player.Character
&#9;&#9;&#9;&#9;&#9;replicationScriptClone.Disabled = false
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end

&#9;&#9;end
&#9;else
&#9;&#9;if LastAnimationTrack then
&#9;&#9;&#9;LastAnimationTrack:Stop()
&#9;&#9;end
&#9;&#9;PlayOrStopObject.Value = false
&#9;end

end)

--NOTE: This script would be much nicer if AnimationTracks could be sent using ObjectValues. (Or directly sent through some other means)
</ProtectedString>
			</Properties>
			<Item class="Animation" referent="RBX17">
				<Properties>
					<Content name="AnimationId"><url>http://www.roblox.com/Asset?ID=93604135</url></Content>
					<string name="Name">NewNoogieLoop</string>
				</Properties>
			</Item>
			<Item class="StringValue" referent="RBX18">
				<Properties>
					<string name="Name">AnimationToPlay</string>
					<string name="Value"></string>
				</Properties>
			</Item>
			<Item class="ObjectValue" referent="RBX19">
				<Properties>
					<string name="Name">Pet</string>
					<Ref name="Value">null</Ref>
				</Properties>
			</Item>
			<Item class="LocalScript" referent="RBX20">
				<Properties>
					<bool name="Disabled">true</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">ReplicateNpcAnimation</string>
					<ProtectedString name="Source">-- Waits for parent.child to exist, then returns it
local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end

local DebrisService = Game:GetService(&apos;Debris&apos;)

local MyModel = script.Parent

local PlayOrStop = WaitForChild(script, &apos;PlayOrStop&apos;).Value
local AnimToReplicate = WaitForChild(script, &apos;AnimationToReplicate&apos;).Value
local PetHumanoid = WaitForChild(script, &apos;PetHumanoid&apos;).Value

local TrackToReplicate = PetHumanoid:LoadAnimation(AnimToReplicate)


TrackToReplicate:Play()
wait(3)
TrackToReplicate:Stop()
DebrisService:AddItem(script, 0)</ProtectedString>
				</Properties>
				<Item class="BoolValue" referent="RBX21">
					<Properties>
						<string name="Name">PlayOrStop</string>
						<bool name="Value">false</bool>
					</Properties>
				</Item>
				<Item class="ObjectValue" referent="RBX22">
					<Properties>
						<string name="Name">AnimationToReplicate</string>
						<Ref name="Value">null</Ref>
					</Properties>
				</Item>
				<Item class="ObjectValue" referent="RBX23">
					<Properties>
						<string name="Name">PetHumanoid</string>
						<Ref name="Value">null</Ref>
					</Properties>
				</Item>
			</Item>
		</Item>
		<Item class="LocalScript" referent="RBX24">
			<Properties>
				<bool name="Disabled">true</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">PopupGui</string>
				<ProtectedString name="Source">-- Waits for parent.child to exist, then returns it
local function WaitForChild(parent, childName)
&#9;assert(parent, &quot;ERROR: WaitForChild: parent is nil&quot;)
&#9;while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
&#9;return parent[childName]
end

local PlayersService = Game:GetService(&apos;Players&apos;)
local MyPlayer = PlayersService.LocalPlayer

local Tool = script.Parent

local ScreenGui = WaitForChild(script, &apos;ScreenGui&apos;)
local ClonedFrame = nil

local NeverEquipped = true

local function OnEquipped(mouse)
&#9;if NeverEquipped then
&#9;&#9;NeverEquipped = false

&#9;&#9;local guiClone = ScreenGui:Clone()
&#9;&#9;guiClone.Parent = MyPlayer.PlayerGui

&#9;&#9;ClonedFrame = WaitForChild(guiClone, &apos;Frame&apos;)
&#9;end
end

local function OnActivated()
&#9;ClonedFrame.Visible = false
end

Tool.Equipped:connect(OnEquipped)
Tool.Activated:connect(OnActivated)
</ProtectedString>
			</Properties>
			<Item class="ScreenGui" referent="RBX25">
				<Properties>
					<string name="Name">ScreenGui</string>
				</Properties>
				<Item class="Frame" referent="RBX26">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<string name="Name">Frame</string>
						<UDim2 name="Position">
							<XS>0.5</XS>
							<XO>-284</XO>
							<YS>0.5</YS>
							<YO>-257</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>568</XO>
							<YS>0</YS>
							<YO>515</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">10</int>
					</Properties>
					<Item class="ImageLabel" referent="RBX27">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><url>http://www.roblox.com/Asset?ID=93747474</url></Content>
							<string name="Name">ImageLabel</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">10</int>
						</Properties>
					</Item>
				</Item>
			</Item>
		</Item>
		<Item class="Camera" referent="RBX28">
			<Properties>
				<Ref name="CameraSubject">null</Ref>
				<token name="CameraType">0</token>
				<CoordinateFrame name="CoordinateFrame">
					<X>39.5540581</X>
					<Y>36.4641685</Y>
					<Z>0.293527603</Z>
					<R00>0.942067862</R00>
					<R01>-0.0263123661</R01>
					<R02>0.334388822</R02>
					<R10>-1.86264515e-009</R10>
					<R11>0.996918499</R11>
					<R12>0.0784454569</R12>
					<R20>-0.335422456</R20>
					<R21>-0.0739009455</R21>
					<R22>0.939164817</R22>
				</CoordinateFrame>
				<float name="FieldOfView">70</float>
				<CoordinateFrame name="Focus">
					<X>38.8852806</X>
					<Y>36.3072777</Y>
					<Z>-1.58480155</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<string name="Name">ThumbnailCamera</string>
			</Properties>
		</Item>
	</Item>
</roblox>