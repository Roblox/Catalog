<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Tool" referent="RBX0">
		<Properties>
			<bool name="Enabled">true</bool>
			<CoordinateFrame name="Grip">
				<X>-1</X>
				<Y>-2</Y>
				<Z>1.5</Z>
				<R00>1</R00>
				<R01>0</R01>
				<R02>0</R02>
				<R10>0</R10>
				<R11>0</R11>
				<R12>-1</R12>
				<R20>0</R20>
				<R21>1</R21>
				<R22>0</R22>
			</CoordinateFrame>
			<string name="Name">SentryTurret</string>
			<Content name="TextureId"><url>http://www.roblox.com/asset/?id=68414075</url></Content>
		</Properties>
		<Item class="Part" referent="RBX1">
			<Properties>
				<bool name="Anchored">false</bool>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">0</token>
				<token name="BottomSurfaceInput">0</token>
				<int name="BrickColor">1003</int>
				<CoordinateFrame name="CFrame">
					<X>-6.19999695</X>
					<Y>46.4995575</Y>
					<Z>-9.20003891</Z>
					<R00>-1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>0</R11>
					<R12>1</R12>
					<R20>0</R20>
					<R21>1</R21>
					<R22>0</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<float name="Elasticity">0.5</float>
				<float name="Friction">0.300000012</float>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<float name="LeftParamA">0</float>
				<float name="LeftParamB">0</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">false</bool>
				<token name="Material">256</token>
				<string name="Name">Handle</string>
				<float name="Reflectance">0</float>
				<float name="RightParamA">0</float>
				<float name="RightParamB">0</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">0</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<token name="formFactorRaw">3</token>
				<token name="shape">1</token>
				<Vector3 name="size">
					<X>4</X>
					<Y>4</Y>
					<Z>4</Z>
				</Vector3>
			</Properties>
			<Item class="SpecialMesh" referent="RBX2">
				<Properties>
					<token name="LODX">2</token>
					<token name="LODY">2</token>
					<Content name="MeshId"><url>http://www.roblox.com/asset/?id=68388933</url></Content>
					<token name="MeshType">5</token>
					<string name="Name">Mesh</string>
					<Vector3 name="Offset">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<Vector3 name="Scale">
						<X>2</X>
						<Y>2</Y>
						<Z>2</Z>
					</Vector3>
					<Content name="TextureId"><url>http://www.roblox.com/asset/?id=68237809</url></Content>
					<Vector3 name="VertexColor">
						<X>1</X>
						<Y>1</Y>
						<Z>1</Z>
					</Vector3>
				</Properties>
			</Item>
		</Item>
		<Item class="Script" referent="RBX3">
			<Properties>
				<bool name="Disabled">true</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">SentryTurret_SentryCleanup</string>
				<ProtectedString name="Source">function Create(ty)
&#9;return function(data)
&#9;&#9;local obj = Instance.new(ty)
&#9;&#9;for k, v in pairs(data) do
&#9;&#9;&#9;if type(k) == &apos;number&apos; then
&#9;&#9;&#9;&#9;v.Parent = obj
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;obj[k] = v
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;return obj
&#9;end
end

local Model = script.Parent
local Humanoid = Model:FindFirstChild(&quot;Humanoid&quot;)
local Player = (Model:FindFirstChild(&quot;TurretOwner&quot;) or {}).Value
local PlayerTurretValue = (Player or game):FindFirstChild(&quot;SentryValue&quot;)

if not (Model and Humanoid and Player and PlayerTurretValue) then
&#9;print(&quot;FATAL: SentryCleaner setup failed, destroying turret!&quot;)
&#9;Model:Destroy()
&#9;Model.Parent = nil
end

game.Players.ChildRemoved:connect(function(p)
&#9;if p == Player then
&#9;&#9;--my player left, kill self
&#9;&#9;Humanoid.Health = 0
&#9;end
end)


Player.Changed:connect(function(prop, value)
&#9;if prop == &quot;Character&quot; then
&#9;&#9;local runner = script.SentryTurret_Sentry:Clone()
&#9;&#9;local runnerTarget = Create&apos;ObjectValue&apos;{
&#9;&#9;&#9;Name = &apos;MyTargetTurret&apos;,
&#9;&#9;&#9;Value = Model,
&#9;&#9;&#9;Parent = runner,
&#9;&#9;}
&#9;&#9;runner.Parent = Player.Character
&#9;&#9;runner.Disabled = false
&#9;end
end)


Humanoid.Died:connect(function()
&#9;local partsToFade = {}
&#9;for _, p in pairs(Model:GetChildren()) do
&#9;&#9;if p:IsA(&quot;BasePart&quot;) then
&#9;&#9;&#9;Create&apos;Fire&apos;{
&#9;&#9;&#9;&#9;Name = &apos;FireEffect&apos;,
&#9;&#9;&#9;&#9;Parent = p,
&#9;&#9;&#9;}&#9;
&#9;&#9;&#9;partsToFade[#partsToFade+1] = p
&#9;&#9;end
&#9;end

&#9;--remove this as current turret for player
&#9;if PlayerTurretValue.Value == model then
&#9;&#9;PlayerTurretValue.Value = nil
&#9;end 
&#9;
&#9;--fade stuff
&#9;for i = 0, 1, 0.05 do
&#9;&#9;for _, p in pairs(partsToFade) do
&#9;&#9;&#9;p.Transparency = i
&#9;&#9;end
&#9;&#9;wait()
&#9;end

&#9;--remove self
&#9;Model:Destroy()
end)

--script.Name = &quot;RUNNING_&quot;..script.Name
while Humanoid.MaxHealth ~= 200 do
&#9;wait()
&#9;Humanoid.MaxHealth = 200
end
while Humanoid.Health ~= 200 do
&#9;wait()
&#9;local p = Humanoid.Parent
&#9;Humanoid.Health = 200
&#9;Humanoid.Parent = p
end
</ProtectedString>
			</Properties>
			<Item class="LocalScript" referent="RBX4">
				<Properties>
					<bool name="Disabled">true</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">SentryTurret_Sentry</string>
					<ProtectedString name="Source">function Create(ty)
&#9;return function(data)
&#9;&#9;local obj = Instance.new(ty)
&#9;&#9;for k, v in pairs(data) do
&#9;&#9;&#9;if type(k) == &apos;number&apos; then
&#9;&#9;&#9;&#9;v.Parent = obj
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;obj[k] = v
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;return obj
&#9;end
end

local function class(name)
&#9;local def = {}
&#9;getfenv(0)[name] = def
&#9;return function(ctor, static)
&#9;&#9;local nctor = function(...)
&#9;&#9;&#9;local this = {}
&#9;&#9;&#9;if ctor then
&#9;&#9;&#9;&#9;ctor(this, ...)
&#9;&#9;&#9;end
&#9;&#9;&#9;return this
&#9;&#9;end
&#9;&#9;getfenv(0)[&apos;Create&apos;..name] = nctor
&#9;&#9;if static then static(def) end
&#9;end
end

class&apos;Bin&apos;(function(this)
&#9;local mGarbage = {}

&#9;function this:add(func, ident)
&#9;&#9;ident = ident or &apos;__unnamed&apos;
&#9;&#9;if not mGarbage[ident] then
&#9;&#9;&#9;mGarbage[ident] = {}
&#9;&#9;end
&#9;&#9;mGarbage[ident][#mGarbage[ident]+1] = func
&#9;end

&#9;function this:clean(ident)
&#9;&#9;local listToCall = mGarbage[ident]
&#9;&#9;if listToCall then
&#9;&#9;&#9;for _, func in pairs(listToCall) do
&#9;&#9;&#9;&#9;func()
&#9;&#9;&#9;end
&#9;&#9;&#9;mGarbage[ident] = nil
&#9;&#9;end
&#9;end

&#9;function this:cleanAll()
&#9;&#9;for ident, list in pairs(mGarbage) do
&#9;&#9;&#9;for _, func in pairs(list) do
&#9;&#9;&#9;&#9;func()
&#9;&#9;&#9;end
&#9;&#9;&#9;mGarbage[ident] = nil
&#9;&#9;end
&#9;end
end)

local Bin = CreateBin()

--------------------------------------------------
--                    settings                  --
local MaxRange = 30
local ReloadTime = 0.5
local DamagePerShot = 7
--                                              --
--------------------------------------------------

--game.Workspace.ErrorOut.Value = game.Workspace.ErrorOut.Value..&quot;(( SentryScript Running &quot;

while not script:FindFirstChild(&quot;MyTargetTurret&quot;) do script.ChildAdded:wait() end
local Model = script.MyTargetTurret.Value
local Humanoid = Model:FindFirstChild(&quot;Humanoid&quot;)
local Player = (Model:FindFirstChild(&quot;TurretOwner&quot;) or {}).Value
local PlayerTurretValue = (Player or game):FindFirstChild(&quot;SentryValue&quot;)
local PlayerTurretTargetValue = (Player or game):FindFirstChild(&quot;SentryTargetValue&quot;)
--
local CannonPart = Model:FindFirstChild(&quot;CannonMove&quot;)
local TorsoPart = Model:FindFirstChild(&quot;Torso&quot;)
local HeadPart = Model:FindFirstChild(&quot;Head&quot;)
local TorsoToHead = (TorsoPart or game):FindFirstChild(&quot;Neck&quot;)
local HeadToCannon = (HeadPart or game):FindFirstChild(&quot;CannonAttach&quot;)
local FireSound = (CannonPart or game):FindFirstChild(&quot;FireSound&quot;)

if not (Model and Humanoid and Player and PlayerTurretValue and PlayerTurretTargetValue and
        CannonPart and TorsoPart and HeadPart and TorsoToHead and HeadToCannon and FireSound) 
then
&#9;print(&quot;FATAL: Sentry setup failed, destroying turret!&quot;)
&#9;Model:Destroy()
&#9;Model.Parent = nil
end

--prevent double init
local INITED_HACK = (Model:FindFirstChild(&quot;INITED_HACK&quot;))
if not INITED_HACK then
&#9;Create&apos;IntValue&apos;{
&#9;&#9;Name = &quot;INITED_HACK&quot;,
&#9;&#9;Parent = Model,
&#9;}
end
--game.Workspace.ErrorOut.Value = game.Workspace.ErrorOut.Value..&quot;... with&quot;..(INITED_HACK and &quot;out&quot; or &quot;&quot;)..&quot; INIT ))&quot;


local UnfoldAnimDef = Create&apos;Animation&apos;{
&#9;Parent = Model,
&#9;AnimationId = &quot;http://www.roblox.com/asset/?id=68433924&quot;,
}
local FireAnim1Def = Create&apos;Animation&apos;{
&#9;Parent = Model,
&#9;AnimationId = &quot;http://www.roblox.com/asset/?id=68433992&quot;,
}
local FireAnim2Def = Create&apos;Animation&apos;{
&#9;Parent = Model,
&#9;AnimationId = &quot;http://www.roblox.com/asset/?id=68433974&quot;,
}
local UnfoldAnim = Humanoid:LoadAnimation(UnfoldAnimDef)
local FireAnim1 = Humanoid:LoadAnimation(FireAnim1Def)
local FireAnim2 = Humanoid:LoadAnimation(FireAnim2Def)

if not INITED_HACK then
&#9;UnfoldAnim:Play(0, 1, 1)
end

function TagHumanoid(humanoid)
&#9;local tag = Create&apos;ObjectValue&apos;{
&#9;&#9;Name = &quot;creator&quot;, 
&#9;&#9;Value = Player,
&#9;&#9;Parent = humanoid,
&#9;}
&#9;game.Debris:AddItem(tag, 2)
end


Humanoid.Died:connect(function()
&#9;script:Destroy()
end)


---fire from point
local whichFireFrom = true
local function GetFireFrom()
&#9;local dir = (whichFireFrom and 1 or -1)
&#9;return CannonPart.CFrame*CFrame.new(0,dir*0.3,-1.8)
end
local function GetFireAnim()
&#9;if whichFireFrom then
&#9;&#9;return FireAnim1
&#9;else
&#9;&#9;return FireAnim2
&#9;end
end
local function SwitchFireFrom()
&#9;whichFireFrom = not whichFireFrom
end


function ShowShot(from, to)
&#9;local shotBlast = Create&apos;Part&apos;{
&#9;&#9;Name = &quot;ShotBlast&quot;,
&#9;&#9;CanCollide = false,
&#9;&#9;Anchored = true,
&#9;&#9;Parent = Model,
&#9;&#9;FormFactor = &apos;Custom&apos;,
&#9;&#9;Size = Vector3.new(0.5, 0.5, 1.5),
&#9;&#9;BrickColor = BrickColor.new(21),
&#9;&#9;Transparency = 0.3,
&#9;&#9;Create&apos;SpecialMesh&apos;{
&#9;&#9;&#9;MeshType = &apos;Sphere&apos;,
&#9;&#9;},
&#9;&#9;Create&apos;Fire&apos;{
&#9;&#9;&#9;Size = 0,
&#9;&#9;&#9;Heat = 0,
&#9;&#9;},
&#9;}
&#9;local shotLance = Create&apos;Part&apos;{
&#9;&#9;Name = &quot;ShotLance&quot;,
&#9;&#9;CanCollide = false,
&#9;&#9;Anchored = true,
&#9;&#9;Parent = Model,
&#9;&#9;FormFactor = &apos;Custom&apos;,
&#9;&#9;BrickColor = BrickColor.new(21),
&#9;&#9;Size = Vector3.new(0.2, 0.2, (from-to).magnitude),
&#9;&#9;Transparency = 0.3,
&#9;}
&#9;shotBlast.CFrame = CFrame.new(from, to)
&#9;shotLance.CFrame = CFrame.new(from, to)*CFrame.new(0, 0, -(from-to).magnitude/2)
&#9;--
&#9;game.Debris:AddItem(shotBlast, 0.5)
&#9;game.Debris:AddItem(shotLance, 0.5)
&#9;game.Debris:AddItem(shotBlast.Fire, 0.2)
&#9;--
&#9;Spawn(function()
&#9;&#9;for i = 0.3, 1, 0.05 do
&#9;&#9;&#9;wait()
&#9;&#9;&#9;shotBlast.Transparency = i
&#9;&#9;&#9;shotLance.Transparency = i
&#9;&#9;end
&#9;&#9;shotBlast:Destroy()
&#9;&#9;shotLance:Destroy()
&#9;end)
end


local PivotOffsetFromHead = CFrame.new(0, 0.4, 0.1)*CFrame.Angles(-math.pi/2, 0, 0)
local HeadOffsetFromPivot = CFrame.new(0, 0, -1)
local GunOffsetFromHead = CFrame.new(0, 0.6, 0.2)*CFrame.Angles(math.pi/2, 0, 0)
function AimAt(pos)
&#9;--edit the swivel joint
&#9;--[[local originalHeadPos = (TorsoPart.CFrame*TorsoToHead.C0*TorsoToHeadAnimMod).p
&#9;local desiredCFrame = CFrame.new(originalHeadPos, 
&#9;                                 Vector3.new(pos.x, originalHeadPos.y, pos.z))*
&#9;                      CFrame.Angles(-math.pi/2, 0, 0)
&#9;TorsoToHead.C1 = desiredCFrame:inverse()*
&#9;                 TorsoPart.CFrame*
&#9;                 TorsoToHead.C0*
&#9;                 TorsoToHeadAnimMod
&#9;]]
&#9;local headPivot = TorsoPart.CFrame*PivotOffsetFromHead
&#9;local desiredCF = CFrame.new(headPivot.p, Vector3.new(pos.x, headPivot.p.y, pos.z))
&#9;desiredCF = desiredCF*CFrame.Angles(-math.pi/2, 0, 0)
&#9;TorsoToHead.C1 = HeadOffsetFromPivot*(desiredCF:inverse()*headPivot)
&#9;--
&#9;local gunPivot = HeadPart.CFrame*GunOffsetFromHead
&#9;local desiredCF = CFrame.new(gunPivot.p, pos)
&#9;HeadToCannon.C1 = desiredCF:inverse()*gunPivot
end

function GetTarget(targetPos)
&#9;local from = GetFireFrom().p
&#9;local ray = Ray.new(from, (targetPos-from))
&#9;local part, hit = game.Workspace:FindPartOnRay(ray, Model)
&#9;--if part then
&#9;--&#9;print(&quot;Hit part&quot;, part, &quot;in&quot;, part.Parent)
&#9;--end
&#9;if part then
&#9;&#9;--if it&apos;s part of a humanoid, or a humanoid&apos;s gear/hats
&#9;&#9;local hum = (part.Parent or game):FindFirstChild(&apos;Humanoid&apos;)
&#9;&#9;hum = hum or ((part.Parent or game).Parent or game):FindFirstChild(&apos;Humanoid&apos;)
&#9;&#9;if hum then
&#9;&#9;&#9;return hum, (hit-from).magnitude, hit
&#9;&#9;end
&#9;end
end


function InflictDamageOn(hum)
&#9;TagHumanoid(hum)
&#9;hum:TakeDamage(DamagePerShot)
&#9;GetFireAnim():Play(0, 1, 5)
&#9;FireSound:Play()
end


local mLastShotTime = 0

if not INITED_HACK then
&#9;repeat until UnfoldAnim.KeyframeReached:wait() == &apos;complete&apos;
&#9;wait()
end

--local beforeErr = &quot;&quot;
while true do
&#9;wait()

&#9;--local st, err = pcall(function()
&#9;local didAttackOnTarget = false

&#9;if PlayerTurretTargetValue.Value then
&#9;&#9;local hum = PlayerTurretTargetValue.Value
&#9;&#9;if hum.Health &gt; 0 then
&#9;&#9;&#9;local torso = (hum.Parent or game):FindFirstChild(&quot;Torso&quot;)
&#9;&#9;&#9;--find biggest part to target in the thing if no torso exists
&#9;&#9;&#9;if not torso and hum.Parent then
&#9;&#9;&#9;&#9;local largestPart = nil
&#9;&#9;&#9;&#9;local largestSize = -1
&#9;&#9;&#9;&#9;for _, p in pairs(hum.Parent:GetChildren()) do
&#9;&#9;&#9;&#9;&#9;if p:IsA(&apos;BasePart&apos;) then
&#9;&#9;&#9;&#9;&#9;&#9;--beforeErr = &quot;281&quot;
&#9;&#9;&#9;&#9;&#9;&#9;if p.Size.magnitude &gt; largestSize then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;largestPart = p
&#9;&#9;&#9;&#9;&#9;&#9;&#9;largestSize = p.Size.magnitude
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;--
&#9;&#9;&#9;&#9;torso = largestPart
&#9;&#9;&#9;end
&#9;&#9;&#9;--beforeErr = &quot;291&quot;
&#9;&#9;&#9;--make sure there were any parts at all
&#9;&#9;&#9;if torso then
&#9;&#9;&#9;&#9;if hum ~= Humanoid then
&#9;&#9;&#9;&#9;&#9;AimAt(torso.Position)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;local hum, dist, hitPos = GetTarget(torso.Position)
&#9;&#9;&#9;&#9;if hum and hum ~= Humanoid and dist &lt; MaxRange then
&#9;&#9;&#9;&#9;&#9;AimAt(hitPos)
&#9;&#9;&#9;&#9;&#9;didAttackOnTarget = true
&#9;&#9;&#9;&#9;&#9;if (tick()-mLastShotTime) &gt; ReloadTime then
&#9;&#9;&#9;&#9;&#9;&#9;ShowShot(GetFireFrom().p, hitPos)
&#9;&#9;&#9;&#9;&#9;&#9;InflictDamageOn(hum)
&#9;&#9;&#9;&#9;&#9;&#9;SwitchFireFrom()
&#9;&#9;&#9;&#9;&#9;&#9;mLastShotTime = tick()
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;if not didAttackOnTarget then
&#9;&#9;--do targeting
&#9;&#9;local targets = {}

&#9;&#9;--gather all possible targets
&#9;&#9;local fireFrom = GetFireFrom().p
&#9;&#9;local targetAtAll = nil --if all else fails, aim at this thing
&#9;&#9;for _, p in pairs(game.Players:GetChildren()) do
&#9;&#9;&#9;if p ~= Player then
&#9;&#9;&#9;&#9;if p.Character and p.Character:FindFirstChild(&apos;Torso&apos;) then
&#9;&#9;&#9;&#9;&#9;local targetPos = p.Character.Torso.Position
&#9;&#9;&#9;&#9;&#9;--skip raycasting if the target is too far away
&#9;&#9;&#9;&#9;&#9;--beforeErr = tostring(fireFrom)..&quot;,&quot;..tostring(targetPos)
&#9;&#9;&#9;&#9;&#9;if (fireFrom - targetPos).magnitude &gt; MaxRange*2 then
&#9;&#9;&#9;&#9;&#9;&#9;targetAtAll = targetPos
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;--beforeErr = beforeErr..&quot;|328&quot;
&#9;&#9;&#9;&#9;&#9;&#9;AimAt(targetPos)
&#9;&#9;&#9;&#9;&#9;&#9;--beforeErr = beforeErr..&quot;|330&quot;
&#9;&#9;&#9;&#9;&#9;&#9;local hum, dist, hit = GetTarget(targetPos)
&#9;&#9;&#9;&#9;&#9;&#9;if hum and hum ~= Humanoid and dist &lt; MaxRange then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;targets[hum] = hit
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;--beforeErr = beforeErr..&quot;|340&quot;
&#9;&#9;--if there are any targets available
&#9;&#9;if next(targets) then
&#9;&#9;&#9;--find the lowest health one, the best to try killing
&#9;&#9;&#9;local lowestHealth = 10000
&#9;&#9;&#9;local lowestHealthHum = nil
&#9;&#9;&#9;for p, _ in pairs(targets) do
&#9;&#9;&#9;&#9;if p.Health &lt; lowestHealth then
&#9;&#9;&#9;&#9;&#9;lowestHealth = p.Health
&#9;&#9;&#9;&#9;&#9;lowestHealthHum = p
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end

&#9;&#9;&#9;local to = targets[lowestHealthHum]
&#9;&#9;&#9;AimAt(to)
&#9;&#9;&#9;if (tick()-mLastShotTime) &gt; ReloadTime then
&#9;&#9;&#9;&#9;ShowShot(GetFireFrom().p, to)
&#9;&#9;&#9;&#9;InflictDamageOn(lowestHealthHum)
&#9;&#9;&#9;&#9;SwitchFireFrom()
&#9;&#9;&#9;&#9;mLastShotTime = tick()
&#9;&#9;&#9;end
&#9;&#9;elseif targetAtAll then
&#9;&#9;&#9;--all else failed, just point at something
&#9;&#9;&#9;AimAt(targetAtAll)
&#9;&#9;end
&#9;end
&#9;--end)
&#9;--if not st then 
&#9;--game.Workspace.ErrorOut.Value = game.Workspace.ErrorOut.Value..&quot;[:&quot;..beforeErr..&quot;: &quot;..err..&quot;]&quot;
&#9;--break
&#9;--end
end

--script.Name = &quot;RUNNING_&quot;..script.Name</ProtectedString>
				</Properties>
			</Item>
		</Item>
		<Item class="LocalScript" referent="RBX5">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">SentryTurret_Main</string>
				<ProtectedString name="Source">--local mDebugId = game.Workspace.DebugId.Value
--game.Workspace.DebugId.Value = game.Workspace.DebugId.Value+1
--print(&quot;Running swordscript &lt;&quot;..mDebugId..&quot;&gt;&quot;)

-------------------------------------
-- Makes an RBX::Lua Instance using
-- a table of key-value pairs to
-- initialize it. Values with numeric 
-- keys will be parented to the object
-- and other values will be set
-- as members of the object.
function Create(ty)
&#9;return function(data)
&#9;&#9;local obj = Instance.new(ty)
&#9;&#9;for k, v in pairs(data) do
&#9;&#9;&#9;if type(k) == &apos;number&apos; then
&#9;&#9;&#9;&#9;v.Parent = obj
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;obj[k] = v
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;return obj
&#9;end
end

---------------------------------------
-- Same as Make, but modifies an existing
-- object rather than creating ones.
function Modify(obj, data)
&#9;for k, v in pairs(data) do
&#9;&#9;if type(data) == &apos;number&apos; then
&#9;&#9;&#9;data.Parent = obj
&#9;&#9;else
&#9;&#9;&#9;data[k] = v
&#9;&#9;end
&#9;end
&#9;return obj
end

-----------------------------------------
-- Creates a class which can be instantiated
-- using `CreateCLASSNAME( ... )`.
---usage:
--class&apos;MyClass&apos;(function(this, arg1)
--&#9;this.ClassMember = value
--&#9;function this.ClassMethod(...) ... end
--end, function(def)
--&#9;def.StaticMember = value
--&#9; function def.StaticMethod(...) ... end
--end)
--local obj = CreateMyClass(arg1)
------------------------------------------
local function class(name)
&#9;local def = {}
&#9;getfenv(0)[name] = def
&#9;return function(ctor, static)
&#9;&#9;local nctor = function(...)
&#9;&#9;&#9;local this = {}
&#9;&#9;&#9;if ctor then
&#9;&#9;&#9;&#9;ctor(this, ...)
&#9;&#9;&#9;end
&#9;&#9;&#9;return this
&#9;&#9;end
&#9;&#9;getfenv(0)[&apos;Create&apos;..name] = nctor
&#9;&#9;if static then static(def) end
&#9;end
end


---------------------------------------------
-- Signal class for custom-made events
--API:
-- Signal:connect(callback)
-- Signal:fire(...)
-- Signal:wait()
---------------------------------------------
class&apos;Signal&apos;(function(this)
&#9;local mListeners = {}
&#9;local mWaitObject = Create&apos;BoolValue&apos;{}

&#9;function this:connect(func)
&#9;&#9;local connection = {}
&#9;&#9;function connection:disconnect()
&#9;&#9;&#9;mListeners[func] = nil
&#9;&#9;end
&#9;&#9;mListeners[func] = connection
&#9;&#9;return connection
&#9;end

&#9;function this:fire(...)
&#9;&#9;--print(&quot;Fire evt&lt;&quot;..tostring(this)..&quot;&gt; from script&lt;&quot;..mDebugId..&quot;&gt;&quot;)
&#9;&#9;for func, conn in pairs(mListeners) do
&#9;&#9;&#9;--print(&quot;-&gt; &quot;..tostring(func)..&quot;( ... )&quot;)
&#9;&#9;&#9;func(...)
&#9;&#9;end
&#9;&#9;mWaitObject.Value = not mWaitObject.Value
&#9;end

&#9;function this:wait()
&#9;&#9;mWaitObject.Changed:wait()
&#9;end
end)


--------------------------------------------------
-- Bin class for cleaning up assets
--API: 
-- Bin:add(func: Function, ident: String)
-- Bin:clean(ident: String)
-- Bin:cleanAll()
--------------------------------------------------
class&apos;Bin&apos;(function(this)
&#9;local mGarbage = {}

&#9;function this:add(func, ident)
&#9;&#9;ident = ident or &apos;__unnamed&apos;
&#9;&#9;if not mGarbage[ident] then
&#9;&#9;&#9;mGarbage[ident] = {}
&#9;&#9;end
&#9;&#9;mGarbage[ident][#mGarbage[ident]+1] = func
&#9;end

&#9;function this:clean(ident)
&#9;&#9;local listToCall = mGarbage[ident]
&#9;&#9;if listToCall then
&#9;&#9;&#9;for _, func in pairs(listToCall) do
&#9;&#9;&#9;&#9;func()
&#9;&#9;&#9;end
&#9;&#9;&#9;mGarbage[ident] = nil
&#9;&#9;end
&#9;end

&#9;function this:cleanAll()
&#9;&#9;for ident, list in pairs(mGarbage) do
&#9;&#9;&#9;for _, func in pairs(list) do
&#9;&#9;&#9;&#9;func()
&#9;&#9;&#9;end
&#9;&#9;&#9;mGarbage[ident] = nil
&#9;&#9;end
&#9;end
end)


-----------------------------------------------------
-- AnimationProvider class for easy loading of
-- animation assets into animationtracks once 
-- a humanoid is available.
--API:
-- AnimationProvider:registerAnimation(ident, assetid)
-- AnimationProvider:setHumanoid(humanoid)
-- AnimationProvider:setTool(tool)
-- AnimationProvider:getAnimation(ident)
-----------------------------------------------------
class&apos;AnimationProvider&apos;(function(this)
&#9;local mAnimations = {--[[ident =&gt; {AnimationId, CurrentTrack, CurrentAnim} ]]}
&#9;local mCurrentHumanoid = nil

&#9;function this:registerAnimation(ident, assetid)
&#9;&#9;--check for an existing copy of the anim
&#9;&#9;local existingAnim = Tool.Tool:FindFirstChild(&apos;ANIM_&apos;..ident)
&#9;&#9;&#9;
&#9;&#9;--make the data for this anim
&#9;&#9;local animdat = {
&#9;&#9;&#9;AnimationId = assetid, 
&#9;&#9;&#9;CurrentAnim = existingAnim or Create&apos;Animation&apos;{
&#9;&#9;&#9;&#9;Name = &quot;ANIM_&quot;..ident,
&#9;&#9;&#9;&#9;AnimationId = assetid,&#9;
&#9;&#9;&#9;},
&#9;&#9;}
&#9;&#9;mAnimations[ident] = animdat

&#9;&#9;--if there&apos;s a current tool, put it in there
&#9;&#9;if Tool.Tool then
&#9;&#9;&#9;Tool.HUGE_EQUIP_HACK = true
&#9;&#9;&#9;animdat.CurrentAnim.Parent = Tool.Tool
&#9;&#9;&#9;Tool.HUGE_EQUIP_HACK = false
&#9;&#9;end
&#9;&#9;
&#9;&#9;--if there&apos;s a humanoid load the animation track
&#9;&#9;if mCurrentHumanoid then
&#9;&#9;&#9;animdat.CurrentTrack = mCurrentHumanoid:LoadAnimation(animdat.CurrentAnim)
&#9;&#9;end
&#9;end

&#9;function this:setHumanoid(humanoid)
&#9;&#9;mCurrentHumanoid = humanoid
&#9;&#9;for _, anim in pairs(mAnimations) do
&#9;&#9;&#9;anim.CurrentTrack = humanoid:LoadAnimation(anim.CurrentAnim)
&#9;&#9;end
&#9;end

&#9;function this:getAnimation(ident)
&#9;&#9;local dat = mAnimations[ident]
&#9;&#9;if not dat then error(&quot;Gear Fatal Error: Animation `&quot;..ident..&quot;` not found&quot;) end
&#9;&#9;if not dat.CurrentTrack then 
&#9;&#9;&#9;error(&quot;Gear Fatal Error: No Humanoid for animation `&quot;..ident..&quot;` to run in&quot;) 
&#9;&#9;end
&#9;&#9;return dat.CurrentTrack
&#9;end
end)


----------------------------------------------
-- SoundProvider class
-- functions similarily to the animationprovider
----------------------------------------------
class&apos;SoundProvider&apos;(function(this)
&#9;local mSounds = {}

&#9;function this:registerSound(ident, assetid, inpart)
&#9;&#9;inpart = inpart or Tool.Tool:FindFirstChild(&apos;Handle&apos;)
&#9;&#9;if not inpart then
&#9;&#9;&#9;repeat
&#9;&#9;&#9;&#9;inpart = Tool.Tool.ChildAdded:wait()
&#9;&#9;&#9;until inpart.Name == &apos;Handle&apos;
&#9;&#9;end
&#9;&#9;local existingSound = inpart:FindFirstChild(&apos;SOUND_&apos;..ident)
&#9;&#9;local sounddat = {
&#9;&#9;&#9;SoundId = assetid,
&#9;&#9;&#9;CurrentSound = existingSound or Create&apos;Sound&apos;{
&#9;&#9;&#9;&#9;Name = &apos;SOUND_&apos;..ident,
&#9;&#9;&#9;&#9;SoundId = assetid,
&#9;&#9;&#9;&#9;Parent = inpart,
&#9;&#9;&#9;},
&#9;&#9;}
&#9;&#9;mSounds[ident] = sounddat
&#9;end

&#9;function this:getSound(ident)
&#9;&#9;local dat = mSounds[ident]
&#9;&#9;if dat then
&#9;&#9;&#9;return dat.CurrentSound
&#9;&#9;end
&#9;end
end)


----------------------------------------------
-- DebounceProvider class -- Prevent events
-- from happening in too rapid succession
----------------------------------------------
class&apos;DebounceProvider&apos;(function(this)
&#9;local mFlagNameToLastTime = {}

&#9;function this:test(ident, delta)
&#9;&#9;local t = tick()
&#9;&#9;local lastTime = mFlagNameToLastTime[ident] or 0
&#9;&#9;if delta then
&#9;&#9;&#9;return (t-lastTime) &gt; delta
&#9;&#9;else
&#9;&#9;&#9;return mFlagNameToLastTime[ident]
&#9;&#9;end
&#9;end
&#9;function this:set(ident, state)
&#9;&#9;if state then
&#9;&#9;&#9;mFlagNameToLastTime[ident] = state
&#9;&#9;elseif state == false then
&#9;&#9;&#9;mFlagNameToLastTime[ident] = false
&#9;&#9;else
&#9;&#9;&#9;mFlagNameToLastTime[ident] = tick()
&#9;&#9;end
&#9;end
end)


function TagHumanoid(humanoid)
&#9;if Tool.Player then
&#9;&#9;local tag = Create&apos;ObjectValue&apos;{
&#9;&#9;&#9;Name = &quot;creator&quot;, 
&#9;&#9;&#9;Value = Tool.Player,
&#9;&#9;&#9;Parent = humanoid,
&#9;&#9;}
&#9;&#9;Tool.Bin:add(function()
&#9;&#9;&#9;tag:Remove()
&#9;&#9;end, &apos;HumanoidTag&apos;)
&#9;end
end
function UntagHumanoid()
&#9;Tool.Bin:clean(&apos;HumanoidTag&apos;)
end


------- wait for any event in a set of events  to fire ------
function WaitForAny(tb)
&#9;local evt = tb
&#9;local conn = {}
&#9;local eventargs = nil
&#9;local waitProxy = Create&apos;BoolValue&apos;{}
&#9;for _, e in pairs(evt) do
&#9;&#9;local c = e:connect(function(...)
&#9;&#9;&#9;for _, c in pairs(conn) do
&#9;&#9;&#9;&#9;c:disconnect()
&#9;&#9;&#9;end
&#9;&#9;&#9;eventargs = {...}
&#9;&#9;&#9;waitProxy.Value = not waitProxy.Value
&#9;&#9;end)
&#9;&#9;conn[#conn+1] = c
&#9;end
&#9;--
&#9;waitProxy.Changed:wait()
&#9;--
&#9;return unpack(eventargs)
end


----------------------------------------------
-- Tool singleton class
--API:
-- ...
class&apos;Tool&apos;(nil, function(this)
&#9;--need this here for the animationprovider to use
&#9;this.HUGE_EQUIP_HACK = false

&#9;this.Bin = CreateBin()
&#9;this.AnimationProvider = CreateAnimationProvider()
&#9;this.DebounceProvider = CreateDebounceProvider()
&#9;this.SoundProvider = CreateSoundProvider()

&#9;--general values
&#9;this.Tool = script.Parent
&#9;this.Player = nil
&#9;this.Humanoid = nil
&#9;this.Character = nil

&#9;--============ several flags for the gear
&#9;--nothing

&#9;--some events
&#9;this.Equipped = CreateSignal()
&#9;this.Unequipped = CreateSignal()
&#9;this.OwnerChange = CreateSignal()

&#9;--mouse utility events
&#9;this.MouseClick = CreateSignal()
&#9;this.MouseDoubleClick = CreateSignal()
&#9;this.DoubleClickThreshold = 0.2
&#9;this.MouseDown = false
&#9;this.KeyDown = CreateSignal()

&#9;local mLastClickTime = 0

&#9;script.Parent.Equipped:connect(function(mouse)
&#9;&#9;--print(&quot;Internal Equipped: Time b: &quot;..time())
&#9;&#9;--set up general values in the tool
&#9;&#9;this.Mouse = mouse
&#9;&#9;local curOwner = game.Players:GetPlayerFromCharacter(script.Parent.Parent)
&#9;&#9;if curOwner ~= this.Player then
&#9;&#9;&#9;this.Player = curOwner
&#9;&#9;&#9;this.OwnerChange:fire(this.Player)
&#9;&#9;end
&#9;&#9;this.Character = this.Player.Character
&#9;&#9;this.Humanoid = this.Character.Humanoid
&#9;&#9;this.AnimationProvider:setHumanoid(this.Humanoid)

&#9;&#9;--set up the mouse events
&#9;&#9;mouse.Button1Down:connect(function()
&#9;&#9;&#9;this.MouseDown = true
&#9;&#9;&#9;local t = tick()
&#9;&#9;&#9;if (t-mLastClickTime) &lt; this.DoubleClickThreshold then
&#9;&#9;&#9;&#9;--prvent multiple double-clicks in a row
&#9;&#9;&#9;&#9;mLastClickTime = 0
&#9;&#9;&#9;&#9;this.MouseDoubleClick:fire(mouse)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;mLastClickTime = t
&#9;&#9;&#9;&#9;this.MouseClick:fire(mouse)
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;&#9;mouse.Button1Up:connect(function()
&#9;&#9;&#9;this.MouseDown = false
&#9;&#9;end)
&#9;&#9;mouse.KeyDown:connect(function(key)
&#9;&#9;&#9;this.KeyDown:fire(key)
&#9;&#9;end)

&#9;&#9;--done setup, call the equipped function
&#9;&#9;if this.HUGE_EQUIP_HACK then
&#9;&#9;&#9;--the HUGE_EQUIP_HACK flags tells the tool that the equip is a synchronous
&#9;&#9;&#9;--call as a result of parenting an animation to the character, which happens 
&#9;&#9;&#9;--when the tool is picked up from the workspace, but not during normal equips 
&#9;&#9;&#9;--(Why does this happen???), if this is the case, the call should be rederrred 
&#9;&#9;&#9;--one tick to ensure that all of the gear&apos;s loading can complete before it&apos;s 
&#9;&#9;&#9;--equipped event is called.
&#9;&#9;&#9;--TODO: Blame John for this.
&#9;&#9;&#9;Delay(0, function()
&#9;&#9;&#9;&#9;this.Equipped:fire(mouse)
&#9;&#9;&#9;end)
&#9;&#9;else
&#9;&#9;&#9;--otherwise, proceed as normal
&#9;&#9;&#9;this.Equipped:fire(mouse)
&#9;&#9;end
&#9;end)

&#9;script.Parent.Unequipped:connect(function()
&#9;&#9;--before my teardown, fire the event
&#9;&#9;this.Unequipped:fire()

&#9;&#9;--delete all my garbage
&#9;&#9;this.Bin:cleanAll()
&#9;end)
end)



























function CreateSentry(position)
&#9;local sentry = Create&apos;Model&apos;{
&#9;&#9;Name = (Tool.Player.Name..&quot;&apos;s Sentry&quot;),
&#9;&#9;Create&apos;Part&apos;{
&#9;&#9;&#9;Name = &quot;Torso&quot;,
&#9;&#9;&#9;FormFactor = &apos;Custom&apos;,
&#9;&#9;&#9;Size = Vector3.new(3.8, 1.2, 3.6),
&#9;&#9;&#9;Create&apos;SpecialMesh&apos;{
&#9;&#9;&#9;&#9;MeshId = &apos;http://www.roblox.com/asset/?id=68251550&apos;,
&#9;&#9;&#9;&#9;TextureId = &apos;http://www.roblox.com/asset/?id=68237809&apos;,
&#9;&#9;&#9;&#9;Scale = Vector3.new(2,2,2),
&#9;&#9;&#9;},
&#9;&#9;&#9;Create&apos;Motor6D&apos;{Name = &quot;Neck&quot;,},
&#9;&#9;},
&#9;&#9;Create&apos;Part&apos;{
&#9;&#9;&#9;Name = &quot;Head&quot;,
&#9;&#9;&#9;FormFactor = &apos;Custom&apos;,
&#9;&#9;&#9;Size = Vector3.new(2, 2, 2),
&#9;&#9;&#9;Create&apos;SpecialMesh&apos;{
&#9;&#9;&#9;&#9;MeshId = &apos;http://www.roblox.com/asset/?id=68237468&apos;,
&#9;&#9;&#9;&#9;TextureId = &apos;http://www.roblox.com/asset/?id=68237809&apos;,
&#9;&#9;&#9;&#9;Scale = Vector3.new(2,2,2),
&#9;&#9;&#9;},
&#9;&#9;&#9;Create&apos;Motor6D&apos;{Name = &quot;RightAttach&quot;,},
&#9;&#9;&#9;Create&apos;Motor6D&apos;{Name = &quot;LeftAttach&quot;,},
&#9;&#9;&#9;Create&apos;Motor6D&apos;{Name = &quot;CannonAttach&quot;,},
&#9;&#9;},
&#9;&#9;Create&apos;Part&apos;{
&#9;&#9;&#9;Name = &quot;CannonMove&quot;,
&#9;&#9;&#9;FormFactor = &apos;Custom&apos;,
&#9;&#9;&#9;Size = Vector3.new(0.2, 0.2, 0.2),
&#9;&#9;&#9;Create&apos;Motor6D&apos;{Name = &quot;Barrel1Attach&quot;,},
&#9;&#9;&#9;Create&apos;Motor6D&apos;{Name = &quot;Barrel2Attach&quot;,},
&#9;&#9;&#9;Create&apos;Sound&apos;{
&#9;&#9;&#9;&#9;Name = &quot;FireSound&quot;,
&#9;&#9;&#9;&#9;SoundId = &quot;http://www.roblox.com/asset/?id=68433873&quot;,
&#9;&#9;&#9;},
&#9;&#9;},
&#9;&#9;Create&apos;Part&apos;{
&#9;&#9;&#9;Name = &quot;Barrel1&quot;,
&#9;&#9;&#9;FormFactor = &apos;Custom&apos;,
&#9;&#9;&#9;Size = Vector3.new(0.6, 2, 0.6),
&#9;&#9;&#9;Create&apos;SpecialMesh&apos;{
&#9;&#9;&#9;&#9;MeshId = &apos;http://www.roblox.com/asset/?id=68251580&apos;,
&#9;&#9;&#9;&#9;TextureId = &apos;http://www.roblox.com/asset/?id=68237809&apos;,&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;Scale = Vector3.new(2,2,2),
&#9;&#9;&#9;},
&#9;&#9;},
&#9;&#9;Create&apos;Part&apos;{
&#9;&#9;&#9;Name = &quot;Barrel2&quot;,
&#9;&#9;&#9;FormFactor = &apos;Custom&apos;,
&#9;&#9;&#9;Size = Vector3.new(0.6, 2, 0.6),
&#9;&#9;&#9;Create&apos;SpecialMesh&apos;{
&#9;&#9;&#9;&#9;MeshId = &apos;http://www.roblox.com/asset/?id=68251580&apos;,
&#9;&#9;&#9;&#9;TextureId = &apos;http://www.roblox.com/asset/?id=68237809&apos;,&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;Scale = Vector3.new(2,2,2),
&#9;&#9;&#9;},
&#9;&#9;},
&#9;&#9;Create&apos;Part&apos;{
&#9;&#9;&#9;Name = &quot;FlangeLeft&quot;,
&#9;&#9;&#9;FormFactor = &apos;Custom&apos;,
&#9;&#9;&#9;Size = Vector3.new(1.2, 0.4, 3.6),
&#9;&#9;&#9;Create&apos;SpecialMesh&apos;{
&#9;&#9;&#9;&#9;MeshId = &apos;http://www.roblox.com/asset/?id=68237502&apos;,
&#9;&#9;&#9;&#9;TextureId = &apos;http://www.roblox.com/asset/?id=68237809&apos;,
&#9;&#9;&#9;&#9;Scale = Vector3.new(2,2,2),
&#9;&#9;&#9;},
&#9;&#9;},
&#9;&#9;Create&apos;Part&apos;{
&#9;&#9;&#9;Name = &quot;FlangeRight&quot;,
&#9;&#9;&#9;FormFactor = &apos;Custom&apos;,
&#9;&#9;&#9;Size = Vector3.new(1.2, 0.4, 3.6),
&#9;&#9;&#9;Create&apos;SpecialMesh&apos;{
&#9;&#9;&#9;&#9;MeshId = &apos;http://www.roblox.com/asset/?id=68237527&apos;,
&#9;&#9;&#9;&#9;TextureId = &apos;http://www.roblox.com/asset/?id=68237809&apos;,
&#9;&#9;&#9;&#9;Scale = Vector3.new(2,2,2),
&#9;&#9;&#9;},
&#9;&#9;},
&#9;&#9;Create&apos;Part&apos;{
&#9;&#9;&#9;Name = &quot;SideLeft&quot;,
&#9;&#9;&#9;FormFactor = &apos;Custom&apos;,
&#9;&#9;&#9;Size = Vector3.new(1.4, 2.8, 1.2),
&#9;&#9;&#9;Create&apos;SpecialMesh&apos;{
&#9;&#9;&#9;&#9;MeshId = &apos;http://www.roblox.com/asset/?id=68237451&apos;,
&#9;&#9;&#9;&#9;TextureId = &apos;http://www.roblox.com/asset/?id=68237809&apos;,
&#9;&#9;&#9;&#9;Scale = Vector3.new(2,2,2),
&#9;&#9;&#9;},
&#9;&#9;&#9;Create&apos;Motor6D&apos;{Name = &quot;FlangeAttach&quot;,},
&#9;&#9;},
&#9;&#9;Create&apos;Part&apos;{
&#9;&#9;&#9;Name = &quot;SideRight&quot;,
&#9;&#9;&#9;FormFactor = &apos;Custom&apos;,
&#9;&#9;&#9;Size = Vector3.new(1.4, 2.8, 1.2),
&#9;&#9;&#9;Create&apos;SpecialMesh&apos;{
&#9;&#9;&#9;&#9;MeshId = &apos;http://www.roblox.com/asset/?id=68237486&apos;,
&#9;&#9;&#9;&#9;TextureId = &apos;http://www.roblox.com/asset/?id=68237809&apos;,
&#9;&#9;&#9;&#9;Scale = Vector3.new(2,2,2),
&#9;&#9;&#9;},
&#9;&#9;&#9;Create&apos;Motor6D&apos;{Name = &quot;FlangeAttach&quot;,},
&#9;&#9;},
&#9;&#9;Create&apos;ObjectValue&apos;{
&#9;&#9;&#9;Name = &quot;TurretOwner&quot;,
&#9;&#9;&#9;Value = Tool.Player,&#9;
&#9;&#9;},
&#9;}
&#9;---------------------------
&#9;local neck = sentry.Torso.Neck
&#9;neck.Part0 = sentry.Torso
&#9;neck.Part1 = sentry.Head
&#9;neck.C0 = CFrame.new(0, 0.4, 0.1)*CFrame.Angles(-math.pi/2, 0, 0)
&#9;neck.C1 = CFrame.new(0, 0, -1)
&#9;--
&#9;local cannonm = sentry.Head.CannonAttach
&#9;cannonm.Part0 = sentry.Head
&#9;cannonm.Part1 = sentry.CannonMove
&#9;cannonm.C0 = CFrame.new(0, 0.6, 0.2)*CFrame.Angles(math.pi/2, 0, 0)
&#9;--
&#9;local barrel1 = sentry.CannonMove.Barrel1Attach
&#9;barrel1.Part0 = sentry.CannonMove
&#9;barrel1.Part1 = sentry.Barrel1
&#9;barrel1.C0 = CFrame.new(0, 0.3, -1)*CFrame.Angles(-math.pi/2, 0, 0)
&#9;--
&#9;local barrel2 = sentry.CannonMove.Barrel2Attach
&#9;barrel2.Part0 = sentry.CannonMove
&#9;barrel2.Part1 = sentry.Barrel2
&#9;barrel2.C0 = CFrame.new(0, -0.3, -1)*CFrame.Angles(-math.pi/2, 0, 0)
&#9;--
&#9;local rightm = sentry.Head.RightAttach
&#9;rightm.Part0 = sentry.Head
&#9;rightm.Part1 = sentry.SideRight
&#9;rightm.C0 = CFrame.new(1.7, -0.4, 0.4)
&#9;--
&#9;local leftm = sentry.Head.LeftAttach
&#9;leftm.Part0 = sentry.Head
&#9;leftm.Part1 = sentry.SideLeft
&#9;leftm.C0 = CFrame.new(-1.6, -0.4, 0.4)
&#9;--
&#9;local flangel = sentry.SideLeft.FlangeAttach
&#9;flangel.Part0 = sentry.SideLeft
&#9;flangel.Part1 = sentry.FlangeLeft
&#9;flangel.C0 = CFrame.new(0.7, 1.4, 0.05)
&#9;--
&#9;local flanger = sentry.SideRight.FlangeAttach
&#9;flanger.Part0 = sentry.SideRight
&#9;flanger.Part1 = sentry.FlangeRight
&#9;flanger.C0 = CFrame.new(-0.7, 1.4, 0.05)
&#9;--
&#9;local humanoid = Create&apos;Humanoid&apos;{
&#9;&#9;MaxHealth = 200,
&#9;&#9;Health = 200,
&#9;&#9;Torso = sentry.Torso,
&#9;&#9;Parent = sentry,
&#9;}
&#9;--

&#9;--make the main runner script
&#9;local runner = Tool.Tool.SentryTurret_Sentry:Clone()
&#9;local runnerTarget = Create&apos;ObjectValue&apos;{
&#9;&#9;Name = &apos;MyTargetTurret&apos;,
&#9;&#9;Value = sentry,
&#9;&#9;Parent = runner,
&#9;}
&#9;runner.Parent = Tool.Player.Character

&#9;--make the cleaner script
&#9;local cleaner = Tool.Tool.SentryTurret_SentryCleanup:Clone()
&#9;cleaner.Parent = sentry

&#9;--now done, put it in the right place in the workspace
&#9;sentry.Torso.CFrame = CFrame.new(position)
&#9;sentry.Parent = game.Workspace

&#9;runner.Disabled = false
&#9;cleaner.Disabled = false

&#9;return sentry
end


--gui
local Gui = Create&apos;ScreenGui&apos;{
&#9;Name = &quot;SentryTurret_Gui&quot;,
&#9;Create&apos;TextButton&apos;{
&#9;&#9;Name = &quot;DestroyButton&quot;,
&#9;&#9;Style = &apos;RobloxButton&apos;,
&#9;&#9;Font = &apos;Arial&apos;,
&#9;&#9;FontSize = &apos;Size24&apos;,
&#9;&#9;Text = &quot;Destroy Current Turret\n(Press `Q`)&quot;,
&#9;&#9;Position = UDim2.new(0, 0, 0.5, -128),
&#9;&#9;Size = UDim2.new(0, 128, 0, 128),
&#9;&#9;TextWrap = true,
&#9;&#9;TextColor3 = Color3.new(1,1,1),
&#9;},
}


--create or get the value to track the current sentry (deffered to on equip)
local SentryValue
local SentryTargetValue


--utility check
function HasSentry()
&#9;return (SentryValue.Value ~= nil) and 
&#9;       (SentryValue.Value:FindFirstChild(&quot;Humanoid&quot;)) and
&#9;       (SentryValue.Value.Humanoid.Health &gt; 0)
end


--create a sentry at a position and register it to this tool
function BuildSentry(position)
&#9;--remove any old sentry
&#9;if SentryValue.Value ~= nil then
&#9;&#9;local humanoid = SentryValue.Value:FindFirstChild(&quot;Humanoid&quot;)
&#9;&#9;if humanoid then
&#9;&#9;&#9;--kill the turret
&#9;&#9;&#9;humanoid.Health = 0
&#9;&#9;else
&#9;&#9;&#9;--something terrible happened, just delete it
&#9;&#9;&#9;SentryValue.Value:Destroy()
&#9;&#9;&#9;SentryValue.Value = nil
&#9;&#9;end
&#9;end

&#9;--now create a new one
&#9;local new = CreateSentry(position)
&#9;SentryValue.Value = new
end


function DestroySentry()
&#9;if SentryValue.Value then
&#9;&#9;local hum = SentryValue.Value:FindFirstChild(&quot;Humanoid&quot;)
&#9;&#9;if hum then
&#9;&#9;&#9;hum.Health = 0
&#9;&#9;else
&#9;&#9;&#9;SentryValue.Value:Destroy()
&#9;&#9;end
&#9;&#9;SentryValue.Value = nil
&#9;end
end


--call on destroying code
Gui.DestroyButton.MouseButton1Down:connect(function()
&#9;DestroySentry()
end)
Tool.KeyDown:connect(function(key)
&#9;if key:lower() == &quot;q&quot; then
&#9;&#9;DestroySentry()
&#9;end
end)


local Equipped = false

Tool.Equipped:connect(function()
&#9;Gui.Parent = Tool.Player.PlayerGui
&#9;Equipped = true
&#9;if not Tool.Player:FindFirstChild(&quot;SentryValue&quot;) then
&#9;&#9;Create&apos;ObjectValue&apos;{
&#9;&#9;&#9;Name = &quot;SentryValue&quot;,
&#9;&#9;&#9;Parent = Tool.Player,
&#9;&#9;}
&#9;end
&#9;if not Tool.Player:FindFirstChild(&quot;SentryTargetValue&quot;) then
&#9;&#9;Create&apos;ObjectValue&apos;{
&#9;&#9;&#9;Name = &quot;SentryTargetValue&quot;,
&#9;&#9;&#9;Parent = Tool.Player,
&#9;&#9;}
&#9;end
&#9;SentryTargetValue = Tool.Player.SentryTargetValue
&#9;SentryValue = Tool.Player.SentryValue

&#9;while Equipped do
&#9;&#9;wait()
&#9;&#9;if SentryValue.Value then
&#9;&#9;&#9;local trg = Tool.Mouse.Target
&#9;&#9;&#9;local foundHum = false
&#9;&#9;&#9;if trg and trg.Parent and trg.Parent.Parent then
&#9;&#9;&#9;&#9;local hum = trg.Parent:FindFirstChild(&quot;Humanoid&quot;)
&#9;&#9;&#9;&#9;hum = hum or trg.Parent.Parent:FindFirstChild(&quot;Humanoid&quot;)
&#9;&#9;&#9;&#9;--
&#9;&#9;&#9;&#9;if hum then
&#9;&#9;&#9;&#9;&#9;foundHum = true
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;if foundHum then
&#9;&#9;&#9;&#9;--found target
&#9;&#9;&#9;&#9;Tool.Mouse.Icon = &quot;http://www.roblox.com/asset/?id=68414013&quot;
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;--no target
&#9;&#9;&#9;&#9;Tool.Mouse.Icon = &quot;http://www.roblox.com/asset/?id=68414005&quot;
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;if (Tool.Mouse.Hit.p-Tool.Character.Torso.Position).magnitude &gt; 20 then
&#9;&#9;&#9;&#9;--out of range
&#9;&#9;&#9;&#9;Tool.Mouse.Icon = &quot;http://www.roblox.com/asset/?id=68415132&quot;
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;--build icon
&#9;&#9;&#9;&#9;Tool.Mouse.Icon = &quot;http://www.roblox.com/asset/?id=68413998&quot;
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end)
Tool.Unequipped:connect(function()
&#9;Gui.Parent = nil
&#9;Equipped = false
end)


Tool.MouseClick:connect(function()
&#9;if SentryValue.Value then
&#9;&#9;local trg = Tool.Mouse.Target
&#9;&#9;if trg and trg.Parent and trg.Parent.Parent then
&#9;&#9;&#9;local hum = trg.Parent:FindFirstChild(&quot;Humanoid&quot;)
&#9;&#9;&#9;hum = hum or trg.Parent.Parent:FindFirstChild(&quot;Humanoid&quot;)
&#9;&#9;&#9;--
&#9;&#9;&#9;if hum then
&#9;&#9;&#9;&#9;SentryTargetValue.Value = hum
&#9;&#9;&#9;end
&#9;&#9;end
&#9;else
&#9;&#9;if (Tool.Mouse.Hit.p-Tool.Character.Torso.Position).magnitude &lt; 20 then
&#9;&#9;&#9;BuildSentry(Tool.Mouse.Hit.p)
&#9;&#9;end
&#9;end
end)


script.Parent.Grip = CFrame.Angles(math.pi/2, 0, 0)*CFrame.new(-0.1, -0.7, 0.1)
while not script.Parent:FindFirstChild(&quot;Handle&quot;) do
&#9;script.Parent.ChildAdded:wait()
end
--edit handle
local Handle = script.Parent.Handle
Handle.Mesh.TextureId = &quot;http://www.roblox.com/asset/?id=16884673&quot;
Handle.Mesh.MeshId = &quot;http://www.roblox.com/asset/?id=16884681&quot;
Handle.Mesh.Scale = Vector3.new(1, 1, 1)
Handle.Size = Vector3.new(1, 1, 4)</ProtectedString>
			</Properties>
		</Item>
		<Item class="LocalScript" referent="RBX6">
			<Properties>
				<bool name="Disabled">true</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">SentryTurret_Sentry</string>
				<ProtectedString name="Source">function Create(ty)
&#9;return function(data)
&#9;&#9;local obj = Instance.new(ty)
&#9;&#9;for k, v in pairs(data) do
&#9;&#9;&#9;if type(k) == &apos;number&apos; then
&#9;&#9;&#9;&#9;v.Parent = obj
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;obj[k] = v
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;return obj
&#9;end
end

local function class(name)
&#9;local def = {}
&#9;getfenv(0)[name] = def
&#9;return function(ctor, static)
&#9;&#9;local nctor = function(...)
&#9;&#9;&#9;local this = {}
&#9;&#9;&#9;if ctor then
&#9;&#9;&#9;&#9;ctor(this, ...)
&#9;&#9;&#9;end
&#9;&#9;&#9;return this
&#9;&#9;end
&#9;&#9;getfenv(0)[&apos;Create&apos;..name] = nctor
&#9;&#9;if static then static(def) end
&#9;end
end

class&apos;Bin&apos;(function(this)
&#9;local mGarbage = {}

&#9;function this:add(func, ident)
&#9;&#9;ident = ident or &apos;__unnamed&apos;
&#9;&#9;if not mGarbage[ident] then
&#9;&#9;&#9;mGarbage[ident] = {}
&#9;&#9;end
&#9;&#9;mGarbage[ident][#mGarbage[ident]+1] = func
&#9;end

&#9;function this:clean(ident)
&#9;&#9;local listToCall = mGarbage[ident]
&#9;&#9;if listToCall then
&#9;&#9;&#9;for _, func in pairs(listToCall) do
&#9;&#9;&#9;&#9;func()
&#9;&#9;&#9;end
&#9;&#9;&#9;mGarbage[ident] = nil
&#9;&#9;end
&#9;end

&#9;function this:cleanAll()
&#9;&#9;for ident, list in pairs(mGarbage) do
&#9;&#9;&#9;for _, func in pairs(list) do
&#9;&#9;&#9;&#9;func()
&#9;&#9;&#9;end
&#9;&#9;&#9;mGarbage[ident] = nil
&#9;&#9;end
&#9;end
end)

local Bin = CreateBin()

--------------------------------------------------
--                    settings                  --
local MaxRange = 30
local ReloadTime = 0.5
local DamagePerShot = 7
--                                              --
--------------------------------------------------

--game.Workspace.ErrorOut.Value = game.Workspace.ErrorOut.Value..&quot;(( SentryScript Running &quot;

while not script:FindFirstChild(&quot;MyTargetTurret&quot;) do script.ChildAdded:wait() end
local Model = script.MyTargetTurret.Value
local Humanoid = Model:FindFirstChild(&quot;Humanoid&quot;)
local Player = (Model:FindFirstChild(&quot;TurretOwner&quot;) or {}).Value
local PlayerTurretValue = (Player or game):FindFirstChild(&quot;SentryValue&quot;)
local PlayerTurretTargetValue = (Player or game):FindFirstChild(&quot;SentryTargetValue&quot;)
--
local CannonPart = Model:FindFirstChild(&quot;CannonMove&quot;)
local TorsoPart = Model:FindFirstChild(&quot;Torso&quot;)
local HeadPart = Model:FindFirstChild(&quot;Head&quot;)
local TorsoToHead = (TorsoPart or game):FindFirstChild(&quot;Neck&quot;)
local HeadToCannon = (HeadPart or game):FindFirstChild(&quot;CannonAttach&quot;)
local FireSound = (CannonPart or game):FindFirstChild(&quot;FireSound&quot;)

if not (Model and Humanoid and Player and PlayerTurretValue and PlayerTurretTargetValue and
        CannonPart and TorsoPart and HeadPart and TorsoToHead and HeadToCannon and FireSound) 
then
&#9;print(&quot;FATAL: Sentry setup failed, destroying turret!&quot;)
&#9;Model:Destroy()
&#9;Model.Parent = nil
end

--prevent double init
local INITED_HACK = (Model:FindFirstChild(&quot;INITED_HACK&quot;))
if not INITED_HACK then
&#9;Create&apos;IntValue&apos;{
&#9;&#9;Name = &quot;INITED_HACK&quot;,
&#9;&#9;Parent = Model,
&#9;}
end
--game.Workspace.ErrorOut.Value = game.Workspace.ErrorOut.Value..&quot;... with&quot;..(INITED_HACK and &quot;out&quot; or &quot;&quot;)..&quot; INIT ))&quot;


local UnfoldAnimDef = Create&apos;Animation&apos;{
&#9;Parent = Model,
&#9;AnimationId = &quot;http://www.roblox.com/asset/?id=68433924&quot;,
}
local FireAnim1Def = Create&apos;Animation&apos;{
&#9;Parent = Model,
&#9;AnimationId = &quot;http://www.roblox.com/asset/?id=68433992&quot;,
}
local FireAnim2Def = Create&apos;Animation&apos;{
&#9;Parent = Model,
&#9;AnimationId = &quot;http://www.roblox.com/asset/?id=68433974&quot;,
}
local UnfoldAnim = Humanoid:LoadAnimation(UnfoldAnimDef)
local FireAnim1 = Humanoid:LoadAnimation(FireAnim1Def)
local FireAnim2 = Humanoid:LoadAnimation(FireAnim2Def)

if not INITED_HACK then
&#9;UnfoldAnim:Play(0, 1, 1)
end

function TagHumanoid(humanoid)
&#9;local tag = Create&apos;ObjectValue&apos;{
&#9;&#9;Name = &quot;creator&quot;, 
&#9;&#9;Value = Player,
&#9;&#9;Parent = humanoid,
&#9;}
&#9;game.Debris:AddItem(tag, 2)
end


Humanoid.Died:connect(function()
&#9;script:Destroy()
end)


---fire from point
local whichFireFrom = true
local function GetFireFrom()
&#9;local dir = (whichFireFrom and 1 or -1)
&#9;return CannonPart.CFrame*CFrame.new(0,dir*0.3,-1.8)
end
local function GetFireAnim()
&#9;if whichFireFrom then
&#9;&#9;return FireAnim1
&#9;else
&#9;&#9;return FireAnim2
&#9;end
end
local function SwitchFireFrom()
&#9;whichFireFrom = not whichFireFrom
end


function ShowShot(from, to)
&#9;local shotBlast = Create&apos;Part&apos;{
&#9;&#9;Name = &quot;ShotBlast&quot;,
&#9;&#9;CanCollide = false,
&#9;&#9;Anchored = true,
&#9;&#9;Parent = Model,
&#9;&#9;FormFactor = &apos;Custom&apos;,
&#9;&#9;Size = Vector3.new(0.5, 0.5, 1.5),
&#9;&#9;BrickColor = BrickColor.new(21),
&#9;&#9;Transparency = 0.3,
&#9;&#9;Create&apos;SpecialMesh&apos;{
&#9;&#9;&#9;MeshType = &apos;Sphere&apos;,
&#9;&#9;},
&#9;&#9;Create&apos;Fire&apos;{
&#9;&#9;&#9;Size = 0,
&#9;&#9;&#9;Heat = 0,
&#9;&#9;},
&#9;}
&#9;local shotLance = Create&apos;Part&apos;{
&#9;&#9;Name = &quot;ShotLance&quot;,
&#9;&#9;CanCollide = false,
&#9;&#9;Anchored = true,
&#9;&#9;Parent = Model,
&#9;&#9;FormFactor = &apos;Custom&apos;,
&#9;&#9;BrickColor = BrickColor.new(21),
&#9;&#9;Size = Vector3.new(0.2, 0.2, (from-to).magnitude),
&#9;&#9;Transparency = 0.3,
&#9;}
&#9;shotBlast.CFrame = CFrame.new(from, to)
&#9;shotLance.CFrame = CFrame.new(from, to)*CFrame.new(0, 0, -(from-to).magnitude/2)
&#9;--
&#9;game.Debris:AddItem(shotBlast, 0.5)
&#9;game.Debris:AddItem(shotLance, 0.5)
&#9;game.Debris:AddItem(shotBlast.Fire, 0.2)
&#9;--
&#9;Spawn(function()
&#9;&#9;for i = 0.3, 1, 0.05 do
&#9;&#9;&#9;wait()
&#9;&#9;&#9;shotBlast.Transparency = i
&#9;&#9;&#9;shotLance.Transparency = i
&#9;&#9;end
&#9;&#9;shotBlast:Destroy()
&#9;&#9;shotLance:Destroy()
&#9;end)
end


local PivotOffsetFromHead = CFrame.new(0, 0.4, 0.1)*CFrame.Angles(-math.pi/2, 0, 0)
local HeadOffsetFromPivot = CFrame.new(0, 0, -1)
local GunOffsetFromHead = CFrame.new(0, 0.6, 0.2)*CFrame.Angles(math.pi/2, 0, 0)
function AimAt(pos)
&#9;--edit the swivel joint
&#9;--[[local originalHeadPos = (TorsoPart.CFrame*TorsoToHead.C0*TorsoToHeadAnimMod).p
&#9;local desiredCFrame = CFrame.new(originalHeadPos, 
&#9;                                 Vector3.new(pos.x, originalHeadPos.y, pos.z))*
&#9;                      CFrame.Angles(-math.pi/2, 0, 0)
&#9;TorsoToHead.C1 = desiredCFrame:inverse()*
&#9;                 TorsoPart.CFrame*
&#9;                 TorsoToHead.C0*
&#9;                 TorsoToHeadAnimMod
&#9;]]
&#9;local headPivot = TorsoPart.CFrame*PivotOffsetFromHead
&#9;local desiredCF = CFrame.new(headPivot.p, Vector3.new(pos.x, headPivot.p.y, pos.z))
&#9;desiredCF = desiredCF*CFrame.Angles(-math.pi/2, 0, 0)
&#9;TorsoToHead.C1 = HeadOffsetFromPivot*(desiredCF:inverse()*headPivot)
&#9;--
&#9;local gunPivot = HeadPart.CFrame*GunOffsetFromHead
&#9;local desiredCF = CFrame.new(gunPivot.p, pos)
&#9;HeadToCannon.C1 = desiredCF:inverse()*gunPivot
end

function GetTarget(targetPos)
&#9;local from = GetFireFrom().p
&#9;local ray = Ray.new(from, (targetPos-from))
&#9;local part, hit = game.Workspace:FindPartOnRay(ray, Model)
&#9;--if part then
&#9;--&#9;print(&quot;Hit part&quot;, part, &quot;in&quot;, part.Parent)
&#9;--end
&#9;if part then
&#9;&#9;--if it&apos;s part of a humanoid, or a humanoid&apos;s gear/hats
&#9;&#9;local hum = (part.Parent or game):FindFirstChild(&apos;Humanoid&apos;)
&#9;&#9;hum = hum or ((part.Parent or game).Parent or game):FindFirstChild(&apos;Humanoid&apos;)
&#9;&#9;if hum then
&#9;&#9;&#9;return hum, (hit-from).magnitude, hit
&#9;&#9;end
&#9;end
end


function InflictDamageOn(hum)
&#9;TagHumanoid(hum)
&#9;hum:TakeDamage(DamagePerShot)
&#9;GetFireAnim():Play(0, 1, 5)
&#9;FireSound:Play()
end


local mLastShotTime = 0

if not INITED_HACK then
&#9;repeat until UnfoldAnim.KeyframeReached:wait() == &apos;complete&apos;
&#9;wait()
end

--local beforeErr = &quot;&quot;
while true do
&#9;wait()

&#9;--local st, err = pcall(function()
&#9;local didAttackOnTarget = false

&#9;if PlayerTurretTargetValue.Value then
&#9;&#9;local hum = PlayerTurretTargetValue.Value
&#9;&#9;if hum.Health &gt; 0 then
&#9;&#9;&#9;local torso = (hum.Parent or game):FindFirstChild(&quot;Torso&quot;)
&#9;&#9;&#9;--find biggest part to target in the thing if no torso exists
&#9;&#9;&#9;if not torso and hum.Parent then
&#9;&#9;&#9;&#9;local largestPart = nil
&#9;&#9;&#9;&#9;local largestSize = -1
&#9;&#9;&#9;&#9;for _, p in pairs(hum.Parent:GetChildren()) do
&#9;&#9;&#9;&#9;&#9;if p:IsA(&apos;BasePart&apos;) then
&#9;&#9;&#9;&#9;&#9;&#9;--beforeErr = &quot;281&quot;
&#9;&#9;&#9;&#9;&#9;&#9;if p.Size.magnitude &gt; largestSize then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;largestPart = p
&#9;&#9;&#9;&#9;&#9;&#9;&#9;largestSize = p.Size.magnitude
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;--
&#9;&#9;&#9;&#9;torso = largestPart
&#9;&#9;&#9;end
&#9;&#9;&#9;--beforeErr = &quot;291&quot;
&#9;&#9;&#9;--make sure there were any parts at all
&#9;&#9;&#9;if torso then
&#9;&#9;&#9;&#9;if hum ~= Humanoid then
&#9;&#9;&#9;&#9;&#9;AimAt(torso.Position)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;local hum, dist, hitPos = GetTarget(torso.Position)
&#9;&#9;&#9;&#9;if hum and hum ~= Humanoid and dist &lt; MaxRange then
&#9;&#9;&#9;&#9;&#9;AimAt(hitPos)
&#9;&#9;&#9;&#9;&#9;didAttackOnTarget = true
&#9;&#9;&#9;&#9;&#9;if (tick()-mLastShotTime) &gt; ReloadTime then
&#9;&#9;&#9;&#9;&#9;&#9;ShowShot(GetFireFrom().p, hitPos)
&#9;&#9;&#9;&#9;&#9;&#9;InflictDamageOn(hum)
&#9;&#9;&#9;&#9;&#9;&#9;SwitchFireFrom()
&#9;&#9;&#9;&#9;&#9;&#9;mLastShotTime = tick()
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;if not didAttackOnTarget then
&#9;&#9;--do targeting
&#9;&#9;local targets = {}

&#9;&#9;--gather all possible targets
&#9;&#9;local fireFrom = GetFireFrom().p
&#9;&#9;local targetAtAll = nil --if all else fails, aim at this thing
&#9;&#9;for _, p in pairs(game.Players:GetChildren()) do
&#9;&#9;&#9;if p ~= Player then
&#9;&#9;&#9;&#9;if p.Character and p.Character:FindFirstChild(&apos;Torso&apos;) then
&#9;&#9;&#9;&#9;&#9;local targetPos = p.Character.Torso.Position
&#9;&#9;&#9;&#9;&#9;--skip raycasting if the target is too far away
&#9;&#9;&#9;&#9;&#9;--beforeErr = tostring(fireFrom)..&quot;,&quot;..tostring(targetPos)
&#9;&#9;&#9;&#9;&#9;if (fireFrom - targetPos).magnitude &gt; MaxRange*2 then
&#9;&#9;&#9;&#9;&#9;&#9;targetAtAll = targetPos
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;--beforeErr = beforeErr..&quot;|328&quot;
&#9;&#9;&#9;&#9;&#9;&#9;AimAt(targetPos)
&#9;&#9;&#9;&#9;&#9;&#9;--beforeErr = beforeErr..&quot;|330&quot;
&#9;&#9;&#9;&#9;&#9;&#9;local hum, dist, hit = GetTarget(targetPos)
&#9;&#9;&#9;&#9;&#9;&#9;if hum and hum ~= Humanoid and dist &lt; MaxRange then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;targets[hum] = hit
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;--beforeErr = beforeErr..&quot;|340&quot;
&#9;&#9;--if there are any targets available
&#9;&#9;if next(targets) then
&#9;&#9;&#9;--find the lowest health one, the best to try killing
&#9;&#9;&#9;local lowestHealth = 10000
&#9;&#9;&#9;local lowestHealthHum = nil
&#9;&#9;&#9;for p, _ in pairs(targets) do
&#9;&#9;&#9;&#9;if p.Health &lt; lowestHealth then
&#9;&#9;&#9;&#9;&#9;lowestHealth = p.Health
&#9;&#9;&#9;&#9;&#9;lowestHealthHum = p
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end

&#9;&#9;&#9;local to = targets[lowestHealthHum]
&#9;&#9;&#9;AimAt(to)
&#9;&#9;&#9;if (tick()-mLastShotTime) &gt; ReloadTime then
&#9;&#9;&#9;&#9;ShowShot(GetFireFrom().p, to)
&#9;&#9;&#9;&#9;InflictDamageOn(lowestHealthHum)
&#9;&#9;&#9;&#9;SwitchFireFrom()
&#9;&#9;&#9;&#9;mLastShotTime = tick()
&#9;&#9;&#9;end
&#9;&#9;elseif targetAtAll then
&#9;&#9;&#9;--all else failed, just point at something
&#9;&#9;&#9;AimAt(targetAtAll)
&#9;&#9;end
&#9;end
&#9;--end)
&#9;--if not st then 
&#9;--game.Workspace.ErrorOut.Value = game.Workspace.ErrorOut.Value..&quot;[:&quot;..beforeErr..&quot;: &quot;..err..&quot;]&quot;
&#9;--break
&#9;--end
end

--script.Name = &quot;RUNNING_&quot;..script.Name</ProtectedString>
			</Properties>
		</Item>
		<Item class="Camera" referent="RBX7">
			<Properties>
				<Ref name="CameraSubject">null</Ref>
				<token name="CameraType">0</token>
				<CoordinateFrame name="CoordinateFrame">
					<X>-1.6521616</X>
					<Y>47.4741974</Y>
					<Z>-3.48770618</Z>
					<R00>0.783694625</R00>
					<R01>-0.08107429</R01>
					<R02>0.615832627</R02>
					<R10>-0</R10>
					<R11>0.991445303</R11>
					<R12>0.130523637</R12>
					<R20>-0.621146441</R20>
					<R21>-0.102290675</R21>
					<R22>0.776990175</R22>
				</CoordinateFrame>
				<CoordinateFrame name="Focus">
					<X>-13.9688139</X>
					<Y>44.8637238</Y>
					<Z>-19.0275097</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<string name="Name">ThumbnailCamera</string>
			</Properties>
		</Item>
	</Item>
</roblox>